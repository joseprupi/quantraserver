#!/usr/bin/env python3
"""
Generate OpenAPI 3.0 specification from FlatBuffers-generated JSON schemas.

This script:
1. Reads JSON schemas generated by `flatc --jsonschema`
2. Combines them into a complete OpenAPI 3.0 spec
3. Generates HTML documentation using ReDoc and Swagger UI

Usage:
    python3 scripts/generate_openapi.py
    
Output:
    - jsonserver/openapi/openapi3.yaml  - OpenAPI 3.0 spec
    - jsonserver/openapi/openapi3.json  - OpenAPI 3.0 spec (JSON)
    - jsonserver/openapi/docs.html      - ReDoc HTML documentation
    - jsonserver/openapi/swagger.html   - Swagger UI documentation
"""

import json
import yaml
import os
import re
from pathlib import Path
from typing import Dict, Any, List, Optional
from collections import OrderedDict


# =============================================================================
# Configuration
# =============================================================================

WORKSPACE = Path(__file__).parent.parent
JSON_SCHEMA_DIR = WORKSPACE / "flatbuffers" / "json"
OUTPUT_DIR = WORKSPACE / "jsonserver" / "openapi"

# API Info
API_INFO = {
    "title": "Quantra Pricing API",
    "description": """
## QuantLib-powered Financial Instrument Pricing API

Quantra provides a high-performance JSON HTTP API for pricing financial instruments using the QuantLib library.

### Supported Products

| Product | Endpoint | Description |
|---------|----------|-------------|
| Fixed Rate Bond | `/price-fixed-rate-bond` | Price fixed coupon bonds |
| Floating Rate Bond | `/price-floating-rate-bond` | Price floating rate notes |
| Vanilla Swap | `/price-vanilla-swap` | Price interest rate swaps |
| FRA | `/price-fra` | Price forward rate agreements |
| Cap/Floor | `/price-cap-floor` | Price interest rate caps and floors |
| Swaption | `/price-swaption` | Price swaptions |
| CDS | `/price-cds` | Price credit default swaps |

### Architecture

```
Client (JSON) → JSON Server (HTTP:8080) → gRPC Server (:50051) → QuantLib
```

### Quick Start

```bash
# Health check
curl http://localhost:8080/health

# Price a fixed rate bond
curl -X POST http://localhost:8080/price-fixed-rate-bond \\
  -H "Content-Type: application/json" \\
  -d @examples/data/fixed_rate_bond_request.json
```
""",
    "version": "1.0.0",
    "contact": {
        "name": "Quantra API Support",
        "url": "https://github.com/jmelo11/quantra"
    },
    "license": {
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT"
    }
}

# Endpoint definitions - maps endpoint to request/response schema names
# These must match exactly what FlatBuffers generates in the JSON schemas
ENDPOINTS = {
    "/price-fixed-rate-bond": {
        "summary": "Price Fixed Rate Bond",
        "description": "Calculate NPV, clean/dirty price, yield, duration, and convexity for fixed coupon bonds.",
        "request_schema": "quantra_PriceFixedRateBondRequest",
        "response_schema": "quantra_PriceFixedRateBondResponse",
        "tags": ["Bonds"]
    },
    "/price-floating-rate-bond": {
        "summary": "Price Floating Rate Bond",
        "description": "Calculate NPV and analytics for floating rate notes with IBOR index linkage.",
        "request_schema": "quantra_PriceFloatingRateBondRequest",
        "response_schema": "quantra_PriceFloatingRateBondResponse",
        "tags": ["Bonds"]
    },
    "/price-vanilla-swap": {
        "summary": "Price Vanilla Interest Rate Swap",
        "description": "Calculate NPV and fair rate for fixed-for-floating interest rate swaps.",
        "request_schema": "quantra_PriceVanillaSwapRequest",
        "response_schema": "quantra_PriceVanillaSwapResponse",
        "tags": ["Interest Rate Derivatives"]
    },
    "/price-fra": {
        "summary": "Price Forward Rate Agreement",
        "description": "Calculate NPV and forward rate for FRAs.",
        "request_schema": "quantra_PriceFRARequest",
        "response_schema": "quantra_PriceFRAResponse",
        "tags": ["Interest Rate Derivatives"]
    },
    "/price-cap-floor": {
        "summary": "Price Interest Rate Cap/Floor",
        "description": "Calculate NPV for interest rate caps, floors, and collars using Black model.",
        "request_schema": "quantra_PriceCapFloorRequest",
        "response_schema": "quantra_PriceCapFloorResponse",
        "tags": ["Interest Rate Derivatives"]
    },
    "/price-swaption": {
        "summary": "Price Swaption",
        "description": "Calculate NPV for European swaptions using Black model.",
        "request_schema": "quantra_PriceSwaptionRequest",
        "response_schema": "quantra_PriceSwaptionResponse",
        "tags": ["Interest Rate Derivatives"]
    },
    "/price-cds": {
        "summary": "Price Credit Default Swap",
        "description": "Calculate NPV and fair spread for CDS contracts.",
        "request_schema": "quantra_PriceCDSRequest",
        "response_schema": "quantra_PriceCDSResponse",
        "tags": ["Credit Derivatives"]
    }
}


# =============================================================================
# Schema Loading and Conversion
# =============================================================================

def load_json_schema(filepath: Path) -> Dict[str, Any]:
    """Load a JSON schema file."""
    with open(filepath, 'r') as f:
        return json.load(f)


def convert_ref(ref: str) -> str:
    """Convert JSON Schema $ref to OpenAPI $ref format."""
    # FlatBuffers generates refs like "#/definitions/quantra_enums_DayCounter"
    # OpenAPI uses "#/components/schemas/..."
    if ref.startswith("#/definitions/"):
        schema_name = ref.replace("#/definitions/", "")
        return f"#/components/schemas/{schema_name}"
    return ref


def convert_schema_to_openapi(schema: Dict[str, Any]) -> Dict[str, Any]:
    """Convert a JSON Schema to OpenAPI 3.0 schema format."""
    if not schema:
        return {}
    
    result = {}
    
    # Handle $ref
    if "$ref" in schema:
        return {"$ref": convert_ref(schema["$ref"])}
    
    # Copy basic properties
    for key in ["type", "description", "enum", "default", "minimum", "maximum", 
                "minLength", "maxLength", "pattern", "format"]:
        if key in schema:
            result[key] = schema[key]
    
    # Handle properties (objects)
    if "properties" in schema:
        result["type"] = "object"
        result["properties"] = {}
        for prop_name, prop_schema in schema["properties"].items():
            result["properties"][prop_name] = convert_schema_to_openapi(prop_schema)
        
        # Handle required fields
        if "required" in schema:
            result["required"] = schema["required"]
    
    # Handle items (arrays)
    if "items" in schema:
        result["type"] = "array"
        result["items"] = convert_schema_to_openapi(schema["items"])
    
    # Handle oneOf/anyOf/allOf
    for key in ["oneOf", "anyOf", "allOf"]:
        if key in schema:
            result[key] = [convert_schema_to_openapi(s) for s in schema[key]]
    
    # Handle additionalProperties
    if "additionalProperties" in schema:
        if isinstance(schema["additionalProperties"], dict):
            result["additionalProperties"] = convert_schema_to_openapi(schema["additionalProperties"])
        else:
            result["additionalProperties"] = schema["additionalProperties"]
    
    return result


def load_all_schemas() -> Dict[str, Any]:
    """Load all FlatBuffers-generated JSON schemas and convert to OpenAPI format."""
    schemas = {}
    
    if not JSON_SCHEMA_DIR.exists():
        print(f"Warning: JSON schema directory not found: {JSON_SCHEMA_DIR}")
        print("Run ./scripts/regen-flatbuffers.sh first")
        return schemas
    
    schema_files = list(JSON_SCHEMA_DIR.glob("*.schema.json"))
    if not schema_files:
        print(f"Warning: No .schema.json files found in {JSON_SCHEMA_DIR}")
        return schemas
    
    print(f"Loading schemas from {JSON_SCHEMA_DIR}")
    
    for schema_file in sorted(schema_files):
        try:
            schema = load_json_schema(schema_file)
            print(f"  - {schema_file.name}")
            
            # Extract all definitions from the schema
            # FlatBuffers preserves original naming like "quantra_PriceCDSRequest"
            if "definitions" in schema:
                for def_name, def_schema in schema["definitions"].items():
                    if def_name not in schemas:
                        schemas[def_name] = convert_schema_to_openapi(def_schema)
            
            # The root schema properties are at the top level
            # The root type name is in the definitions, we don't need to add it again
                
        except Exception as e:
            print(f"  Warning: Could not load {schema_file.name}: {e}")
    
    print(f"Loaded {len(schemas)} schemas")
    return schemas


# =============================================================================
# OpenAPI Generation
# =============================================================================

def build_path_item(endpoint_config: Dict[str, Any], schemas: Dict[str, Any]) -> Dict[str, Any]:
    """Build an OpenAPI path item for an endpoint."""
    request_ref = endpoint_config["request_schema"]
    response_ref = endpoint_config["response_schema"]
    
    # Verify schemas exist
    if request_ref not in schemas:
        print(f"  Warning: Request schema '{request_ref}' not found")
    if response_ref not in schemas:
        print(f"  Warning: Response schema '{response_ref}' not found")
    
    return {
        "post": {
            "summary": endpoint_config["summary"],
            "description": endpoint_config["description"],
            "tags": endpoint_config.get("tags", ["Pricing"]),
            "requestBody": {
                "required": True,
                "content": {
                    "application/json": {
                        "schema": {"$ref": f"#/components/schemas/{request_ref}"}
                    }
                }
            },
            "responses": {
                "200": {
                    "description": "Successful pricing response",
                    "content": {
                        "application/json": {
                            "schema": {"$ref": f"#/components/schemas/{response_ref}"}
                        }
                    }
                },
                "400": {
                    "description": "Invalid request",
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "error": {"type": "string", "description": "Error message"}
                                }
                            }
                        }
                    }
                },
                "500": {
                    "description": "Server error",
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "error": {"type": "string", "description": "Error message"}
                                }
                            }
                        }
                    }
                }
            }
        }
    }


def generate_openapi() -> Dict[str, Any]:
    """Generate complete OpenAPI 3.0 specification."""
    
    # Load schemas from FlatBuffers-generated files
    schemas = load_all_schemas()
    
    if not schemas:
        print("Error: No schemas loaded. Cannot generate OpenAPI spec.")
        return {}
    
    # Build paths
    paths = {}
    for endpoint, config in ENDPOINTS.items():
        paths[endpoint] = build_path_item(config, schemas)
    
    # Add health endpoint
    paths["/health"] = {
        "get": {
            "summary": "Health Check",
            "description": "Check if the API server is running.",
            "tags": ["System"],
            "responses": {
                "200": {
                    "description": "Server is healthy",
                    "content": {
                        "application/json": {
                            "schema": {
                                "type": "object",
                                "properties": {
                                    "status": {"type": "string", "example": "ok"}
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    # Build complete spec
    openapi_spec = {
        "openapi": "3.0.3",
        "info": API_INFO,
        "servers": [
            {"url": "http://localhost:8080", "description": "Local development server"}
        ],
        "tags": [
            {"name": "Bonds", "description": "Fixed and floating rate bond pricing"},
            {"name": "Interest Rate Derivatives", "description": "Swaps, FRAs, caps/floors, swaptions"},
            {"name": "Credit Derivatives", "description": "Credit default swaps"},
            {"name": "System", "description": "System endpoints"}
        ],
        "paths": paths,
        "components": {
            "schemas": schemas
        }
    }
    
    return openapi_spec


# =============================================================================
# HTML Documentation Generation
# =============================================================================

def generate_redoc_html(spec_path: str = "openapi3.yaml") -> str:
    """Generate ReDoc HTML documentation."""
    return f'''<!DOCTYPE html>
<html>
<head>
    <title>Quantra API Documentation</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
    <style>
        body {{ margin: 0; padding: 0; }}
    </style>
</head>
<body>
    <redoc spec-url='{spec_path}'></redoc>
    <script src="https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"></script>
</body>
</html>
'''


def generate_swagger_html(spec_path: str = "openapi3.yaml") -> str:
    """Generate Swagger UI HTML documentation."""
    return f'''<!DOCTYPE html>
<html>
<head>
    <title>Quantra API - Swagger UI</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css">
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"></script>
    <script>
        window.onload = function() {{
            SwaggerUIBundle({{
                url: "{spec_path}",
                dom_id: '#swagger-ui',
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIBundle.SwaggerUIStandalonePreset
                ],
                layout: "BaseLayout"
            }});
        }};
    </script>
</body>
</html>
'''


# =============================================================================
# Main
# =============================================================================

def main():
    print("=" * 60)
    print("Generating OpenAPI Documentation")
    print("=" * 60)
    print()
    
    # Ensure output directory exists
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    
    # Generate OpenAPI spec
    spec = generate_openapi()
    
    if not spec:
        print("Failed to generate OpenAPI spec")
        return 1
    
    # Write YAML
    yaml_path = OUTPUT_DIR / "openapi3.yaml"
    with open(yaml_path, 'w') as f:
        yaml.dump(spec, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
    print(f"Written: {yaml_path}")
    
    # Write JSON
    json_path = OUTPUT_DIR / "openapi3.json"
    with open(json_path, 'w') as f:
        json.dump(spec, f, indent=2)
    print(f"Written: {json_path}")
    
    # Write ReDoc HTML
    redoc_path = OUTPUT_DIR / "docs.html"
    with open(redoc_path, 'w') as f:
        f.write(generate_redoc_html())
    print(f"Written: {redoc_path}")
    
    # Write Swagger UI HTML
    swagger_path = OUTPUT_DIR / "swagger.html"
    with open(swagger_path, 'w') as f:
        f.write(generate_swagger_html())
    print(f"Written: {swagger_path}")
    
    print()
    print("=" * 60)
    print("Documentation generated successfully!")
    print("=" * 60)
    print()
    print("To view the documentation:")
    print(f"  cd {OUTPUT_DIR}")
    print("  python3 -m http.server 9000")
    print()
    print("Then open:")
    print("  - http://localhost:9000/docs.html    (ReDoc - clean reading)")
    print("  - http://localhost:9000/swagger.html (Swagger UI - interactive)")
    print()
    
    return 0


if __name__ == "__main__":
    exit(main())