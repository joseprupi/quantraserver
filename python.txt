#### quantra-python/examples/price_bonds.py
#!/usr/bin/env python3
"""
Benchmark the Quantra Python client.
"""

import asyncio
import time
import sys
sys.path.insert(0, '/workspace/quantra-python')

from quantra_client import (
    Client,
    FixedRateBond,
    Schedule,
    TermStructure,
    DepositHelper,
    BondHelper,
    DayCounter,
    Calendar,
    BusinessDayConvention,
    Frequency,
    TimeUnit,
    DateGenerationRule,
    Interpolator,
    BootstrapTrait,
)


def create_term_structure() -> TermStructure:
    """Create a sample term structure for discounting."""
    
    deposit_3m = DepositHelper(
        rate=0.0096,
        tenor_number=3,
        tenor_time_unit=TimeUnit.Months,
        fixing_days=3,
        calendar=Calendar.TARGET,
        business_day_convention=BusinessDayConvention.ModifiedFollowing,
        day_counter=DayCounter.Actual365Fixed,
    )
    
    deposit_6m = DepositHelper(
        rate=0.0145,
        tenor_number=6,
        tenor_time_unit=TimeUnit.Months,
        fixing_days=3,
        calendar=Calendar.TARGET,
        business_day_convention=BusinessDayConvention.ModifiedFollowing,
        day_counter=DayCounter.Actual365Fixed,
    )
    
    deposit_1y = DepositHelper(
        rate=0.0194,
        tenor_number=1,
        tenor_time_unit=TimeUnit.Years,
        fixing_days=3,
        calendar=Calendar.TARGET,
        business_day_convention=BusinessDayConvention.ModifiedFollowing,
        day_counter=DayCounter.Actual365Fixed,
    )
    
    bond_helpers = []
    issue_dates = ["2005/03/15", "2005/06/15", "2006/06/30", "2002/11/15", "1987/05/15"]
    maturities = ["2010/08/31", "2011/08/31", "2013/08/31", "2018/08/15", "2038/05/15"]
    coupon_rates = [0.02375, 0.04625, 0.03125, 0.04000, 0.04500]
    market_quotes = [100.390625, 106.21875, 100.59375, 101.6875, 102.140625]
    
    for i in range(5):
        schedule = Schedule(
            calendar=Calendar.UnitedStatesGovernmentBond,
            effective_date=issue_dates[i],
            termination_date=maturities[i],
            frequency=Frequency.Semiannual,
            convention=BusinessDayConvention.Unadjusted,
            termination_date_convention=BusinessDayConvention.Unadjusted,
            date_generation_rule=DateGenerationRule.Backward,
            end_of_month=False,
        )
        
        bond = BondHelper(
            rate=market_quotes[i],
            settlement_days=3,
            face_amount=100.0,
            schedule=schedule,
            coupon_rate=coupon_rates[i],
            day_counter=DayCounter.ActualActualBond,
            business_day_convention=BusinessDayConvention.Unadjusted,
            redemption=100.0,
            issue_date=issue_dates[i],
        )
        bond_helpers.append(bond)
    
    points = [deposit_3m, deposit_6m, deposit_1y] + bond_helpers
    
    return TermStructure(
        id="depos",
        day_counter=DayCounter.ActualActual365,
        interpolator=Interpolator.LogLinear,
        bootstrap_trait=BootstrapTrait.Discount,
        reference_date="2008/09/18",
        points=points,
    )


def create_fixed_rate_bond() -> FixedRateBond:
    """Create a sample fixed rate bond."""
    
    schedule = Schedule(
        calendar=Calendar.UnitedStatesGovernmentBond,
        effective_date="2007/05/15",
        termination_date="2017/05/15",
        frequency=Frequency.Semiannual,
        convention=BusinessDayConvention.Unadjusted,
        termination_date_convention=BusinessDayConvention.Unadjusted,
        date_generation_rule=DateGenerationRule.Backward,
        end_of_month=False,
    )
    
    return FixedRateBond(
        settlement_days=3,
        face_amount=100.0,
        rate=0.045,
        accrual_day_counter=DayCounter.ActualActualBond,
        payment_convention=BusinessDayConvention.ModifiedFollowing,
        redemption=100.0,
        issue_date="2007/05/15",
        schedule=schedule,
    )


async def benchmark(num_bonds: int, num_requests: int):
    """Run benchmark."""
    
    curve = create_term_structure()
    bonds = [create_fixed_rate_bond() for _ in range(num_bonds)]
    
    async with Client('localhost:50051') as client:
        start = time.perf_counter()
        
        results = await client.price_fixed_rate_bonds(
            bonds=bonds,
            curves=[curve],
            as_of_date='2008/09/18',
            settlement_date='2008/09/18',
            num_requests=num_requests,
            discount_curve='depos',
        )
        
        elapsed_ms = (time.perf_counter() - start) * 1000
        
        # Calculate total NPV
        total_npv = sum(r.get('npv', 0) or 0 for r in results)
        errors = sum(1 for r in results if 'error' in r)
        
        return {
            'bonds': num_bonds,
            'requests': num_requests,
            'elapsed_ms': elapsed_ms,
            'throughput': num_bonds / elapsed_ms * 1000,
            'total_npv': total_npv,
            'errors': errors,
        }


async def main():
    print("=" * 70)
    print("Quantra Python Client Benchmark")
    print("=" * 70)
    
    # Test configurations
    configs = [
        (100, 10),
        (1000, 10),
        (1000, 1),   # Single request for comparison
        #(100000, 10),
    ]
    
    for num_bonds, num_requests in configs:
        result = await benchmark(num_bonds, num_requests)
        
        print(f"\nBonds: {result['bonds']:5d} | "
              f"Requests: {result['requests']:2d} | "
              f"Time: {result['elapsed_ms']:7.1f}ms | "
              f"Throughput: {result['throughput']:7.0f} bonds/sec | "
              f"NPV: {result['total_npv']:.2f}")
        
        if result['errors']:
            print(f"  WARNING: {result['errors']} errors")
    
    print("\n" + "=" * 70)
    print("Compare with C++ benchmark:")
    print("  cd /workspace/build && ./tests/benchmark 100 10 0")
    print("=" * 70)


if __name__ == "__main__":
    asyncio.run(main())

#### quantra-python/quantra_client/__init__.py
"""
Quantra Python Client

A Python client for the Quantra distributed QuantLib pricing engine.

Example:
    from quantra_client import Client, FixedRateBond, Curve, DepositHelper
    
    client = Client("localhost:50051")
    
    curve = Curve(
        id="USD",
        points=[
            DepositHelper(rate=0.05, tenor_number=3, tenor_time_unit=TimeUnit.Months),
        ]
    )
    
    bond = FixedRateBond(
        face_amount=100,
        rate=0.045,
        issue_date="2020-01-15",
        ...
    )
    
    results = await client.price_bonds([bond], curves=[curve])
"""

from .enums import *
from .models import *
from .client import Client

__version__ = "0.1.0"
__all__ = [
    "Client",
    # Re-export commonly used models
    "FixedRateBond",
    "FloatingRateBond",
    "Schedule",
    "TermStructure",
    "DepositHelper",
    "SwapHelper",
    "Pricing",
    # Enums
    "DayCounter",
    "Calendar", 
    "BusinessDayConvention",
    "Frequency",
    "TimeUnit",
    "DateGenerationRule",
    "Interpolator",
    "BootstrapTrait",
]


#### quantra-python/quantra_client/client.py
"""
Quantra gRPC Client

Async client for communicating with Quantra pricing servers.
"""

import asyncio
from typing import List, Optional, Union
from dataclasses import dataclass
import grpc
from grpc import aio

from .models import (
    PriceFixedRateBondRequest,
    PriceFixedRateBondResponse,
    PriceFloatingRateBondRequest,
    PriceFloatingRateBondResponse,
    FixedRateBond,
    FloatingRateBond,
    TermStructure,
    Pricing,
    PriceFixedRateBond,
    PriceFloatingRateBond,
)
from .serializers import (
    serialize_price_fixed_rate_bond_request,
    deserialize_price_fixed_rate_bond_response,
)


@dataclass
class ClientConfig:
    """Client configuration"""
    host: str = "localhost"
    port: int = 50051
    secure: bool = False
    max_message_size: int = 100 * 1024 * 1024  # 100MB
    timeout: float = 30.0
    num_workers: Optional[int] = None  # Auto-detect from server


class Client:
    """
    Async Quantra pricing client.
    
    Example:
        async with Client("localhost:50051") as client:
            results = await client.price_bonds(bonds, curves=[curve])
    """
    
    def __init__(
        self,
        address: str = "localhost:50051",
        secure: bool = False,
        max_message_size: int = 100 * 1024 * 1024,
    ):
        """
        Initialize the client.
        
        Args:
            address: Server address in "host:port" format
            secure: Use TLS encryption
            max_message_size: Maximum gRPC message size in bytes
        """
        self.address = address
        self.secure = secure
        self.max_message_size = max_message_size
        self._channel: Optional[aio.Channel] = None
        self._stub = None
        
    async def __aenter__(self):
        await self.connect()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
        
    async def connect(self):
        """Establish connection to the server"""
        options = [
            ('grpc.max_receive_message_length', self.max_message_size),
            ('grpc.max_send_message_length', self.max_message_size),
        ]
        
        if self.secure:
            credentials = grpc.ssl_channel_credentials()
            self._channel = aio.secure_channel(self.address, credentials, options=options)
        else:
            self._channel = aio.insecure_channel(self.address, options=options)
            
        # Import the generated gRPC stub
        # Note: This assumes the FlatBuffers gRPC code is available
        # We'll need to generate this or use a generic approach
        await self._channel.channel_ready()
        
    async def close(self):
        """Close the connection"""
        if self._channel:
            await self._channel.close()
            self._channel = None
            
    # =========================================================================
    # High-level API
    # =========================================================================
    
    async def price(
        self,
        products: List[Union[FixedRateBond, FloatingRateBond]],
        curves: List[TermStructure],
        as_of_date: str,
        settlement_date: Optional[str] = None,
        num_requests: int = 1,
    ) -> List[dict]:
        """
        Price a list of products.
        
        Automatically detects product types and routes to appropriate methods.
        
        Args:
            products: List of bonds/swaps/etc to price
            curves: List of yield curves
            as_of_date: Pricing date (YYYY/MM/DD format)
            settlement_date: Settlement date (defaults to as_of_date)
            num_requests: Number of parallel requests to split into
            
        Returns:
            List of pricing results
        """
        if settlement_date is None:
            settlement_date = as_of_date
            
        # Group by product type
        fixed_bonds = [p for p in products if isinstance(p, FixedRateBond)]
        floating_bonds = [p for p in products if isinstance(p, FloatingRateBond)]
        
        results = []
        
        if fixed_bonds:
            fixed_results = await self.price_fixed_rate_bonds(
                fixed_bonds, curves, as_of_date, settlement_date, num_requests
            )
            results.extend(fixed_results)
            
        if floating_bonds:
            floating_results = await self.price_floating_rate_bonds(
                floating_bonds, curves, as_of_date, settlement_date, num_requests
            )
            results.extend(floating_results)
            
        return results
    
    async def price_fixed_rate_bonds(
        self,
        bonds: List[FixedRateBond],
        curves: List[TermStructure],
        as_of_date: str,
        settlement_date: Optional[str] = None,
        num_requests: int = 1,
        discount_curve: str = "depos",
    ) -> List[dict]:
        """
        Price fixed rate bonds.
        
        Args:
            bonds: List of FixedRateBond objects
            curves: List of TermStructure objects
            as_of_date: Pricing date
            settlement_date: Settlement date
            num_requests: Number of parallel requests
            discount_curve: ID of the discounting curve
            
        Returns:
            List of pricing results with NPV, duration, etc.
        """
        if settlement_date is None:
            settlement_date = as_of_date
            
        # Build requests
        requests = self._split_fixed_rate_bond_requests(
            bonds, curves, as_of_date, settlement_date, discount_curve, num_requests
        )
        
        # Execute in parallel
        tasks = [self._call_price_fixed_rate_bond(req) for req in requests]
        responses = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Flatten results
        results = []
        for resp in responses:
            if isinstance(resp, Exception):
                results.append({"error": str(resp)})
            else:
                results.extend(resp)
                
        return results
    
    async def price_floating_rate_bonds(
        self,
        bonds: List[FloatingRateBond],
        curves: List[TermStructure],
        as_of_date: str,
        settlement_date: Optional[str] = None,
        num_requests: int = 1,
        discount_curve: str = "depos",
        forecast_curve: str = "depos",
    ) -> List[dict]:
        """Price floating rate bonds."""
        # Similar implementation...
        raise NotImplementedError("Floating rate bonds not yet implemented")
    
    # =========================================================================
    # Request building helpers
    # =========================================================================
    
    def _split_fixed_rate_bond_requests(
        self,
        bonds: List[FixedRateBond],
        curves: List[TermStructure],
        as_of_date: str,
        settlement_date: str,
        discount_curve: str,
        num_requests: int,
    ) -> List[PriceFixedRateBondRequest]:
        """Split bonds into multiple requests for parallel processing."""
        
        if num_requests <= 0:
            num_requests = 1
            
        # Calculate bonds per request
        bonds_per_request = max(1, len(bonds) // num_requests)
        
        requests = []
        for i in range(num_requests):
            start = i * bonds_per_request
            if i == num_requests - 1:
                # Last request gets remaining bonds
                end = len(bonds)
            else:
                end = start + bonds_per_request
                
            if start >= len(bonds):
                break
                
            batch = bonds[start:end]
            
            # Build request
            pricing = Pricing(
                as_of_date=as_of_date,
                settlement_date=settlement_date,
                curves=curves,
            )
            
            price_bonds = [
                PriceFixedRateBond(
                    fixed_rate_bond=bond,
                    discounting_curve=discount_curve,
                )
                for bond in batch
            ]
            
            request = PriceFixedRateBondRequest(
                pricing=pricing,
                bonds=price_bonds,
            )
            
            requests.append(request)
            
        return requests
    
    # =========================================================================
    # Low-level gRPC calls
    # =========================================================================
    
    async def _call_price_fixed_rate_bond(
        self,
        request: PriceFixedRateBondRequest,
    ) -> List[dict]:
        """Make the actual gRPC call for fixed rate bond pricing."""
        
        # Serialize request to FlatBuffers
        request_bytes = serialize_price_fixed_rate_bond_request(request)
        
        # Make gRPC call
        # Note: This is a simplified version - actual implementation needs
        # the generated gRPC stub from FlatBuffers
        
        # For now, we'll use a raw call approach
        response_bytes = await self._raw_call(
            "/quantra.QuantraServer/PriceFixedRateBond",
            request_bytes,
        )
        
        # Deserialize response
        return deserialize_price_fixed_rate_bond_response(response_bytes)
    
    async def _raw_call(self, method: str, request_bytes: bytes) -> bytes:
        """Make a raw gRPC call with FlatBuffers payloads."""
        
        # This is a workaround since FlatBuffers gRPC for Python is tricky
        # We use the unary_unary call with raw bytes
        
        call = self._channel.unary_unary(
            method,
            request_serializer=lambda x: x,  # Already bytes
            response_deserializer=lambda x: x,  # Return raw bytes
        )
        
        response = await call(request_bytes)
        return response


# Synchronous wrapper for convenience
class SyncClient:
    """
    Synchronous wrapper around the async client.
    
    Example:
        client = SyncClient("localhost:50051")
        results = client.price_bonds(bonds, curves=[curve])
    """
    
    def __init__(self, *args, **kwargs):
        self._async_client = Client(*args, **kwargs)
        self._loop = asyncio.new_event_loop()
        
    def __enter__(self):
        self._loop.run_until_complete(self._async_client.connect())
        return self
        
    def __exit__(self, *args):
        self._loop.run_until_complete(self._async_client.close())
        self._loop.close()
        
    def price(self, *args, **kwargs):
        return self._loop.run_until_complete(
            self._async_client.price(*args, **kwargs)
        )
        
    def price_fixed_rate_bonds(self, *args, **kwargs):
        return self._loop.run_until_complete(
            self._async_client.price_fixed_rate_bonds(*args, **kwargs)
        )


#### quantra-python/quantra_client/enums.py
"""Auto-generated enum definitions from FlatBuffers schema"""

from enum import IntEnum

class DayCounter(IntEnum):
    Actual360 = 0
    Actual365Fixed = 1
    Actual365NoLeap = 2
    ActualActual = 3
    ActualActualISMA = 4
    ActualActualBond = 5
    ActualActualISDA = 6
    ActualActualHistorical = 7
    ActualActual365 = 8
    ActualActualAFB = 9
    ActualActualEuro = 10
    Business252 = 11
    One = 12
    Simple = 13
    Thirty360 = 14

class Interpolator(IntEnum):
    BackwardFlat = 0
    ForwardFlat = 1
    Linear = 2
    LogCubic = 3
    LogLinear = 4

class BootstrapTrait(IntEnum):
    Discount = 0
    FwdRate = 1
    InterpolatedDiscount = 2
    InterpolatedFwd = 3
    InterpolatedZero = 4
    ZeroRate = 5

class TimeUnit(IntEnum):
    Days = 0
    Hours = 1
    Microseconds = 2
    Milliseconds = 3
    Minutes = 4
    Months = 5
    Seconds = 6
    Weeks = 7
    Years = 8

class Calendar(IntEnum):
    Argentina = 0
    Australia = 1
    BespokeCalendar = 2
    Brazil = 3
    Canada = 4
    China = 5
    CzechRepublic = 6
    Denmark = 7
    Finland = 8
    Germany = 9
    HongKong = 10
    Hungary = 11
    Iceland = 12
    India = 13
    Indonesia = 14
    Israel = 15
    Italy = 16
    Japan = 17
    Mexico = 18
    NewZealand = 19
    Norway = 20
    NullCalendar = 21
    Poland = 22
    Romania = 23
    Russia = 24
    SaudiArabia = 25
    Singapore = 26
    Slovakia = 27
    SouthAfrica = 28
    SouthKorea = 29
    Sweden = 30
    Switzerland = 31
    TARGET = 32
    Taiwan = 33
    Turkey = 34
    Ukraine = 35
    UnitedKingdom = 36
    UnitedStates = 37
    UnitedStatesGovernmentBond = 38
    UnitedStatesNERC = 39
    UnitedStatesNYSE = 40
    UnitedStatesSettlement = 41
    WeekendsOnly = 42

class BusinessDayConvention(IntEnum):
    Following = 0
    HalfMonthModifiedFollowing = 1
    ModifiedFollowing = 2
    ModifiedPreceding = 3
    Nearest = 4
    Preceding = 5
    Unadjusted = 6

class Frequency(IntEnum):
    Annual = 0
    Bimonthly = 1
    Biweekly = 2
    Daily = 3
    EveryFourthMonth = 4
    EveryFourthWeek = 5
    Monthly = 6
    NoFrequency = 7
    Once = 8
    OtherFrequency = 9
    Quarterly = 10
    Semiannual = 11
    Weekly = 12

class DateGenerationRule(IntEnum):
    Backward = 0
    CDS = 1
    Forward = 2
    OldCDS = 3
    ThirdWednesday = 4
    Twentieth = 5
    TwentiethIMM = 6
    Zero = 7

class Ibor(IntEnum):
    Euribor10M = 0
    Euribor11M = 1
    Euribor1M = 2
    Euribor1Y = 3
    Euribor2M = 4
    Euribor2W = 5
    Euribor365_10M = 6
    Euribor365_11M = 7
    Euribor365_1M = 8
    Euribor365_1Y = 9
    Euribor365_2M = 10
    Euribor365_2W = 11
    Euribor365_3M = 12
    Euribor365_3W = 13
    Euribor365_4M = 14
    Euribor365_5M = 15
    Euribor365_6M = 16
    Euribor365_7M = 17
    Euribor365_8M = 18
    Euribor365_9M = 19
    Euribor365_SW = 20
    Euribor3M = 21
    Euribor3W = 22
    Euribor4M = 23
    Euribor5M = 24
    Euribor6M = 25
    Euribor7M = 26
    Euribor8M = 27
    Euribor9M = 28
    EuriborSW = 29

class Compounding(IntEnum):
    Compounded = 0
    Continuous = 1
    Simple = 2
    SimpleThenCompounded = 3

class SwapType(IntEnum):
    Payer = 0
    Receiver = 1

class FRAType(IntEnum):
    Long = 0
    Short = 1

class CapFloorType(IntEnum):
    Cap = 0
    Floor = 1
    Collar = 2

class ExerciseType(IntEnum):
    European = 0
    Bermudan = 1
    American = 2

class SettlementType(IntEnum):
    Physical = 0
    Cash = 1

class ProtectionSide(IntEnum):
    Buyer = 0
    Seller = 1

class VolatilityType(IntEnum):
    ShiftedLognormal = 0
    Normal = 1


#### quantra-python/quantra_client/models.py
"""Auto-generated model definitions from FlatBuffers schema"""

from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Optional, Union

from .enums import *

@dataclass
class BlackIborCouponPricer:
    """Generated from quantra_client.BlackIborCouponPricer"""
    optionlet_volatility_structure: Optional[OptionletVolatilityStructure] = None

@dataclass
class BondHelper:
    """Generated from quantra_client.BondHelper"""
    rate: Optional[float] = None
    settlement_days: Optional[int] = None
    face_amount: Optional[float] = None
    schedule: Optional[Schedule] = None
    coupon_rate: Optional[float] = None
    day_counter: Optional[DayCounter] = None
    business_day_convention: Optional[BusinessDayConvention] = None
    redemption: Optional[float] = None
    issue_date: Optional[str] = None

@dataclass
class CDS:
    """Generated from quantra_client.CDS"""
    side: Optional[ProtectionSide] = None
    notional: Optional[float] = None
    spread: Optional[float] = None
    schedule: Optional[Schedule] = None
    upfront: Optional[float] = 0.0
    day_counter: Optional[DayCounter] = None
    business_day_convention: Optional[BusinessDayConvention] = None

@dataclass
class CDSValues:
    """Generated from quantra_client.CDSValues"""
    npv: Optional[float] = None
    fair_spread: Optional[float] = None
    fair_upfront: Optional[float] = None
    default_leg_npv: Optional[float] = None
    premium_leg_npv: Optional[float] = None
    error: Optional[Error] = None

@dataclass
class CapFloor:
    """Generated from quantra_client.CapFloor"""
    cap_floor_type: Optional[CapFloorType] = None
    notional: Optional[float] = None
    strike: Optional[float] = None
    schedule: Optional[Schedule] = None
    index: Optional[Index] = None
    day_counter: Optional[DayCounter] = None
    business_day_convention: Optional[BusinessDayConvention] = None

@dataclass
class CapFloorLet:
    """Generated from quantra_client.CapFloorLet"""
    payment_date: Optional[str] = None
    accrual_start_date: Optional[str] = None
    accrual_end_date: Optional[str] = None
    fixing_date: Optional[str] = None
    strike: Optional[float] = None
    forward_rate: Optional[float] = None
    discount: Optional[float] = None
    price: Optional[float] = None

@dataclass
class CapFloorResponse:
    """Generated from quantra_client.CapFloorResponse"""
    npv: Optional[float] = None
    atm_rate: Optional[float] = None
    implied_volatility: Optional[float] = None
    cap_floor_lets: List[CapFloorLet] = field(default_factory=list)

@dataclass
class ConstantOptionletVolatility:
    """Generated from quantra_client.ConstantOptionletVolatility"""
    settlement_days: Optional[int] = None
    calendar: Optional[Calendar] = None
    business_day_convention: Optional[BusinessDayConvention] = None
    volatility: Optional[float] = None
    day_counter: Optional[DayCounter] = None

@dataclass
class CouponPricer:
    """Generated from quantra_client.CouponPricer"""
    id: Optional[str] = None
    pricer: Optional[Pricer] = None

@dataclass
class CreditCurve:
    """Generated from quantra_client.CreditCurve"""
    recovery_rate: Optional[float] = 0.4
    quotes: List[CreditSpreadQuote] = field(default_factory=list)
    flat_hazard_rate: Optional[float] = None

@dataclass
class CreditSpreadQuote:
    """Generated from quantra_client.CreditSpreadQuote"""
    tenor_number: Optional[int] = None
    tenor_time_unit: Optional[TimeUnit] = None
    spread: Optional[float] = None

@dataclass
class DepositHelper:
    """Generated from quantra_client.DepositHelper"""
    rate: Optional[float] = None
    tenor_time_unit: Optional[TimeUnit] = None
    tenor_number: Optional[int] = None
    fixing_days: Optional[int] = None
    calendar: Optional[Calendar] = None
    business_day_convention: Optional[BusinessDayConvention] = None
    day_counter: Optional[DayCounter] = None

@dataclass
class Error:
    """Generated from quantra_client.Error"""
    error_message: Optional[str] = None

@dataclass
class FRA:
    """Generated from quantra_client.FRA"""
    fra_type: Optional[FRAType] = None
    notional: Optional[float] = None
    start_date: Optional[str] = None
    maturity_date: Optional[str] = None
    strike: Optional[float] = None
    index: Optional[Index] = None
    day_counter: Optional[DayCounter] = None
    calendar: Optional[Calendar] = None
    business_day_convention: Optional[BusinessDayConvention] = None

@dataclass
class FRAHelper:
    """Generated from quantra_client.FRAHelper"""
    rate: Optional[float] = None
    months_to_start: Optional[int] = None
    months_to_end: Optional[int] = None
    fixing_days: Optional[int] = None
    calendar: Optional[Calendar] = None
    business_day_convention: Optional[BusinessDayConvention] = None
    day_counter: Optional[DayCounter] = None

@dataclass
class FRAResponse:
    """Generated from quantra_client.FRAResponse"""
    npv: Optional[float] = None
    forward_rate: Optional[float] = None
    spot_value: Optional[float] = None
    settlement_date: Optional[str] = None

@dataclass
class FixedRateBond:
    """Generated from quantra_client.FixedRateBond"""
    settlement_days: Optional[int] = None
    face_amount: Optional[float] = None
    rate: Optional[float] = None
    accrual_day_counter: Optional[DayCounter] = None
    payment_convention: Optional[BusinessDayConvention] = None
    redemption: Optional[float] = None
    issue_date: Optional[str] = None
    schedule: Optional[Schedule] = None

@dataclass
class FixedRateBondResponse:
    """Generated from quantra_client.FixedRateBondResponse"""
    npv: Optional[float] = None
    clean_price: Optional[float] = None
    dirty_price: Optional[float] = None
    accrued_amount: Optional[float] = None
    yield_: Optional[float] = None
    accrued_days: Optional[float] = None
    macaulay_duration: Optional[float] = None
    modified_duration: Optional[float] = None
    convexity: Optional[float] = None
    bps: Optional[float] = None
    flows: List[FlowsWrapper] = field(default_factory=list)

@dataclass
class Fixing:
    """Generated from quantra_client.Fixing"""
    date: Optional[str] = None
    rate: Optional[float] = None

@dataclass
class FloatingRateBond:
    """Generated from quantra_client.FloatingRateBond"""
    settlement_days: Optional[int] = None
    face_amount: Optional[float] = None
    schedule: Optional[Schedule] = None
    index: Optional[Index] = None
    accrual_day_counter: Optional[DayCounter] = None
    payment_convention: Optional[BusinessDayConvention] = None
    fixing_days: Optional[int] = None
    spread: Optional[float] = None
    in_arrears: Optional[bool] = None
    redemption: Optional[float] = None
    issue_date: Optional[str] = None

@dataclass
class FloatingRateBondResponse:
    """Generated from quantra_client.FloatingRateBondResponse"""
    npv: Optional[float] = None
    clean_price: Optional[float] = None
    dirty_price: Optional[float] = None
    accrued_amount: Optional[float] = None
    yield_: Optional[float] = None
    accrued_days: Optional[float] = None
    macaulay_duration: Optional[float] = None
    modified_duration: Optional[float] = None
    convexity: Optional[float] = None
    bps: Optional[float] = None
    flows: List[FlowsWrapper] = field(default_factory=list)

@dataclass
class FlowInterest:
    """Generated from quantra_client.FlowInterest"""
    amount: Optional[float] = None
    fixing_date: Optional[str] = None
    accrual_start_date: Optional[str] = None
    accrual_end_date: Optional[str] = None
    discount: Optional[float] = None
    rate: Optional[float] = None
    price: Optional[float] = None

@dataclass
class FlowInterestFloat:
    """Generated from quantra_client.FlowInterestFloat"""
    amount: Optional[float] = None
    fixing_date: Optional[str] = None
    accrual_start_date: Optional[str] = None
    accrual_end_date: Optional[str] = None
    discount: Optional[float] = None
    rate: Optional[float] = None
    price: Optional[float] = None

@dataclass
class FlowNotional:
    """Generated from quantra_client.FlowNotional"""
    date: Optional[str] = None
    amount: Optional[float] = None
    discount: Optional[float] = None
    price: Optional[float] = None

@dataclass
class FlowPastInterest:
    """Generated from quantra_client.FlowPastInterest"""
    amount: Optional[float] = None
    fixing_date: Optional[str] = None
    accrual_start_date: Optional[str] = None
    accrual_end_date: Optional[str] = None
    rate: Optional[float] = None

@dataclass
class FlowPastInterestFloat:
    """Generated from quantra_client.FlowPastInterestFloat"""
    amount: Optional[float] = None
    fixing_date: Optional[str] = None
    accrual_start_date: Optional[str] = None
    accrual_end_date: Optional[str] = None
    rate: Optional[float] = None

@dataclass
class FlowsWrapper:
    """Generated from quantra_client.FlowsWrapper"""
    flow: Optional[Flow] = None

@dataclass
class FutureHelper:
    """Generated from quantra_client.FutureHelper"""
    rate: Optional[float] = None
    future_start_date: Optional[str] = None
    future_months: Optional[int] = None
    calendar: Optional[Calendar] = None
    business_day_convention: Optional[BusinessDayConvention] = None
    day_counter: Optional[DayCounter] = None

@dataclass
class Index:
    """Generated from quantra_client.Index"""
    period_number: Optional[int] = None
    period_time_unit: Optional[TimeUnit] = None
    settlement_days: Optional[int] = None
    calendar: Optional[Calendar] = None
    business_day_convention: Optional[BusinessDayConvention] = None
    end_of_month: Optional[bool] = None
    day_counter: Optional[DayCounter] = None
    fixings: List[Fixing] = field(default_factory=list)

@dataclass
class PointsWrapper:
    """Generated from quantra_client.PointsWrapper"""
    point: Optional[Point] = None

@dataclass
class PriceCDS:
    """Generated from quantra_client.PriceCDS"""
    cds: Optional[CDS] = None
    discounting_curve: Optional[str] = None
    credit_curve: Optional[CreditCurve] = None

@dataclass
class PriceCDSRequest:
    """Generated from quantra_client.PriceCDSRequest"""
    pricing: Optional[Pricing] = None
    cds_list: List[PriceCDS] = field(default_factory=list)

@dataclass
class PriceCDSResponse:
    """Generated from quantra_client.PriceCDSResponse"""
    cds_list: List[CDSValues] = field(default_factory=list)

@dataclass
class PriceCapFloor:
    """Generated from quantra_client.PriceCapFloor"""
    cap_floor: Optional[CapFloor] = None
    discounting_curve: Optional[str] = None
    forwarding_curve: Optional[str] = None
    volatility: Optional[str] = None
    include_details: Optional[bool] = False

@dataclass
class PriceCapFloorRequest:
    """Generated from quantra_client.PriceCapFloorRequest"""
    pricing: Optional[Pricing] = None
    cap_floors: List[PriceCapFloor] = field(default_factory=list)

@dataclass
class PriceCapFloorResponse:
    """Generated from quantra_client.PriceCapFloorResponse"""
    cap_floors: List[CapFloorResponse] = field(default_factory=list)

@dataclass
class PriceFRA:
    """Generated from quantra_client.PriceFRA"""
    fra: Optional[FRA] = None
    discounting_curve: Optional[str] = None
    forwarding_curve: Optional[str] = None

@dataclass
class PriceFRARequest:
    """Generated from quantra_client.PriceFRARequest"""
    pricing: Optional[Pricing] = None
    fras: List[PriceFRA] = field(default_factory=list)

@dataclass
class PriceFRAResponse:
    """Generated from quantra_client.PriceFRAResponse"""
    fras: List[FRAResponse] = field(default_factory=list)

@dataclass
class PriceFixedRateBond:
    """Generated from quantra_client.PriceFixedRateBond"""
    fixed_rate_bond: Optional[FixedRateBond] = None
    discounting_curve: Optional[str] = None
    yield_: Optional[Yield] = None

@dataclass
class PriceFixedRateBondRequest:
    """Generated from quantra_client.PriceFixedRateBondRequest"""
    pricing: Optional[Pricing] = None
    bonds: List[PriceFixedRateBond] = field(default_factory=list)

@dataclass
class PriceFixedRateBondResponse:
    """Generated from quantra_client.PriceFixedRateBondResponse"""
    bonds: List[FixedRateBondResponse] = field(default_factory=list)

@dataclass
class PriceFloatingRateBond:
    """Generated from quantra_client.PriceFloatingRateBond"""
    floating_rate_bond: Optional[FloatingRateBond] = None
    discounting_curve: Optional[str] = None
    forecasting_curve: Optional[str] = None
    coupon_pricer: Optional[str] = None
    yield_: Optional[Yield] = None

@dataclass
class PriceFloatingRateBondRequest:
    """Generated from quantra_client.PriceFloatingRateBondRequest"""
    pricing: Optional[Pricing] = None
    bonds: List[PriceFloatingRateBond] = field(default_factory=list)

@dataclass
class PriceFloatingRateBondResponse:
    """Generated from quantra_client.PriceFloatingRateBondResponse"""
    bonds: List[FloatingRateBondResponse] = field(default_factory=list)

@dataclass
class PriceSwaption:
    """Generated from quantra_client.PriceSwaption"""
    swaption: Optional[Swaption] = None
    discounting_curve: Optional[str] = None
    forwarding_curve: Optional[str] = None
    volatility: Optional[str] = None

@dataclass
class PriceSwaptionRequest:
    """Generated from quantra_client.PriceSwaptionRequest"""
    pricing: Optional[Pricing] = None
    swaptions: List[PriceSwaption] = field(default_factory=list)

@dataclass
class PriceSwaptionResponse:
    """Generated from quantra_client.PriceSwaptionResponse"""
    swaptions: List[SwaptionResponse] = field(default_factory=list)

@dataclass
class PriceVanillaSwap:
    """Generated from quantra_client.PriceVanillaSwap"""
    vanilla_swap: Optional[VanillaSwap] = None
    discounting_curve: Optional[str] = None
    forwarding_curve: Optional[str] = None

@dataclass
class PriceVanillaSwapRequest:
    """Generated from quantra_client.PriceVanillaSwapRequest"""
    pricing: Optional[Pricing] = None
    swaps: List[PriceVanillaSwap] = field(default_factory=list)
    include_flows: Optional[bool] = False

@dataclass
class PriceVanillaSwapResponse:
    """Generated from quantra_client.PriceVanillaSwapResponse"""
    swaps: List[VanillaSwapResponse] = field(default_factory=list)

@dataclass
class Pricing:
    """Generated from quantra_client.Pricing"""
    as_of_date: str
    settlement_date: str
    curves: List[TermStructure]
    volatilities: List[VolatilityTermStructure] = field(default_factory=list)
    bond_pricing_details: Optional[bool] = False
    bond_pricing_flows: Optional[bool] = False
    coupon_pricers: List[CouponPricer] = field(default_factory=list)

@dataclass
class Schedule:
    """Generated from quantra_client.Schedule"""
    calendar: Optional[Calendar] = None
    effective_date: Optional[str] = None
    termination_date: Optional[str] = None
    frequency: Optional[Frequency] = None
    convention: Optional[BusinessDayConvention] = None
    termination_date_convention: Optional[BusinessDayConvention] = None
    date_generation_rule: Optional[DateGenerationRule] = None
    end_of_month: Optional[bool] = None

@dataclass
class SwapFixedLeg:
    """Generated from quantra_client.SwapFixedLeg"""
    schedule: Optional[Schedule] = None
    notional: Optional[float] = None
    rate: Optional[float] = None
    day_counter: Optional[DayCounter] = None
    payment_convention: Optional[BusinessDayConvention] = None

@dataclass
class SwapFloatingLeg:
    """Generated from quantra_client.SwapFloatingLeg"""
    schedule: Optional[Schedule] = None
    notional: Optional[float] = None
    index: Optional[Index] = None
    spread: Optional[float] = 0.0
    day_counter: Optional[DayCounter] = None
    payment_convention: Optional[BusinessDayConvention] = None
    fixing_days: Optional[int] = 2
    in_arrears: Optional[bool] = False

@dataclass
class SwapHelper:
    """Generated from quantra_client.SwapHelper"""
    rate: Optional[float] = None
    tenor_time_unit: Optional[TimeUnit] = None
    tenor_number: Optional[int] = None
    calendar: Optional[Calendar] = None
    sw_fixed_leg_frequency: Optional[Frequency] = None
    sw_fixed_leg_convention: Optional[BusinessDayConvention] = None
    sw_fixed_leg_day_counter: Optional[DayCounter] = None
    sw_floating_leg_index: Optional[Ibor] = None
    spread: Optional[float] = None
    fwd_start_days: Optional[int] = None

@dataclass
class SwapLegFlow:
    """Generated from quantra_client.SwapLegFlow"""
    payment_date: Optional[str] = None
    accrual_start_date: Optional[str] = None
    accrual_end_date: Optional[str] = None
    amount: Optional[float] = None
    discount: Optional[float] = None
    present_value: Optional[float] = None
    fixing_date: Optional[str] = None
    index_fixing: Optional[float] = None
    spread: Optional[float] = None
    rate: Optional[float] = None

@dataclass
class SwapLegResponse:
    """Generated from quantra_client.SwapLegResponse"""
    npv: Optional[float] = None
    bps: Optional[float] = None
    flows: List[SwapLegFlow] = field(default_factory=list)

@dataclass
class Swaption:
    """Generated from quantra_client.Swaption"""
    exercise_type: Optional[ExerciseType] = None
    settlement_type: Optional[SettlementType] = None
    exercise_date: Optional[str] = None
    underlying_swap: Optional[VanillaSwap] = None

@dataclass
class SwaptionResponse:
    """Generated from quantra_client.SwaptionResponse"""
    npv: Optional[float] = None
    implied_volatility: Optional[float] = None
    atm_forward: Optional[float] = None
    annuity: Optional[float] = None
    delta: Optional[float] = None
    vega: Optional[float] = None

@dataclass
class TermStructure:
    """Generated from quantra_client.TermStructure"""
    id: Optional[str] = None
    day_counter: Optional[DayCounter] = None
    interpolator: Optional[Interpolator] = None
    bootstrap_trait: Optional[BootstrapTrait] = None
    points: List[PointsWrapper] = field(default_factory=list)
    reference_date: Optional[str] = None

@dataclass
class VanillaSwap:
    """Generated from quantra_client.VanillaSwap"""
    swap_type: Optional[SwapType] = None
    fixed_leg: Optional[SwapFixedLeg] = None
    floating_leg: Optional[SwapFloatingLeg] = None

@dataclass
class VanillaSwapResponse:
    """Generated from quantra_client.VanillaSwapResponse"""
    npv: Optional[float] = None
    fair_rate: Optional[float] = None
    fair_spread: Optional[float] = None
    fixed_leg_bps: Optional[float] = None
    floating_leg_bps: Optional[float] = None
    fixed_leg_npv: Optional[float] = None
    floating_leg_npv: Optional[float] = None
    fixed_leg_flows: List[SwapLegFlow] = field(default_factory=list)
    floating_leg_flows: List[SwapLegFlow] = field(default_factory=list)

@dataclass
class VolatilityQuote:
    """Generated from quantra_client.VolatilityQuote"""
    tenor_number: Optional[int] = None
    tenor_time_unit: Optional[TimeUnit] = None
    strike: Optional[float] = None
    volatility: Optional[float] = None

@dataclass
class VolatilityTermStructure:
    """Generated from quantra_client.VolatilityTermStructure"""
    id: str
    reference_date: Optional[str] = None
    calendar: Optional[Calendar] = None
    business_day_convention: Optional[BusinessDayConvention] = None
    day_counter: Optional[DayCounter] = None
    volatility_type: Optional[VolatilityType] = None
    constant_vol: Optional[float] = None
    quotes: List[VolatilityQuote] = field(default_factory=list)

@dataclass
class Yield:
    """Generated from quantra_client.Yield"""
    day_counter: Optional[DayCounter] = None
    compounding: Optional[Compounding] = None
    frequency: Optional[Frequency] = None


#### quantra-python/quantra_client/serializers.py
"""
Serialization functions for Python models to/from FlatBuffers.

This module handles converting between Pythonic dataclasses and FlatBuffers
binary format for gRPC communication.
"""

import flatbuffers
from typing import List, Optional
import sys
import os

# Add the flatbuffers python path BEFORE any other imports
FB_PYTHON_PATH = os.environ.get(
    "QUANTRA_FB_PYTHON_PATH",
    "/workspace/flatbuffers/python"
)
if FB_PYTHON_PATH not in sys.path:
    sys.path.insert(0, FB_PYTHON_PATH)

# Import our models
from .models import (
    PriceFixedRateBondRequest,
    PriceFixedRateBondResponse,
    PriceFixedRateBond,
    FixedRateBond,
    FixedRateBondResponse,
    Pricing,
    TermStructure,
    Schedule,
    DepositHelper,
    SwapHelper,
    BondHelper,
    FRAHelper,
    FutureHelper,
)
from .enums import *

# Now import FlatBuffers generated MODULES (not classes)
FB_AVAILABLE = False
FB_IMPORT_ERROR = None

try:
    import importlib
    
    # Import modules - we need the module to access the free functions
    fb_PriceFixedRateBondRequest = importlib.import_module('quantra.PriceFixedRateBondRequest')
    fb_PriceFixedRateBondResponse = importlib.import_module('quantra.PriceFixedRateBondResponse')
    fb_PriceFixedRateBond = importlib.import_module('quantra.PriceFixedRateBond')
    fb_FixedRateBond = importlib.import_module('quantra.FixedRateBond')
    fb_FixedRateBondValues = importlib.import_module('quantra.FixedRateBondValues')
    fb_Pricing = importlib.import_module('quantra.Pricing')
    fb_TermStructure = importlib.import_module('quantra.TermStructure')
    fb_Schedule = importlib.import_module('quantra.Schedule')
    fb_DepositHelper = importlib.import_module('quantra.DepositHelper')
    fb_SwapHelper = importlib.import_module('quantra.SwapHelper')
    fb_BondHelper = importlib.import_module('quantra.BondHelper')
    fb_FRAHelper = importlib.import_module('quantra.FRAHelper')
    fb_FutureHelper = importlib.import_module('quantra.FutureHelper')
    fb_PointsWrapper = importlib.import_module('quantra.PointsWrapper')
    fb_Point = importlib.import_module('quantra.Point')
    
    FB_AVAILABLE = True
except ImportError as e:
    FB_IMPORT_ERROR = str(e)


def serialize_price_fixed_rate_bond_request(request: PriceFixedRateBondRequest) -> bytes:
    """
    Serialize a PriceFixedRateBondRequest to FlatBuffers bytes.
    """
    if not FB_AVAILABLE:
        raise ImportError(f"FlatBuffers Python code not available: {FB_IMPORT_ERROR}")
    
    builder = flatbuffers.Builder(4096)
    
    # Serialize pricing (curves, dates, etc.)
    pricing_offset = _serialize_pricing(builder, request.pricing)
    
    # Serialize bonds
    bond_offsets = []
    for bond in request.bonds:
        bond_offset = _serialize_price_fixed_rate_bond(builder, bond)
        bond_offsets.append(bond_offset)
    
    # Create bonds vector
    fb_PriceFixedRateBondRequest.StartBondsVector(builder, len(bond_offsets))
    for offset in reversed(bond_offsets):
        builder.PrependUOffsetTRelative(offset)
    bonds_vector = builder.EndVector()
    
    # Build the request
    fb_PriceFixedRateBondRequest.Start(builder)
    fb_PriceFixedRateBondRequest.AddPricing(builder, pricing_offset)
    fb_PriceFixedRateBondRequest.AddBonds(builder, bonds_vector)
    request_offset = fb_PriceFixedRateBondRequest.End(builder)
    
    builder.Finish(request_offset)
    return bytes(builder.Output())


def _serialize_pricing(builder: flatbuffers.Builder, pricing: Pricing) -> int:
    """Serialize Pricing object."""
    
    # Serialize curves
    curve_offsets = []
    for curve in pricing.curves:
        curve_offset = _serialize_term_structure(builder, curve)
        curve_offsets.append(curve_offset)
    
    fb_Pricing.StartCurvesVector(builder, len(curve_offsets))
    for offset in reversed(curve_offsets):
        builder.PrependUOffsetTRelative(offset)
    curves_vector = builder.EndVector()
    
    # Create strings
    as_of_date = builder.CreateString(pricing.as_of_date)
    settlement_date = builder.CreateString(pricing.settlement_date)
    
    # Build pricing
    fb_Pricing.Start(builder)
    fb_Pricing.AddAsOfDate(builder, as_of_date)
    fb_Pricing.AddSettlementDate(builder, settlement_date)
    fb_Pricing.AddCurves(builder, curves_vector)
    fb_Pricing.AddBondPricingDetails(builder, pricing.bond_pricing_details or False)
    fb_Pricing.AddBondPricingFlows(builder, pricing.bond_pricing_flows or False)
    return fb_Pricing.End(builder)


def _serialize_term_structure(builder: flatbuffers.Builder, ts: TermStructure) -> int:
    """Serialize TermStructure object."""
    
    # Serialize points (curve instruments)
    point_offsets = []
    for point in ts.points:
        point_offset = _serialize_point(builder, point)
        point_offsets.append(point_offset)
    
    fb_TermStructure.StartPointsVector(builder, len(point_offsets))
    for offset in reversed(point_offsets):
        builder.PrependUOffsetTRelative(offset)
    points_vector = builder.EndVector()
    
    # Create strings
    id_str = builder.CreateString(ts.id or "")
    ref_date = builder.CreateString(ts.reference_date or "")
    
    # Build term structure
    fb_TermStructure.Start(builder)
    fb_TermStructure.AddId(builder, id_str)
    fb_TermStructure.AddReferenceDate(builder, ref_date)
    fb_TermStructure.AddDayCounter(builder, ts.day_counter.value if ts.day_counter else 0)
    fb_TermStructure.AddInterpolator(builder, ts.interpolator.value if ts.interpolator else 0)
    fb_TermStructure.AddBootstrapTrait(builder, ts.bootstrap_trait.value if ts.bootstrap_trait else 0)
    fb_TermStructure.AddPoints(builder, points_vector)
    return fb_TermStructure.End(builder)


def _serialize_point(builder: flatbuffers.Builder, point) -> int:
    """Serialize a curve point (deposit, swap, etc.)."""
    
    # Determine point type and serialize accordingly
    if isinstance(point, DepositHelper):
        return _serialize_deposit_helper_wrapper(builder, point)
    elif isinstance(point, SwapHelper):
        return _serialize_swap_helper_wrapper(builder, point)
    elif isinstance(point, BondHelper):
        return _serialize_bond_helper_wrapper(builder, point)
    elif isinstance(point, FRAHelper):
        return _serialize_fra_helper_wrapper(builder, point)
    elif isinstance(point, FutureHelper):
        return _serialize_future_helper_wrapper(builder, point)
    else:
        raise ValueError(f"Unknown point type: {type(point)}")


def _serialize_deposit_helper_wrapper(builder: flatbuffers.Builder, deposit: DepositHelper) -> int:
    """Serialize a deposit helper wrapped in PointsWrapper."""
    
    # Build deposit helper using module functions
    fb_DepositHelper.Start(builder)
    fb_DepositHelper.AddRate(builder, deposit.rate or 0.0)
    fb_DepositHelper.AddTenorNumber(builder, deposit.tenor_number or 0)
    fb_DepositHelper.AddTenorTimeUnit(builder, deposit.tenor_time_unit.value if deposit.tenor_time_unit else 0)
    fb_DepositHelper.AddFixingDays(builder, deposit.fixing_days or 0)
    fb_DepositHelper.AddCalendar(builder, deposit.calendar.value if deposit.calendar else 0)
    fb_DepositHelper.AddBusinessDayConvention(builder, deposit.business_day_convention.value if deposit.business_day_convention else 0)
    fb_DepositHelper.AddDayCounter(builder, deposit.day_counter.value if deposit.day_counter else 0)
    deposit_offset = fb_DepositHelper.End(builder)
    
    # Wrap in PointsWrapper
    fb_PointsWrapper.Start(builder)
    fb_PointsWrapper.AddPointType(builder, fb_Point.Point.DepositHelper)
    fb_PointsWrapper.AddPoint(builder, deposit_offset)
    return fb_PointsWrapper.End(builder)


def _serialize_swap_helper_wrapper(builder: flatbuffers.Builder, swap: SwapHelper) -> int:
    """Serialize a swap helper wrapped in PointsWrapper."""
    
    fb_SwapHelper.Start(builder)
    fb_SwapHelper.AddRate(builder, swap.rate or 0.0)
    fb_SwapHelper.AddTenorNumber(builder, swap.tenor_number or 0)
    fb_SwapHelper.AddTenorTimeUnit(builder, swap.tenor_time_unit.value if swap.tenor_time_unit else 0)
    fb_SwapHelper.AddCalendar(builder, swap.calendar.value if swap.calendar else 0)
    fb_SwapHelper.AddSwFixedLegFrequency(builder, swap.sw_fixed_leg_frequency.value if swap.sw_fixed_leg_frequency else 0)
    fb_SwapHelper.AddSwFixedLegConvention(builder, swap.sw_fixed_leg_convention.value if swap.sw_fixed_leg_convention else 0)
    fb_SwapHelper.AddSwFixedLegDayCounter(builder, swap.sw_fixed_leg_day_counter.value if swap.sw_fixed_leg_day_counter else 0)
    fb_SwapHelper.AddSwFloatingLegIndex(builder, swap.sw_floating_leg_index.value if swap.sw_floating_leg_index else 0)
    fb_SwapHelper.AddSpread(builder, swap.spread or 0.0)
    fb_SwapHelper.AddFwdStartDays(builder, swap.fwd_start_days or 0)
    swap_offset = fb_SwapHelper.End(builder)
    
    fb_PointsWrapper.Start(builder)
    fb_PointsWrapper.AddPointType(builder, fb_Point.Point.SwapHelper)
    fb_PointsWrapper.AddPoint(builder, swap_offset)
    return fb_PointsWrapper.End(builder)


def _serialize_bond_helper_wrapper(builder: flatbuffers.Builder, bond: BondHelper) -> int:
    """Serialize a bond helper wrapped in PointsWrapper."""
    
    # Serialize schedule if present
    schedule_offset = None
    if bond.schedule:
        schedule_offset = _serialize_schedule(builder, bond.schedule)
    
    issue_date = builder.CreateString(bond.issue_date or "")
    
    fb_BondHelper.Start(builder)
    fb_BondHelper.AddRate(builder, bond.rate or 0.0)
    fb_BondHelper.AddSettlementDays(builder, bond.settlement_days or 0)
    fb_BondHelper.AddFaceAmount(builder, bond.face_amount or 0.0)
    if schedule_offset:
        fb_BondHelper.AddSchedule(builder, schedule_offset)
    fb_BondHelper.AddCouponRate(builder, bond.coupon_rate or 0.0)
    fb_BondHelper.AddDayCounter(builder, bond.day_counter.value if bond.day_counter else 0)
    fb_BondHelper.AddBusinessDayConvention(builder, bond.business_day_convention.value if bond.business_day_convention else 0)
    fb_BondHelper.AddRedemption(builder, bond.redemption or 100.0)
    fb_BondHelper.AddIssueDate(builder, issue_date)
    bond_offset = fb_BondHelper.End(builder)
    
    fb_PointsWrapper.Start(builder)
    fb_PointsWrapper.AddPointType(builder, fb_Point.Point.BondHelper)
    fb_PointsWrapper.AddPoint(builder, bond_offset)
    return fb_PointsWrapper.End(builder)


def _serialize_fra_helper_wrapper(builder: flatbuffers.Builder, fra: FRAHelper) -> int:
    """Serialize a FRA helper wrapped in PointsWrapper."""
    
    fb_FRAHelper.Start(builder)
    fb_FRAHelper.AddRate(builder, fra.rate or 0.0)
    fb_FRAHelper.AddMonthsToStart(builder, fra.months_to_start or 0)
    fb_FRAHelper.AddMonthsToEnd(builder, fra.months_to_end or 0)
    fb_FRAHelper.AddFixingDays(builder, fra.fixing_days or 0)
    fb_FRAHelper.AddCalendar(builder, fra.calendar.value if fra.calendar else 0)
    fb_FRAHelper.AddBusinessDayConvention(builder, fra.business_day_convention.value if fra.business_day_convention else 0)
    fb_FRAHelper.AddDayCounter(builder, fra.day_counter.value if fra.day_counter else 0)
    fra_offset = fb_FRAHelper.End(builder)
    
    fb_PointsWrapper.Start(builder)
    fb_PointsWrapper.AddPointType(builder, fb_Point.Point.FRAHelper)
    fb_PointsWrapper.AddPoint(builder, fra_offset)
    return fb_PointsWrapper.End(builder)


def _serialize_future_helper_wrapper(builder: flatbuffers.Builder, future: FutureHelper) -> int:
    """Serialize a future helper wrapped in PointsWrapper."""
    
    future_start_date = builder.CreateString(future.future_start_date or "")
    
    fb_FutureHelper.Start(builder)
    fb_FutureHelper.AddRate(builder, future.rate or 0.0)
    fb_FutureHelper.AddFutureStartDate(builder, future_start_date)
    fb_FutureHelper.AddFutureMonths(builder, future.future_months or 0)
    fb_FutureHelper.AddCalendar(builder, future.calendar.value if future.calendar else 0)
    fb_FutureHelper.AddBusinessDayConvention(builder, future.business_day_convention.value if future.business_day_convention else 0)
    fb_FutureHelper.AddDayCounter(builder, future.day_counter.value if future.day_counter else 0)
    future_offset = fb_FutureHelper.End(builder)
    
    fb_PointsWrapper.Start(builder)
    fb_PointsWrapper.AddPointType(builder, fb_Point.Point.FutureHelper)
    fb_PointsWrapper.AddPoint(builder, future_offset)
    return fb_PointsWrapper.End(builder)


def _serialize_schedule(builder: flatbuffers.Builder, schedule: Schedule) -> int:
    """Serialize a Schedule object."""
    
    effective_date = builder.CreateString(schedule.effective_date or "")
    termination_date = builder.CreateString(schedule.termination_date or "")
    
    fb_Schedule.Start(builder)
    fb_Schedule.AddCalendar(builder, schedule.calendar.value if schedule.calendar else 0)
    fb_Schedule.AddEffectiveDate(builder, effective_date)
    fb_Schedule.AddTerminationDate(builder, termination_date)
    fb_Schedule.AddFrequency(builder, schedule.frequency.value if schedule.frequency else 0)
    fb_Schedule.AddConvention(builder, schedule.convention.value if schedule.convention else 0)
    fb_Schedule.AddTerminationDateConvention(builder, schedule.termination_date_convention.value if schedule.termination_date_convention else 0)
    fb_Schedule.AddDateGenerationRule(builder, schedule.date_generation_rule.value if schedule.date_generation_rule else 0)
    fb_Schedule.AddEndOfMonth(builder, schedule.end_of_month or False)
    return fb_Schedule.End(builder)


def _serialize_price_fixed_rate_bond(builder: flatbuffers.Builder, price_bond: PriceFixedRateBond) -> int:
    """Serialize a PriceFixedRateBond object."""
    
    # Serialize the bond
    bond_offset = None
    if price_bond.fixed_rate_bond:
        bond_offset = _serialize_fixed_rate_bond(builder, price_bond.fixed_rate_bond)
    
    discounting_curve = builder.CreateString(price_bond.discounting_curve or "")
    
    fb_PriceFixedRateBond.Start(builder)
    if bond_offset:
        fb_PriceFixedRateBond.AddFixedRateBond(builder, bond_offset)
    fb_PriceFixedRateBond.AddDiscountingCurve(builder, discounting_curve)
    return fb_PriceFixedRateBond.End(builder)


def _serialize_fixed_rate_bond(builder: flatbuffers.Builder, bond: FixedRateBond) -> int:
    """Serialize a FixedRateBond object."""
    
    # Serialize schedule first (must be created before Start)
    schedule_offset = None
    if bond.schedule:
        schedule_offset = _serialize_schedule(builder, bond.schedule)
    
    issue_date = builder.CreateString(bond.issue_date or "")
    
    fb_FixedRateBond.Start(builder)
    fb_FixedRateBond.AddSettlementDays(builder, bond.settlement_days or 0)
    fb_FixedRateBond.AddFaceAmount(builder, bond.face_amount or 0.0)
    fb_FixedRateBond.AddRate(builder, bond.rate or 0.0)
    fb_FixedRateBond.AddAccrualDayCounter(builder, bond.accrual_day_counter.value if bond.accrual_day_counter else 0)
    fb_FixedRateBond.AddPaymentConvention(builder, bond.payment_convention.value if bond.payment_convention else 0)
    fb_FixedRateBond.AddRedemption(builder, bond.redemption or 100.0)
    fb_FixedRateBond.AddIssueDate(builder, issue_date)
    if schedule_offset:
        fb_FixedRateBond.AddSchedule(builder, schedule_offset)
    return fb_FixedRateBond.End(builder)


# ============================================================================
# Deserialization
# ============================================================================

def deserialize_price_fixed_rate_bond_response(data: bytes) -> List[dict]:
    """
    Deserialize a PriceFixedRateBondResponse from FlatBuffers bytes.
    """
    if not FB_AVAILABLE:
        raise ImportError(f"FlatBuffers Python code not available: {FB_IMPORT_ERROR}")
    
    response = fb_PriceFixedRateBondResponse.PriceFixedRateBondResponse.GetRootAs(data, 0)
    
    results = []
    for i in range(response.BondsLength()):
        bond_result = response.Bonds(i)
        results.append({
            "npv": bond_result.Npv(),
            "clean_price": getattr(bond_result, 'CleanPrice', lambda: None)(),
            "dirty_price": getattr(bond_result, 'DirtyPrice', lambda: None)(),
            "accrued_amount": getattr(bond_result, 'AccruedAmount', lambda: None)(),
            "yield": getattr(bond_result, 'Yield', lambda: None)(),
            "duration": getattr(bond_result, 'MacaulayDuration', lambda: None)(),
            "modified_duration": getattr(bond_result, 'ModifiedDuration', lambda: None)(),
            "convexity": getattr(bond_result, 'Convexity', lambda: None)(),
            "bps": getattr(bond_result, 'Bps', lambda: None)(),
        })
    
    return results

#### quantra-python/setup.py
from setuptools import setup, find_packages

setup(
    name="quantra-client",
    version="0.1.0",
    description="Python client for Quantra distributed QuantLib pricing engine",
    author="Josep Rupi",
    packages=find_packages(),
    python_requires=">=3.8",
    install_requires=[
        "grpcio>=1.50.0",
        "grpcio-tools>=1.50.0",
        "flatbuffers>=23.0.0",
    ],
    extras_require={
        "dev": [
            "pytest>=7.0.0",
            "pytest-asyncio>=0.20.0",
        ],
    },
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Financial and Insurance Industry",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
    ],
)


#### quantra-python/test_client.py
#!/usr/bin/env python3
"""
Simple test to verify the Python client models and serialization work.
"""

import sys
# FlatBuffers generated code takes priority
sys.path.insert(0, '/home/claude/quantraserver-refractor/flatbuffers/python')
sys.path.insert(0, '/home/claude/quantra-python')

print("Testing Quantra Python Client")
print("=" * 50)

# Test 1: Import FlatBuffers enums
print("\n[1] Testing FlatBuffers enum imports...")
try:
    from quantra.enums.DayCounter import DayCounter
    from quantra.enums.Calendar import Calendar
    from quantra.enums.BusinessDayConvention import BusinessDayConvention
    from quantra.enums.Frequency import Frequency
    from quantra.enums.TimeUnit import TimeUnit
    from quantra.enums.DateGenerationRule import DateGenerationRule
    from quantra.enums.Interpolator import Interpolator
    from quantra.enums.BootstrapTrait import BootstrapTrait
    
    print(f"    DayCounter.Actual360 = {DayCounter.Actual360}")
    print(f"    Calendar.TARGET = {Calendar.TARGET}")
    print(f"    Frequency.Semiannual = {Frequency.Semiannual}")
    print("     Enums OK")
except Exception as e:
    print(f"     Failed: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)

# Test 2: Import FlatBuffers tables
print("\n[2] Testing FlatBuffers table imports...")
try:
    from quantra.FixedRateBond import FixedRateBond as FBFixedRateBond
    from quantra.Schedule import Schedule as FBSchedule
    from quantra.TermStructure import TermStructure as FBTermStructure
    from quantra.Pricing import Pricing as FBPricing
    from quantra.DepositHelper import DepositHelper as FBDepositHelper
    from quantra.SwapHelper import SwapHelper as FBSwapHelper
    from quantra.PointsWrapper import PointsWrapper as FBPointsWrapper
    from quantra.PriceFixedRateBond import PriceFixedRateBond as FBPriceFixedRateBond
    from quantra.PriceFixedRateBondRequest import PriceFixedRateBondRequest as FBRequest
    from quantra.Point import Point as FBPoint
    print("     FlatBuffers tables imported OK")
except Exception as e:
    print(f"     Failed: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)

# Test 3: Build a simple serialized message
print("\n[3] Testing FlatBuffers serialization...")
try:
    import flatbuffers
    
    builder = flatbuffers.Builder(4096)
    
    # Create strings first (FlatBuffers requirement)
    as_of_date = builder.CreateString("2008/09/18")
    settlement_date = builder.CreateString("2008/09/18")
    curve_id = builder.CreateString("depos")
    ref_date = builder.CreateString("2008/09/18")
    issue_date = builder.CreateString("2007/05/15")
    effective_date = builder.CreateString("2007/05/15")
    termination_date = builder.CreateString("2017/05/15")
    discount_curve = builder.CreateString("depos")
    
    # Build schedule
    FBSchedule.Start(builder)
    FBSchedule.AddCalendar(builder, Calendar.UnitedStatesGovernmentBond)
    FBSchedule.AddEffectiveDate(builder, effective_date)
    FBSchedule.AddTerminationDate(builder, termination_date)
    FBSchedule.AddFrequency(builder, Frequency.Semiannual)
    FBSchedule.AddConvention(builder, BusinessDayConvention.Unadjusted)
    FBSchedule.AddTerminationDateConvention(builder, BusinessDayConvention.Unadjusted)
    FBSchedule.AddDateGenerationRule(builder, DateGenerationRule.Backward)
    FBSchedule.AddEndOfMonth(builder, False)
    schedule_off = FBSchedule.End(builder)
    print("    Built Schedule")
    
    # Build fixed rate bond
    FBFixedRateBond.Start(builder)
    FBFixedRateBond.AddSettlementDays(builder, 3)
    FBFixedRateBond.AddFaceAmount(builder, 100.0)
    FBFixedRateBond.AddRate(builder, 0.045)
    FBFixedRateBond.AddAccrualDayCounter(builder, DayCounter.ActualActualBond)
    FBFixedRateBond.AddPaymentConvention(builder, BusinessDayConvention.ModifiedFollowing)
    FBFixedRateBond.AddRedemption(builder, 100.0)
    FBFixedRateBond.AddIssueDate(builder, issue_date)
    FBFixedRateBond.AddSchedule(builder, schedule_off)
    bond_off = FBFixedRateBond.End(builder)
    print("    Built FixedRateBond")
    
    # Build deposit helper
    FBDepositHelper.Start(builder)
    FBDepositHelper.AddRate(builder, 0.05)
    FBDepositHelper.AddTenorNumber(builder, 3)
    FBDepositHelper.AddTenorTimeUnit(builder, TimeUnit.Months)
    FBDepositHelper.AddFixingDays(builder, 3)
    FBDepositHelper.AddCalendar(builder, Calendar.TARGET)
    FBDepositHelper.AddBusinessDayConvention(builder, BusinessDayConvention.ModifiedFollowing)
    FBDepositHelper.AddDayCounter(builder, DayCounter.Actual365Fixed)
    deposit_off = FBDepositHelper.End(builder)
    print("    Built DepositHelper")
    
    # Wrap in PointsWrapper
    FBPointsWrapper.Start(builder)
    FBPointsWrapper.AddPointType(builder, FBPoint.DepositHelper)
    FBPointsWrapper.AddPoint(builder, deposit_off)
    point_wrapper_off = FBPointsWrapper.End(builder)
    print("    Built PointsWrapper")
    
    # Build points vector
    FBTermStructure.StartPointsVector(builder, 1)
    builder.PrependUOffsetTRelative(point_wrapper_off)
    points_vec = builder.EndVector()
    
    # Build term structure
    FBTermStructure.Start(builder)
    FBTermStructure.AddId(builder, curve_id)
    FBTermStructure.AddDayCounter(builder, DayCounter.ActualActual365)
    FBTermStructure.AddInterpolator(builder, Interpolator.LogLinear)
    FBTermStructure.AddBootstrapTrait(builder, BootstrapTrait.Discount)
    FBTermStructure.AddReferenceDate(builder, ref_date)
    FBTermStructure.AddPoints(builder, points_vec)
    term_structure_off = FBTermStructure.End(builder)
    print("    Built TermStructure")
    
    # Build curves vector
    FBPricing.StartCurvesVector(builder, 1)
    builder.PrependUOffsetTRelative(term_structure_off)
    curves_vec = builder.EndVector()
    
    # Build pricing
    FBPricing.Start(builder)
    FBPricing.AddAsOfDate(builder, as_of_date)
    FBPricing.AddSettlementDate(builder, settlement_date)
    FBPricing.AddCurves(builder, curves_vec)
    FBPricing.AddBondPricingDetails(builder, False)
    FBPricing.AddBondPricingFlows(builder, False)
    pricing_off = FBPricing.End(builder)
    print("    Built Pricing")
    
    # Build PriceFixedRateBond
    FBPriceFixedRateBond.Start(builder)
    FBPriceFixedRateBond.AddFixedRateBond(builder, bond_off)
    FBPriceFixedRateBond.AddDiscountingCurve(builder, discount_curve)
    price_bond_off = FBPriceFixedRateBond.End(builder)
    print("    Built PriceFixedRateBond")
    
    # Build bonds vector
    FBRequest.StartBondsVector(builder, 1)
    builder.PrependUOffsetTRelative(price_bond_off)
    bonds_vec = builder.EndVector()
    
    # Build request
    FBRequest.Start(builder)
    FBRequest.AddPricing(builder, pricing_off)
    FBRequest.AddBonds(builder, bonds_vec)
    request_off = FBRequest.End(builder)
    
    builder.Finish(request_off)
    buf = bytes(builder.Output())
    
    print(f"     Serialization OK: {len(buf)} bytes")
except Exception as e:
    print(f"     Failed: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)

print("\n" + "=" * 50)
print("All serialization tests passed! ")
print(f"\nSerialized request size: {len(buf)} bytes")
print("\nNext: Test against live server")
print("  Terminal 1: quantra start --workers 10 --foreground")
print("  Terminal 2: python test_client_live.py")


#### quantra-python/test_serialization.py
#!/usr/bin/env python3
"""
Test serialization only - no gRPC needed.
"""

import sys
sys.path.insert(0, '/home/claude/quantraserver-refractor/flatbuffers/python')

print("Testing Quantra Serialization")
print("=" * 50)

# Test 1: Import FlatBuffers enums
print("\n[1] Testing FlatBuffers enum imports...")
try:
    from quantra.enums.DayCounter import DayCounter
    from quantra.enums.Calendar import Calendar
    from quantra.enums.BusinessDayConvention import BusinessDayConvention
    from quantra.enums.Frequency import Frequency
    from quantra.enums.TimeUnit import TimeUnit
    from quantra.enums.DateGenerationRule import DateGenerationRule
    from quantra.enums.Interpolator import Interpolator
    from quantra.enums.BootstrapTrait import BootstrapTrait
    
    print(f"    DayCounter.Actual360 = {DayCounter.Actual360}")
    print(f"    Calendar.TARGET = {Calendar.TARGET}")
    print(f"    Frequency.Semiannual = {Frequency.Semiannual}")
    print("     Enums OK")
except Exception as e:
    print(f"     Failed: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)

# Test 2: Import FlatBuffers tables and builder functions
print("\n[2] Testing FlatBuffers table imports...")
try:
    # Import module-level builder functions
    from quantra import FixedRateBond as FBFixedRateBondModule
    from quantra import Schedule as FBScheduleModule
    from quantra import TermStructure as FBTermStructureModule
    from quantra import Pricing as FBPricingModule
    from quantra import DepositHelper as FBDepositHelperModule
    from quantra import PointsWrapper as FBPointsWrapperModule
    from quantra import PriceFixedRateBond as FBPriceFixedRateBondModule
    from quantra import PriceFixedRateBondRequest as FBRequestModule
    from quantra.Point import Point as FBPoint
    print("     FlatBuffers tables imported OK")
except Exception as e:
    print(f"     Failed: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)

# Test 3: Build a simple serialized message
print("\n[3] Testing FlatBuffers serialization...")
try:
    import flatbuffers
    
    builder = flatbuffers.Builder(4096)
    
    # Create strings first (FlatBuffers requirement)
    as_of_date = builder.CreateString("2008/09/18")
    settlement_date = builder.CreateString("2008/09/18")
    curve_id = builder.CreateString("depos")
    ref_date = builder.CreateString("2008/09/18")
    issue_date = builder.CreateString("2007/05/15")
    effective_date = builder.CreateString("2007/05/15")
    termination_date = builder.CreateString("2017/05/15")
    discount_curve = builder.CreateString("depos")
    
    # Build schedule using module functions
    FBScheduleModule.Start(builder)
    FBScheduleModule.AddCalendar(builder, Calendar.UnitedStatesGovernmentBond)
    FBScheduleModule.AddEffectiveDate(builder, effective_date)
    FBScheduleModule.AddTerminationDate(builder, termination_date)
    FBScheduleModule.AddFrequency(builder, Frequency.Semiannual)
    FBScheduleModule.AddConvention(builder, BusinessDayConvention.Unadjusted)
    FBScheduleModule.AddTerminationDateConvention(builder, BusinessDayConvention.Unadjusted)
    FBScheduleModule.AddDateGenerationRule(builder, DateGenerationRule.Backward)
    FBScheduleModule.AddEndOfMonth(builder, False)
    schedule_off = FBScheduleModule.End(builder)
    print("    Built Schedule")
    
    # Build fixed rate bond
    FBFixedRateBondModule.Start(builder)
    FBFixedRateBondModule.AddSettlementDays(builder, 3)
    FBFixedRateBondModule.AddFaceAmount(builder, 100.0)
    FBFixedRateBondModule.AddRate(builder, 0.045)
    FBFixedRateBondModule.AddAccrualDayCounter(builder, DayCounter.ActualActualBond)
    FBFixedRateBondModule.AddPaymentConvention(builder, BusinessDayConvention.ModifiedFollowing)
    FBFixedRateBondModule.AddRedemption(builder, 100.0)
    FBFixedRateBondModule.AddIssueDate(builder, issue_date)
    FBFixedRateBondModule.AddSchedule(builder, schedule_off)
    bond_off = FBFixedRateBondModule.End(builder)
    print("    Built FixedRateBond")
    
    # Build deposit helper
    FBDepositHelperModule.Start(builder)
    FBDepositHelperModule.AddRate(builder, 0.05)
    FBDepositHelperModule.AddTenorNumber(builder, 3)
    FBDepositHelperModule.AddTenorTimeUnit(builder, TimeUnit.Months)
    FBDepositHelperModule.AddFixingDays(builder, 3)
    FBDepositHelperModule.AddCalendar(builder, Calendar.TARGET)
    FBDepositHelperModule.AddBusinessDayConvention(builder, BusinessDayConvention.ModifiedFollowing)
    FBDepositHelperModule.AddDayCounter(builder, DayCounter.Actual365Fixed)
    deposit_off = FBDepositHelperModule.End(builder)
    print("    Built DepositHelper")
    
    # Wrap in PointsWrapper
    FBPointsWrapperModule.Start(builder)
    FBPointsWrapperModule.AddPointType(builder, FBPoint.DepositHelper)
    FBPointsWrapperModule.AddPoint(builder, deposit_off)
    point_wrapper_off = FBPointsWrapperModule.End(builder)
    print("    Built PointsWrapper")
    
    # Build points vector
    FBTermStructureModule.StartPointsVector(builder, 1)
    builder.PrependUOffsetTRelative(point_wrapper_off)
    points_vec = builder.EndVector()
    
    # Build term structure
    FBTermStructureModule.Start(builder)
    FBTermStructureModule.AddId(builder, curve_id)
    FBTermStructureModule.AddDayCounter(builder, DayCounter.ActualActual365)
    FBTermStructureModule.AddInterpolator(builder, Interpolator.LogLinear)
    FBTermStructureModule.AddBootstrapTrait(builder, BootstrapTrait.Discount)
    FBTermStructureModule.AddReferenceDate(builder, ref_date)
    FBTermStructureModule.AddPoints(builder, points_vec)
    term_structure_off = FBTermStructureModule.End(builder)
    print("    Built TermStructure")
    
    # Build curves vector
    FBPricingModule.StartCurvesVector(builder, 1)
    builder.PrependUOffsetTRelative(term_structure_off)
    curves_vec = builder.EndVector()
    
    # Build pricing
    FBPricingModule.Start(builder)
    FBPricingModule.AddAsOfDate(builder, as_of_date)
    FBPricingModule.AddSettlementDate(builder, settlement_date)
    FBPricingModule.AddCurves(builder, curves_vec)
    FBPricingModule.AddBondPricingDetails(builder, False)
    FBPricingModule.AddBondPricingFlows(builder, False)
    pricing_off = FBPricingModule.End(builder)
    print("    Built Pricing")
    
    # Build PriceFixedRateBond
    FBPriceFixedRateBondModule.Start(builder)
    FBPriceFixedRateBondModule.AddFixedRateBond(builder, bond_off)
    FBPriceFixedRateBondModule.AddDiscountingCurve(builder, discount_curve)
    price_bond_off = FBPriceFixedRateBondModule.End(builder)
    print("    Built PriceFixedRateBond")
    
    # Build bonds vector
    FBRequestModule.StartBondsVector(builder, 1)
    builder.PrependUOffsetTRelative(price_bond_off)
    bonds_vec = builder.EndVector()
    
    # Build request
    FBRequestModule.Start(builder)
    FBRequestModule.AddPricing(builder, pricing_off)
    FBRequestModule.AddBonds(builder, bonds_vec)
    request_off = FBRequestModule.End(builder)
    
    builder.Finish(request_off)
    buf = bytes(builder.Output())
    
    print(f"     Serialization OK: {len(buf)} bytes")
except Exception as e:
    print(f"     Failed: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)

print("\n" + "=" * 50)
print("All serialization tests passed! ")
print(f"\nSerialized request size: {len(buf)} bytes")

# Save buffer to file for testing with server
with open('/tmp/test_request.bin', 'wb') as f:
    f.write(buf)
print(f"Saved to /tmp/test_request.bin")


#### quantra-python/tools/fbs_codegen.py
#!/usr/bin/env python3
"""
FlatBuffers Schema to Python Dataclass Generator

Reads .fbs files and generates Pythonic wrapper classes that serialize
to/from FlatBuffers.
"""

import re
import os
from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict, Optional, Set, Tuple


@dataclass
class Field:
    name: str
    fbs_type: str
    python_type: str
    is_required: bool
    is_list: bool
    is_enum: bool
    is_table: bool
    is_union: bool
    default: Optional[str]
    enum_namespace: Optional[str] = None


@dataclass  
class Table:
    name: str
    fields: List[Field]
    namespace: str


@dataclass
class Enum:
    name: str
    values: List[str]
    namespace: str


@dataclass
class Union:
    name: str
    types: List[str]
    namespace: str


class FBSParser:
    """Parse .fbs schema files"""
    
    # Map FlatBuffers types to Python types
    TYPE_MAP = {
        'bool': 'bool',
        'byte': 'int',
        'ubyte': 'int', 
        'short': 'int',
        'ushort': 'int',
        'int': 'int',
        'uint': 'int',
        'long': 'int',
        'ulong': 'int',
        'float': 'float',
        'double': 'float',
        'string': 'str',
    }
    
    def __init__(self, fbs_dir: str):
        self.fbs_dir = Path(fbs_dir)
        self.tables: Dict[str, Table] = {}
        self.enums: Dict[str, Enum] = {}
        self.unions: Dict[str, Union] = {}
        self.current_namespace = "quantra"
        
    def parse_all(self):
        """Parse all .fbs files in directory"""
        # Parse enums.fbs first (dependencies)
        enums_file = self.fbs_dir / "enums.fbs"
        if enums_file.exists():
            self.parse_file(enums_file)
            
        # Parse rest
        for fbs_file in sorted(self.fbs_dir.glob("*.fbs")):
            if fbs_file.name != "enums.fbs":
                self.parse_file(fbs_file)
                
    def parse_file(self, filepath: Path):
        """Parse a single .fbs file"""
        content = filepath.read_text()
        
        # Remove comments
        content = re.sub(r'//.*$', '', content, flags=re.MULTILINE)
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        
        # Extract namespace
        ns_match = re.search(r'namespace\s+([\w.]+);', content)
        if ns_match:
            self.current_namespace = ns_match.group(1)
        
        # Parse enums
        for match in re.finditer(r'enum\s+(\w+)\s*:\s*\w+\s*\{([^}]+)\}', content):
            enum_name = match.group(1)
            values_str = match.group(2)
            values = [v.strip().rstrip(',') for v in values_str.split('\n') if v.strip() and not v.strip().startswith('//')]
            values = [v.split('=')[0].strip() for v in values if v]  # Remove = assignments
            self.enums[enum_name] = Enum(enum_name, values, self.current_namespace)
            
        # Parse unions
        for match in re.finditer(r'union\s+(\w+)\s*\{([^}]+)\}', content):
            union_name = match.group(1)
            types_str = match.group(2)
            types = [t.strip().rstrip(',') for t in types_str.split(',') if t.strip()]
            self.unions[union_name] = Union(union_name, types, self.current_namespace)
            
        # Parse tables
        for match in re.finditer(r'table\s+(\w+)\s*\{([^}]+)\}', content):
            table_name = match.group(1)
            fields_str = match.group(2)
            fields = self._parse_fields(fields_str)
            self.tables[table_name] = Table(table_name, fields, self.current_namespace)
            
    def _parse_fields(self, fields_str: str) -> List[Field]:
        """Parse field definitions from table body"""
        fields = []
        for line in fields_str.split(';'):
            line = line.strip()
            if not line or line.startswith('//'):
                continue
                
            # Pattern: field_name:type (attributes) = default
            match = re.match(r'(\w+)\s*:\s*(\[?)(\w+(?:\.\w+)?)\]?\s*(?:\(([^)]*)\))?\s*(?:=\s*(\S+))?', line)
            if match:
                name = match.group(1)
                is_list = match.group(2) == '['
                fbs_type = match.group(3)
                attrs = match.group(4) or ''
                default = match.group(5)
                
                is_required = 'required' in attrs
                
                # Determine Python type
                is_enum = False
                is_table = False
                is_union = False
                enum_namespace = None
                
                # Handle namespaced types (enums.DayCounter)
                if '.' in fbs_type:
                    parts = fbs_type.split('.')
                    enum_namespace = parts[0]
                    fbs_type_simple = parts[1]
                    if fbs_type_simple in self.enums or enum_namespace == 'enums':
                        is_enum = True
                        python_type = fbs_type_simple
                    else:
                        python_type = fbs_type_simple
                elif fbs_type in self.TYPE_MAP:
                    python_type = self.TYPE_MAP[fbs_type]
                elif fbs_type in self.enums:
                    is_enum = True
                    python_type = fbs_type
                elif fbs_type in self.unions:
                    is_union = True
                    python_type = fbs_type
                else:
                    is_table = True
                    python_type = fbs_type
                    
                if is_list:
                    python_type = f'List[{python_type}]'
                    
                fields.append(Field(
                    name=name,
                    fbs_type=fbs_type,
                    python_type=python_type,
                    is_required=is_required,
                    is_list=is_list,
                    is_enum=is_enum,
                    is_table=is_table,
                    is_union=is_union,
                    default=default,
                    enum_namespace=enum_namespace
                ))
                
        return fields


class PythonGenerator:
    """Generate Python wrapper classes"""
    
    def __init__(self, parser: FBSParser):
        self.parser = parser
        
    def generate_enums(self) -> str:
        """Generate Python Enum classes"""
        lines = [
            '"""Auto-generated enum definitions from FlatBuffers schema"""',
            '',
            'from enum import IntEnum',
            '',
        ]
        
        for enum in self.parser.enums.values():
            lines.append(f'class {enum.name}(IntEnum):')
            for i, value in enumerate(enum.values):
                lines.append(f'    {value} = {i}')
            lines.append('')
            
        return '\n'.join(lines)
    
    def generate_models(self) -> str:
        """Generate Python dataclass models"""
        lines = [
            '"""Auto-generated model definitions from FlatBuffers schema"""',
            '',
            'from __future__ import annotations',
            'from dataclasses import dataclass, field',
            'from typing import List, Optional, Union',
            '',
            'from .enums import *',
            '',
        ]
        
        # Sort tables by dependency order (simple approach: alphabetical for now)
        for table in sorted(self.parser.tables.values(), key=lambda t: t.name):
            lines.extend(self._generate_table(table))
            lines.append('')
            
        return '\n'.join(lines)
    
    def _generate_table(self, table: Table) -> List[str]:
        """Generate a single dataclass"""
        lines = [
            '@dataclass',
            f'class {table.name}:',
            f'    """Generated from {table.namespace}.{table.name}"""',
        ]
        
        # Sort fields: required first, then optional
        required_fields = [f for f in table.fields if f.is_required]
        optional_fields = [f for f in table.fields if not f.is_required]
        
        for f in required_fields + optional_fields:
            python_name = self._to_snake_case(f.name)
            type_hint = self._get_type_hint(f)
            
            if f.is_required:
                lines.append(f'    {python_name}: {type_hint}')
            else:
                default = self._get_default(f)
                lines.append(f'    {python_name}: {type_hint} = {default}')
                
        if not table.fields:
            lines.append('    pass')
            
        return lines
    
    def _get_type_hint(self, f: Field) -> str:
        """Get Python type hint for field"""
        if f.is_list:
            inner = f.python_type.replace('List[', '').rstrip(']')
            return f'List[{inner}]'
        elif f.is_required:
            return f.python_type
        else:
            return f'Optional[{f.python_type}]'
            
    def _get_default(self, f: Field) -> str:
        """Get default value for optional field"""
        if f.is_list:
            return 'field(default_factory=list)'
        elif f.default:
            if f.is_enum:
                return f'{f.python_type}.{f.default}'
            elif f.python_type == 'str':
                return f'"{f.default}"'
            elif f.python_type == 'bool':
                return f.default.lower()
            else:
                return f.default
        else:
            return 'None'
            
    def _to_snake_case(self, name: str) -> str:
        """Convert camelCase to snake_case"""
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

    def generate_serializers(self) -> str:
        """Generate serialization functions"""
        lines = [
            '"""Auto-generated serialization functions"""',
            '',
            'import flatbuffers',
            'from typing import List',
            '',
            'from .models import *',
            'from .enums import *',
            '',
            '# Import generated FlatBuffers code',
            'from quantra import (',
        ]
        
        # Import all tables
        for table_name in sorted(self.parser.tables.keys()):
            lines.append(f'    {table_name} as FB{table_name},')
        lines.append(')')
        lines.append('')
        lines.append('from quantra.enums import (')
        for enum_name in sorted(self.parser.enums.keys()):
            lines.append(f'    {enum_name} as FB{enum_name},')
        lines.append(')')
        lines.append('')
        
        # Generate serializer for each table
        for table in sorted(self.parser.tables.values(), key=lambda t: t.name):
            lines.extend(self._generate_serializer(table))
            lines.append('')
            
        return '\n'.join(lines)
    
    def _generate_serializer(self, table: Table) -> List[str]:
        """Generate serializer function for a table"""
        func_name = f'serialize_{self._to_snake_case(table.name)}'
        lines = [
            f'def {func_name}(builder: flatbuffers.Builder, obj: {table.name}) -> int:',
            f'    """Serialize {table.name} to FlatBuffer"""',
        ]
        
        # Pre-create strings and nested objects
        pre_creates = []
        for f in table.fields:
            snake_name = self._to_snake_case(f.name)
            if f.python_type == 'str' or (f.is_list and 'str' in f.python_type):
                pre_creates.append(f)
            elif f.is_table and not f.is_list:
                pre_creates.append(f)
            elif f.is_list and f.is_table:
                pre_creates.append(f)
                
        for f in pre_creates:
            snake_name = self._to_snake_case(f.name)
            if f.python_type == 'str':
                lines.append(f'    {snake_name}_off = builder.CreateString(obj.{snake_name}) if obj.{snake_name} else None')
            elif f.is_table and not f.is_list:
                inner_func = f'serialize_{self._to_snake_case(f.fbs_type)}'
                lines.append(f'    {snake_name}_off = {inner_func}(builder, obj.{snake_name}) if obj.{snake_name} else None')
            elif f.is_list:
                inner_type = f.fbs_type
                if f.is_table:
                    inner_func = f'serialize_{self._to_snake_case(inner_type)}'
                    lines.append(f'    {snake_name}_offsets = [{inner_func}(builder, x) for x in obj.{snake_name}] if obj.{snake_name} else []')
                    lines.append(f'    FB{table.name}.Start{f.name}Vector(builder, len({snake_name}_offsets))')
                    lines.append(f'    for off in reversed({snake_name}_offsets):')
                    lines.append(f'        builder.PrependUOffsetTRelative(off)')
                    lines.append(f'    {snake_name}_off = builder.EndVector()')
                    
        # Start building
        lines.append(f'    FB{table.name}.Start(builder)')
        
        for f in table.fields:
            snake_name = self._to_snake_case(f.name)
            fbs_add = f'FB{table.name}.Add{f.name}'
            
            if f.python_type == 'str':
                lines.append(f'    if {snake_name}_off: {fbs_add}(builder, {snake_name}_off)')
            elif f.is_enum:
                lines.append(f'    if obj.{snake_name} is not None: {fbs_add}(builder, obj.{snake_name}.value)')
            elif f.is_table or f.is_list:
                lines.append(f'    if {snake_name}_off: {fbs_add}(builder, {snake_name}_off)')
            else:
                lines.append(f'    if obj.{snake_name} is not None: {fbs_add}(builder, obj.{snake_name})')
                
        lines.append(f'    return FB{table.name}.End(builder)')
        
        return lines

    def _to_snake_case(self, name: str) -> str:
        """Convert camelCase to snake_case"""
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Generate Python wrappers from FBS schemas')
    parser.add_argument('fbs_dir', help='Directory containing .fbs files')
    parser.add_argument('output_dir', help='Output directory for generated Python files')
    args = parser.parse_args()
    
    # Parse schemas
    fbs_parser = FBSParser(args.fbs_dir)
    fbs_parser.parse_all()
    
    # Generate Python
    generator = PythonGenerator(fbs_parser)
    
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Write enums
    (output_dir / 'enums.py').write_text(generator.generate_enums())
    print(f"Generated {output_dir / 'enums.py'}")
    
    # Write models
    (output_dir / 'models.py').write_text(generator.generate_models())
    print(f"Generated {output_dir / 'models.py'}")
    
    # Write serializers (basic version)
    # (output_dir / 'serializers.py').write_text(generator.generate_serializers())
    # print(f"Generated {output_dir / 'serializers.py'}")
    
    print(f"\nParsed {len(fbs_parser.enums)} enums, {len(fbs_parser.tables)} tables, {len(fbs_parser.unions)} unions")


if __name__ == '__main__':
    main()


