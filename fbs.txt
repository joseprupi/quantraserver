#### flatbuffers/fbs/cap_floor.fbs
include "enums.fbs";
include "index.fbs";
include "schedule.fbs";

namespace quantra;

// Cap or Floor instrument
// CapFloorType enum now in enums.fbs
table CapFloor {
    cap_floor_type:enums.CapFloorType;
    notional:double;
    strike:double;                           // Strike rate (e.g., 0.04 for 4%)
    schedule:Schedule;                       // Payment schedule
    index:Index;                             // Reference index (e.g., 3M Euribor)
    day_counter:enums.DayCounter;
    business_day_convention:enums.BusinessDayConvention;
}

root_type CapFloor;


#### flatbuffers/fbs/cap_floor_response.fbs
namespace quantra;

// Individual caplet/floorlet details
table CapFloorLet {
    payment_date:string;
    accrual_start_date:string;
    accrual_end_date:string;
    fixing_date:string;
    strike:double;
    forward_rate:double;
    discount:double;
    price:double;              // Individual caplet/floorlet price
}

// Cap/Floor pricing response
table CapFloorResponse {
    npv:double;
    atm_rate:double;           // At-the-money rate
    implied_volatility:double; // If priced from market price
    cap_floor_lets:[CapFloorLet];
}

// Response wrapper for multiple caps/floors
table PriceCapFloorResponse {
    cap_floors:[CapFloorResponse];
}

root_type PriceCapFloorResponse;


#### flatbuffers/fbs/cds.fbs
include "enums.fbs";
include "schedule.fbs";

namespace quantra;

// Credit Default Swap instrument
// ProtectionSide enum in enums.fbs
table CDS {
    side:enums.ProtectionSide;
    notional:double;
    spread:double;              // Running spread in decimal (0.01 = 100bps)
    schedule:Schedule;
    upfront:double = 0.0;       // Upfront payment (can be 0)
    day_counter:enums.DayCounter;
    business_day_convention:enums.BusinessDayConvention;
}

root_type CDS;


#### flatbuffers/fbs/cds_response.fbs
include "common.fbs";

namespace quantra;

// CDS pricing results
table CDSValues {
    npv:double;
    fair_spread:double;         // Par spread in decimal
    fair_upfront:double;        // Upfront for par spread
    default_leg_npv:double;     // NPV of protection leg
    premium_leg_npv:double;     // NPV of premium leg
    error:Error;
}

// Batch CDS pricing response
table PriceCDSResponse {
    cds_list:[CDSValues];
}

root_type PriceCDSResponse;


#### flatbuffers/fbs/common.fbs
include "term_structure.fbs";
include "volatility.fbs";
include "coupon_pricer.fbs";
include "enums.fbs";

namespace quantra;

table Yield {
    day_counter:enums.DayCounter;
    compounding:enums.Compounding;
    frequency:enums.Frequency;
}

// Central pricing configuration
// Curves and volatility surfaces are defined once here and referenced by id
table Pricing {
    as_of_date:string (required);
    settlement_date:string (required);
    
    // Market data - defined once, referenced by id in instrument pricing
    curves:[TermStructure] (required);
    volatilities:[VolatilityTermStructure];  // NEW: volatility surfaces
    
    // Bond-specific options
    bond_pricing_details:bool = false;
    bond_pricing_flows:bool = false;
    coupon_pricers:[CouponPricer];
}

table Error {
    error_message:string;
}

// ============================================================================
// Cash Flow Types
// ============================================================================
table FlowInterest {
    amount:double;
    fixing_date:string;
    accrual_start_date:string;
    accrual_end_date:string;
    discount:float;
    rate:float;
    price:float;
}

table FlowInterestFloat {
    amount:double;
    fixing_date:string;
    accrual_start_date:string;
    accrual_end_date:string;
    discount:float;
    rate:float;
    price:float;
}

table FlowPastInterestFloat {
    amount:double;
    fixing_date:string;
    accrual_start_date:string;
    accrual_end_date:string;
    rate:float;
}

table FlowPastInterest {
    amount:double;
    fixing_date:string;
    accrual_start_date:string;
    accrual_end_date:string;
    rate:float;
}

table FlowNotional {
    date:string;
    amount:double;
    discount:float;
    price:float;
}

union Flow { FlowInterest, FlowPastInterest, FlowNotional }

table FlowsWrapper {
    flow:Flow;
}


#### flatbuffers/fbs/coupon_pricer.fbs
include "enums.fbs";

namespace quantra;

table ConstantOptionletVolatility{
    settlement_days:int;
    calendar:enums.Calendar;
    business_day_convention:enums.BusinessDayConvention;
    volatility:double;
    day_counter:enums.DayCounter;
}

union OptionletVolatilityStructure {ConstantOptionletVolatility}

table BlackIborCouponPricer{
    optionlet_volatility_structure:OptionletVolatilityStructure;
}

union Pricer {BlackIborCouponPricer}

table CouponPricer {
    id:string;
    pricer:Pricer;
}

root_type CouponPricer; 



#### flatbuffers/fbs/credit_curve.fbs
include "enums.fbs";

namespace quantra;

// =============================================================================
// CREDIT CURVE
// =============================================================================
// Default probability curve for CDS pricing.

table CreditSpreadQuote {
    tenor_number:int;
    tenor_time_unit:enums.TimeUnit;
    spread:double;  // In decimal (0.01 = 100bps)
}

table CreditCurve {
    id:string;
    reference_date:string;
    calendar:enums.Calendar;
    day_counter:enums.DayCounter;
    recovery_rate:double = 0.4;
    
    // Build from CDS spread quotes
    quotes:[CreditSpreadQuote];
    
    // OR: use flat hazard rate
    flat_hazard_rate:double;
}


#### flatbuffers/fbs/enums.fbs
namespace quantra.enums;

// ============================================================================
// Day Count Conventions
// ============================================================================
enum DayCounter : byte { 
    Actual360,
    Actual365Fixed,
    Actual365NoLeap,
    ActualActual,
    ActualActualISMA,
    ActualActualBond,
    ActualActualISDA,
    ActualActualHistorical,
    ActualActual365,
    ActualActualAFB,
    ActualActualEuro,
    Business252,
    One,
    Simple,
    Thirty360,
}

// ============================================================================
// Curve Interpolation
// ============================================================================
enum Interpolator : byte { 
    BackwardFlat,
    ForwardFlat,
    Linear,
    LogCubic,
    LogLinear,
}

enum BootstrapTrait : byte { 
    Discount,
    FwdRate,
    InterpolatedDiscount,
    InterpolatedFwd,
    InterpolatedZero,
    ZeroRate 
}

// ============================================================================
// Time & Calendar
// ============================================================================
enum TimeUnit : byte { 
    Days,
    Hours,
    Microseconds,
    Milliseconds,
    Minutes,
    Months,
    Seconds,
    Weeks,
    Years,
}

enum Calendar : byte { 
    Argentina,
    Australia,
    BespokeCalendar,
    Brazil,
    Canada,
    China,
    CzechRepublic,
    Denmark,
    Finland,
    Germany,
    HongKong,
    Hungary,
    Iceland,
    India,
    Indonesia,
    Israel,
    Italy,
    Japan,
    Mexico,
    NewZealand,
    Norway,
    NullCalendar,
    Poland,
    Romania,
    Russia,
    SaudiArabia,
    Singapore,
    Slovakia,
    SouthAfrica,
    SouthKorea,
    Sweden,
    Switzerland,
    TARGET,
    Taiwan,
    Turkey,
    Ukraine,
    UnitedKingdom,
    UnitedStates,
    UnitedStatesGovernmentBond,
    UnitedStatesNERC,
    UnitedStatesNYSE,
    UnitedStatesSettlement,
    WeekendsOnly,
}

enum BusinessDayConvention : byte {
    Following,
    HalfMonthModifiedFollowing,
    ModifiedFollowing,
    ModifiedPreceding,
    Nearest,
    Preceding,
    Unadjusted,
} 

enum Frequency : byte {
    Annual,
    Bimonthly,
    Biweekly,
    Daily,
    EveryFourthMonth,
    EveryFourthWeek,
    Monthly,
    NoFrequency,
    Once,
    OtherFrequency,
    Quarterly,
    Semiannual,
    Weekly
}

enum DateGenerationRule : byte {
    Backward,
    CDS,
    Forward,
    OldCDS,
    ThirdWednesday,
    Twentieth,
    TwentiethIMM,
    Zero
}

// ============================================================================
// Interest Rate Indices
// ============================================================================
enum Ibor : byte {
    Euribor10M,
    Euribor11M,
    Euribor1M,
    Euribor1Y,
    Euribor2M,
    Euribor2W,
    Euribor365_10M,
    Euribor365_11M,
    Euribor365_1M,
    Euribor365_1Y,
    Euribor365_2M,
    Euribor365_2W,
    Euribor365_3M,
    Euribor365_3W,
    Euribor365_4M,
    Euribor365_5M,
    Euribor365_6M,
    Euribor365_7M,
    Euribor365_8M,
    Euribor365_9M,
    Euribor365_SW,
    Euribor3M,
    Euribor3W,
    Euribor4M,
    Euribor5M,
    Euribor6M,
    Euribor7M,
    Euribor8M,
    Euribor9M,
    EuriborSW
}

// ============================================================================
// Compounding
// ============================================================================
enum Compounding : byte {
    Compounded,
    Continuous,
    Simple,
    SimpleThenCompounded
}

// ============================================================================
// Product-Specific Enums (moved from individual .fbs files)
// ============================================================================

// Swap direction
enum SwapType : byte {
    Payer,      // Pay fixed, receive floating
    Receiver    // Receive fixed, pay floating
}

// FRA position
enum FRAType : byte {
    Long,       // Receive fixed, pay floating (benefit if rates rise)
    Short       // Pay fixed, receive floating (benefit if rates fall)
}

// Cap/Floor type
enum CapFloorType : byte {
    Cap,
    Floor,
    Collar      // Long cap + short floor
}

// Swaption exercise style
enum ExerciseType : byte {
    European,   // Exercise only at expiry
    Bermudan,   // Exercise on specific dates
    American    // Exercise any time
}

// Swaption settlement
enum SettlementType : byte {
    Physical,   // Deliver the swap
    Cash        // Cash settle the value
}

// CDS protection side
enum ProtectionSide : byte {
    Buyer,
    Seller
}

// ============================================================================
// Volatility
// ============================================================================
enum VolatilityType : byte {
    ShiftedLognormal,   // Black volatility (most common)
    Normal              // Bachelier/Normal volatility
}


#### flatbuffers/fbs/fixed_rate_bond.fbs
include "enums.fbs";
include "schedule.fbs";

namespace quantra;

table FixedRateBond {
    settlement_days:int;
    face_amount:double;
    rate:double;
    accrual_day_counter:enums.DayCounter;
    payment_convention:enums.BusinessDayConvention;
    redemption:double;
    issue_date:string;
    schedule:Schedule;
}

root_type FixedRateBond;

#### flatbuffers/fbs/fixed_rate_bond_response.fbs
include "common.fbs";

namespace quantra;

table FixedRateBondResponse{
    npv:double;
    clean_price:double;
    dirty_price:double;
    accrued_amount:double;
    yield:double;
    accrued_days:double;
    macaulay_duration:double;
    modified_duration:double;
    convexity:double;
    bps:double;
    flows:[FlowsWrapper];
}

table PriceFixedRateBondResponse{
    bonds:[FixedRateBondResponse];
}

root_type PriceFixedRateBondResponse;

#### flatbuffers/fbs/floating_rate_bond.fbs
include "enums.fbs";
include "schedule.fbs";
include "index.fbs";

namespace quantra;

table FloatingRateBond {
    settlement_days:int;
    face_amount:double;
    schedule:Schedule;
    index:Index;
    accrual_day_counter:enums.DayCounter;
    payment_convention:enums.BusinessDayConvention;
    fixing_days:int;
    spread:double;
    in_arrears:bool;
    redemption:double;
    issue_date:string;    
}

root_type FloatingRateBond;

#### flatbuffers/fbs/floating_rate_bond_response.fbs
include "common.fbs";

namespace quantra;

table FloatingRateBondResponse{
    npv:double;
    clean_price:double;
    dirty_price:double;
    accrued_amount:double;
    yield:double;
    accrued_days:double;
    macaulay_duration:double;
    modified_duration:double;
    convexity:double;
    bps:double;
    flows:[FlowsWrapper];
}

table PriceFloatingRateBondResponse{
    bonds:[FloatingRateBondResponse];
}

root_type PriceFloatingRateBondResponse;

#### flatbuffers/fbs/fra.fbs
include "enums.fbs";
include "index.fbs";

namespace quantra;

// Forward Rate Agreement
// FRAType enum now in enums.fbs
table FRA {
    fra_type:enums.FRAType;
    notional:double;
    start_date:string;              // When the FRA period starts
    maturity_date:string;           // When the FRA period ends
    strike:double;                  // The agreed forward rate (e.g., 0.035 for 3.5%)
    index:Index;                    // Reference index (e.g., 3M Euribor)
    day_counter:enums.DayCounter;
    calendar:enums.Calendar;
    business_day_convention:enums.BusinessDayConvention;
}

root_type FRA;


#### flatbuffers/fbs/fra_response.fbs
namespace quantra;

// FRA pricing response
table FRAResponse {
    npv:double;
    forward_rate:double;        // The implied forward rate from the curve
    spot_value:double;          // Value at settlement
    settlement_date:string;     // When the FRA settles
}

// Response wrapper for multiple FRAs
table PriceFRAResponse {
    fras:[FRAResponse];
}

root_type PriceFRAResponse;


#### flatbuffers/fbs/index.fbs
include "enums.fbs";

namespace quantra;

table Fixing{
    date:string;
    rate:float;
} 

table Index {
    period_number:int;
    period_time_unit:enums.TimeUnit;
    settlement_days:int;
    calendar:enums.Calendar;
    business_day_convention:enums.BusinessDayConvention;
    end_of_month:bool;
    day_counter:enums.DayCounter;
    fixings:[Fixing];
}

root_type Index;

#### flatbuffers/fbs/price_cap_floor_request.fbs
include "common.fbs";
include "cap_floor.fbs";

namespace quantra;

// Single Cap/Floor pricing request
table PriceCapFloor {
    cap_floor:CapFloor;
    discounting_curve:string;        // Reference to curve in Pricing.curves by id
    forwarding_curve:string;         // Reference to curve for forward rates by id
    volatility:string;               // Reference to volatility in Pricing.volatilities by id
    include_details:bool = false;    // Include caplet/floorlet breakdown
}

// Request to price one or more Caps/Floors
table PriceCapFloorRequest {
    pricing:Pricing;
    cap_floors:[PriceCapFloor];
}

root_type PriceCapFloorRequest;


#### flatbuffers/fbs/price_cds_request.fbs
include "common.fbs";
include "cds.fbs";

namespace quantra;

// Credit spread quote for building survival probability curve
table CreditSpreadQuote {
    tenor_number:int;
    tenor_time_unit:enums.TimeUnit;
    spread:double;  // In decimal (0.01 = 100bps)
}

// Credit curve - can be built from quotes or flat hazard rate
table CreditCurve {
    recovery_rate:double = 0.4;
    
    // Option 1: Build from CDS spread quotes
    quotes:[CreditSpreadQuote];
    
    // Option 2: Use flat hazard rate
    flat_hazard_rate:double;
}

// Single CDS pricing request
table PriceCDS {
    cds:CDS;
    discounting_curve:string;   // Reference to yield curve in Pricing
    credit_curve:CreditCurve;   // Embedded credit curve for this CDS
}

// Batch CDS pricing request
table PriceCDSRequest {
    pricing:Pricing;
    cds_list:[PriceCDS];
}

root_type PriceCDSRequest;


#### flatbuffers/fbs/price_fixed_rate_bond_request.fbs
include "common.fbs";
include "fixed_rate_bond.fbs";
include "floating_rate_bond.fbs";
include "term_structure.fbs";

namespace quantra;

table PriceFixedRateBond{
    fixed_rate_bond:FixedRateBond;
    discounting_curve:string;
    yield:Yield;
}

table PriceFixedRateBondRequest{
    pricing:Pricing;
    bonds:[PriceFixedRateBond];
}

root_type PriceFixedRateBondRequest;

#### flatbuffers/fbs/price_floating_rate_bond_request.fbs
include "common.fbs";
include "floating_rate_bond.fbs";
include "term_structure.fbs";

namespace quantra;

table PriceFloatingRateBond{
    floating_rate_bond:FloatingRateBond;
    discounting_curve:string;
    forecasting_curve:string;
    coupon_pricer:string;
    yield:Yield;
}

table PriceFloatingRateBondRequest{
    pricing:Pricing;
    bonds:[PriceFloatingRateBond];
}

root_type PriceFloatingRateBondRequest;

#### flatbuffers/fbs/price_fra_request.fbs
include "common.fbs";
include "fra.fbs";

namespace quantra;

// Single FRA pricing request
table PriceFRA {
    fra:FRA;
    discounting_curve:string;   // Reference to curve in Pricing.curves
    forwarding_curve:string;    // Reference to curve for forward rates
}

// Request to price one or more FRAs
table PriceFRARequest {
    pricing:Pricing;
    fras:[PriceFRA];
}

root_type PriceFRARequest;


#### flatbuffers/fbs/price_swaption_request.fbs
include "common.fbs";
include "swaption.fbs";

namespace quantra;

// Single Swaption pricing request
table PriceSwaption {
    swaption:Swaption;
    discounting_curve:string;        // Reference to curve in Pricing.curves by id
    forwarding_curve:string;         // Reference to curve for forward rates by id
    volatility:string;               // Reference to volatility in Pricing.volatilities by id
}

// Request to price one or more Swaptions
table PriceSwaptionRequest {
    pricing:Pricing;
    swaptions:[PriceSwaption];
}

root_type PriceSwaptionRequest;


#### flatbuffers/fbs/price_vanilla_swap_request.fbs
include "common.fbs";
include "vanilla_swap.fbs";

namespace quantra;

// Single swap pricing request
table PriceVanillaSwap {
    vanilla_swap:VanillaSwap;
    discounting_curve:string;      // Reference to curve in Pricing.curves
    forwarding_curve:string;       // Reference to curve for forward rates (can be same as discounting)
}

// Request to price one or more swaps
table PriceVanillaSwapRequest {
    pricing:Pricing;
    swaps:[PriceVanillaSwap];
    include_flows:bool = false;    // Include detailed cashflows in response
}

root_type PriceVanillaSwapRequest;


#### flatbuffers/fbs/schedule.fbs
include "enums.fbs";

namespace quantra;

table Schedule{
    calendar:enums.Calendar;
    effective_date:string;
    termination_date:string;
    frequency:enums.Frequency;
    convention:enums.BusinessDayConvention;
    termination_date_convention:enums.BusinessDayConvention;
    date_generation_rule:enums.DateGenerationRule;
    end_of_month:bool;
}

#### flatbuffers/fbs/swaption.fbs
include "enums.fbs";
include "vanilla_swap.fbs";

namespace quantra;

// Swaption instrument
// ExerciseType and SettlementType enums now in enums.fbs
table Swaption {
    exercise_type:enums.ExerciseType;
    settlement_type:enums.SettlementType;
    exercise_date:string;           // When option can be exercised
    underlying_swap:VanillaSwap;    // The swap you have option to enter
}

root_type Swaption;


#### flatbuffers/fbs/swaption_response.fbs
namespace quantra;

// Swaption pricing response
table SwaptionResponse {
    npv:double;
    implied_volatility:double;      // If priced from market
    atm_forward:double;             // ATM forward swap rate
    annuity:double;                 // PV01 of underlying swap
    delta:double;                   // Option delta
    vega:double;                    // Sensitivity to vol
}

// Response wrapper for multiple swaptions
table PriceSwaptionResponse {
    swaptions:[SwaptionResponse];
}

root_type PriceSwaptionResponse;


#### flatbuffers/fbs/term_structure.fbs
include "enums.fbs";
include "schedule.fbs";

namespace quantra;

table DepositHelper {
    rate:double;
    tenor_time_unit:enums.TimeUnit;
    tenor_number: int;
    fixing_days: int;
    calendar:enums.Calendar;
    business_day_convention:enums.BusinessDayConvention;
    day_counter:enums.DayCounter;
}

table FRAHelper {
    rate:double;
    months_to_start:int; 
    months_to_end:int; 
    fixing_days:int;
    calendar:enums.Calendar;
    business_day_convention:enums.BusinessDayConvention;
    day_counter:enums.DayCounter;
}

table FutureHelper {
    rate: double;
    future_start_date: string;
    future_months: int;
    calendar:enums.Calendar;
    business_day_convention:enums.BusinessDayConvention;
    day_counter:enums.DayCounter;
}

table SwapHelper {
    rate:double;
    tenor_time_unit:enums.TimeUnit;
    tenor_number: int;
    calendar:enums.Calendar;
    sw_fixed_leg_frequency:enums.Frequency;
    sw_fixed_leg_convention:enums.BusinessDayConvention;
    sw_fixed_leg_day_counter:enums.DayCounter;
    sw_floating_leg_index:enums.Ibor;
    spread:double;
    fwd_start_days:int; 
}

table BondHelper {
    rate:double;
    settlement_days:int;
    face_amount:double;
    schedule:Schedule;
    coupon_rate:double;
    day_counter:enums.DayCounter;
    business_day_convention:enums.BusinessDayConvention;
    redemption:double;
    issue_date:string; 
}

union Point { DepositHelper, FRAHelper, FutureHelper, SwapHelper, BondHelper }

table PointsWrapper{
    point:Point;
}

table TermStructure {
    id:string;
    day_counter:enums.DayCounter;
    interpolator:enums.Interpolator;
    bootstrap_trait:enums.BootstrapTrait;
    points:[PointsWrapper];
    reference_date:string;
}

root_type TermStructure;

#### flatbuffers/fbs/vanilla_swap.fbs
include "enums.fbs";
include "schedule.fbs";
include "index.fbs";

namespace quantra;

// Fixed leg of the swap
table SwapFixedLeg {
    schedule:Schedule;
    notional:double;
    rate:double;
    day_counter:enums.DayCounter;
    payment_convention:enums.BusinessDayConvention;
}

// Floating leg of the swap
table SwapFloatingLeg {
    schedule:Schedule;
    notional:double;
    index:Index;
    spread:double = 0.0;
    day_counter:enums.DayCounter;
    payment_convention:enums.BusinessDayConvention;
    fixing_days:int = 2;
    in_arrears:bool = false;
}

// Vanilla Interest Rate Swap
// SwapType enum now in enums.fbs
table VanillaSwap {
    swap_type:enums.SwapType;
    fixed_leg:SwapFixedLeg;
    floating_leg:SwapFloatingLeg;
}

root_type VanillaSwap;


#### flatbuffers/fbs/vanilla_swap_response.fbs
include "common.fbs";

namespace quantra;

// Cashflow for a swap leg
table SwapLegFlow {
    payment_date:string;
    accrual_start_date:string;
    accrual_end_date:string;
    amount:double;
    discount:double;
    present_value:double;
    // For floating leg
    fixing_date:string;
    index_fixing:double;
    spread:double;
    // For fixed leg
    rate:double;
}

// Response for a single leg
table SwapLegResponse {
    npv:double;
    bps:double;
    flows:[SwapLegFlow];
}

// Full swap response
table VanillaSwapResponse {
    npv:double;
    fair_rate:double;
    fair_spread:double;
    fixed_leg_bps:double;
    floating_leg_bps:double;
    fixed_leg_npv:double;
    floating_leg_npv:double;
    // Optional detailed flows
    fixed_leg_flows:[SwapLegFlow];
    floating_leg_flows:[SwapLegFlow];
}

// Response wrapper for multiple swaps
table PriceVanillaSwapResponse {
    swaps:[VanillaSwapResponse];
}

root_type PriceVanillaSwapResponse;


#### flatbuffers/fbs/volatility.fbs
include "enums.fbs";

namespace quantra;

// Volatility quote at a specific tenor/strike
table VolatilityQuote {
    tenor_number:int;
    tenor_time_unit:enums.TimeUnit;
    strike:double;                   // Optional: for smile (0 = ATM)
    volatility:double;
}

// Volatility term structure (flat or term structure)
// Created once in Pricing.volatilities, referenced by id
table VolatilityTermStructure {
    id:string (required);            // Unique identifier for referencing
    reference_date:string;
    calendar:enums.Calendar;
    business_day_convention:enums.BusinessDayConvention;
    day_counter:enums.DayCounter;
    volatility_type:enums.VolatilityType;
    
    // Either constant or term structure (use one)
    constant_vol:double;             // Use this for flat vol
    quotes:[VolatilityQuote];        // Use this for term structure
}

root_type VolatilityTermStructure;


