// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OISSWAP_QUANTRA_H_
#define FLATBUFFERS_GENERATED_OISSWAP_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"
#include "index_generated.h"
#include "schedule_generated.h"
#include "vanilla_swap_generated.h"

namespace quantra {

struct OisFloatingLeg;
struct OisFloatingLegBuilder;
struct OisFloatingLegT;

struct OisSwap;
struct OisSwapBuilder;
struct OisSwapT;

struct OisFloatingLegT : public ::flatbuffers::NativeTable {
  typedef OisFloatingLeg TableType;
  std::unique_ptr<quantra::ScheduleT> schedule{};
  double notional = 0.0;
  std::unique_ptr<quantra::IndexRefT> index{};
  double spread = 0.0;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::BusinessDayConvention payment_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::Calendar payment_calendar = quantra::enums::Calendar_TARGET;
  int32_t payment_lag = 0;
  quantra::enums::RateAveragingType averaging_method = quantra::enums::RateAveragingType_Compound;
  int32_t lookback_days = -1;
  int32_t lockout_days = 0;
  bool apply_observation_shift = false;
  bool telescopic_value_dates = false;
  OisFloatingLegT() = default;
  OisFloatingLegT(const OisFloatingLegT &o);
  OisFloatingLegT(OisFloatingLegT&&) FLATBUFFERS_NOEXCEPT = default;
  OisFloatingLegT &operator=(OisFloatingLegT o) FLATBUFFERS_NOEXCEPT;
};

struct OisFloatingLeg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OisFloatingLegT NativeTableType;
  typedef OisFloatingLegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEDULE = 4,
    VT_NOTIONAL = 6,
    VT_INDEX = 8,
    VT_SPREAD = 10,
    VT_DAY_COUNTER = 12,
    VT_PAYMENT_CONVENTION = 14,
    VT_PAYMENT_CALENDAR = 16,
    VT_PAYMENT_LAG = 18,
    VT_AVERAGING_METHOD = 20,
    VT_LOOKBACK_DAYS = 22,
    VT_LOCKOUT_DAYS = 24,
    VT_APPLY_OBSERVATION_SHIFT = 26,
    VT_TELESCOPIC_VALUE_DATES = 28
  };
  const quantra::Schedule *schedule() const {
    return GetPointer<const quantra::Schedule *>(VT_SCHEDULE);
  }
  double notional() const {
    return GetField<double>(VT_NOTIONAL, 0.0);
  }
  /// Reference to an overnight IndexDef by id (e.g., "USD_SOFR")
  const quantra::IndexRef *index() const {
    return GetPointer<const quantra::IndexRef *>(VT_INDEX);
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::BusinessDayConvention payment_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_PAYMENT_CONVENTION, 0));
  }
  /// Payment adjustments
  quantra::enums::Calendar payment_calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_PAYMENT_CALENDAR, 32));
  }
  int32_t payment_lag() const {
    return GetField<int32_t>(VT_PAYMENT_LAG, 0);
  }
  /// Overnight accrual conventions
  quantra::enums::RateAveragingType averaging_method() const {
    return static_cast<quantra::enums::RateAveragingType>(GetField<int8_t>(VT_AVERAGING_METHOD, 0));
  }
  int32_t lookback_days() const {
    return GetField<int32_t>(VT_LOOKBACK_DAYS, -1);
  }
  int32_t lockout_days() const {
    return GetField<int32_t>(VT_LOCKOUT_DAYS, 0);
  }
  bool apply_observation_shift() const {
    return GetField<uint8_t>(VT_APPLY_OBSERVATION_SHIFT, 0) != 0;
  }
  bool telescopic_value_dates() const {
    return GetField<uint8_t>(VT_TELESCOPIC_VALUE_DATES, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.VerifyTable(schedule()) &&
           VerifyField<double>(verifier, VT_NOTIONAL, 8) &&
           VerifyOffsetRequired(verifier, VT_INDEX) &&
           verifier.VerifyTable(index()) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_PAYMENT_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_PAYMENT_CALENDAR, 1) &&
           VerifyField<int32_t>(verifier, VT_PAYMENT_LAG, 4) &&
           VerifyField<int8_t>(verifier, VT_AVERAGING_METHOD, 1) &&
           VerifyField<int32_t>(verifier, VT_LOOKBACK_DAYS, 4) &&
           VerifyField<int32_t>(verifier, VT_LOCKOUT_DAYS, 4) &&
           VerifyField<uint8_t>(verifier, VT_APPLY_OBSERVATION_SHIFT, 1) &&
           VerifyField<uint8_t>(verifier, VT_TELESCOPIC_VALUE_DATES, 1) &&
           verifier.EndTable();
  }
  OisFloatingLegT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OisFloatingLegT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OisFloatingLeg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OisFloatingLegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OisFloatingLegBuilder {
  typedef OisFloatingLeg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_schedule(::flatbuffers::Offset<quantra::Schedule> schedule) {
    fbb_.AddOffset(OisFloatingLeg::VT_SCHEDULE, schedule);
  }
  void add_notional(double notional) {
    fbb_.AddElement<double>(OisFloatingLeg::VT_NOTIONAL, notional, 0.0);
  }
  void add_index(::flatbuffers::Offset<quantra::IndexRef> index) {
    fbb_.AddOffset(OisFloatingLeg::VT_INDEX, index);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(OisFloatingLeg::VT_SPREAD, spread, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(OisFloatingLeg::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_payment_convention(quantra::enums::BusinessDayConvention payment_convention) {
    fbb_.AddElement<int8_t>(OisFloatingLeg::VT_PAYMENT_CONVENTION, static_cast<int8_t>(payment_convention), 0);
  }
  void add_payment_calendar(quantra::enums::Calendar payment_calendar) {
    fbb_.AddElement<int8_t>(OisFloatingLeg::VT_PAYMENT_CALENDAR, static_cast<int8_t>(payment_calendar), 32);
  }
  void add_payment_lag(int32_t payment_lag) {
    fbb_.AddElement<int32_t>(OisFloatingLeg::VT_PAYMENT_LAG, payment_lag, 0);
  }
  void add_averaging_method(quantra::enums::RateAveragingType averaging_method) {
    fbb_.AddElement<int8_t>(OisFloatingLeg::VT_AVERAGING_METHOD, static_cast<int8_t>(averaging_method), 0);
  }
  void add_lookback_days(int32_t lookback_days) {
    fbb_.AddElement<int32_t>(OisFloatingLeg::VT_LOOKBACK_DAYS, lookback_days, -1);
  }
  void add_lockout_days(int32_t lockout_days) {
    fbb_.AddElement<int32_t>(OisFloatingLeg::VT_LOCKOUT_DAYS, lockout_days, 0);
  }
  void add_apply_observation_shift(bool apply_observation_shift) {
    fbb_.AddElement<uint8_t>(OisFloatingLeg::VT_APPLY_OBSERVATION_SHIFT, static_cast<uint8_t>(apply_observation_shift), 0);
  }
  void add_telescopic_value_dates(bool telescopic_value_dates) {
    fbb_.AddElement<uint8_t>(OisFloatingLeg::VT_TELESCOPIC_VALUE_DATES, static_cast<uint8_t>(telescopic_value_dates), 0);
  }
  explicit OisFloatingLegBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OisFloatingLeg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OisFloatingLeg>(end);
    fbb_.Required(o, OisFloatingLeg::VT_INDEX);
    return o;
  }
};

inline ::flatbuffers::Offset<OisFloatingLeg> CreateOisFloatingLeg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double notional = 0.0,
    ::flatbuffers::Offset<quantra::IndexRef> index = 0,
    double spread = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention payment_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::Calendar payment_calendar = quantra::enums::Calendar_TARGET,
    int32_t payment_lag = 0,
    quantra::enums::RateAveragingType averaging_method = quantra::enums::RateAveragingType_Compound,
    int32_t lookback_days = -1,
    int32_t lockout_days = 0,
    bool apply_observation_shift = false,
    bool telescopic_value_dates = false) {
  OisFloatingLegBuilder builder_(_fbb);
  builder_.add_spread(spread);
  builder_.add_notional(notional);
  builder_.add_lockout_days(lockout_days);
  builder_.add_lookback_days(lookback_days);
  builder_.add_payment_lag(payment_lag);
  builder_.add_index(index);
  builder_.add_schedule(schedule);
  builder_.add_telescopic_value_dates(telescopic_value_dates);
  builder_.add_apply_observation_shift(apply_observation_shift);
  builder_.add_averaging_method(averaging_method);
  builder_.add_payment_calendar(payment_calendar);
  builder_.add_payment_convention(payment_convention);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<OisFloatingLeg> CreateOisFloatingLeg(::flatbuffers::FlatBufferBuilder &_fbb, const OisFloatingLegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OisSwapT : public ::flatbuffers::NativeTable {
  typedef OisSwap TableType;
  quantra::enums::SwapType swap_type = quantra::enums::SwapType_Payer;
  std::unique_ptr<quantra::SwapFixedLegT> fixed_leg{};
  std::unique_ptr<quantra::OisFloatingLegT> overnight_leg{};
  OisSwapT() = default;
  OisSwapT(const OisSwapT &o);
  OisSwapT(OisSwapT&&) FLATBUFFERS_NOEXCEPT = default;
  OisSwapT &operator=(OisSwapT o) FLATBUFFERS_NOEXCEPT;
};

struct OisSwap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OisSwapT NativeTableType;
  typedef OisSwapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SWAP_TYPE = 4,
    VT_FIXED_LEG = 6,
    VT_OVERNIGHT_LEG = 8
  };
  quantra::enums::SwapType swap_type() const {
    return static_cast<quantra::enums::SwapType>(GetField<int8_t>(VT_SWAP_TYPE, 0));
  }
  const quantra::SwapFixedLeg *fixed_leg() const {
    return GetPointer<const quantra::SwapFixedLeg *>(VT_FIXED_LEG);
  }
  const quantra::OisFloatingLeg *overnight_leg() const {
    return GetPointer<const quantra::OisFloatingLeg *>(VT_OVERNIGHT_LEG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SWAP_TYPE, 1) &&
           VerifyOffset(verifier, VT_FIXED_LEG) &&
           verifier.VerifyTable(fixed_leg()) &&
           VerifyOffset(verifier, VT_OVERNIGHT_LEG) &&
           verifier.VerifyTable(overnight_leg()) &&
           verifier.EndTable();
  }
  OisSwapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OisSwapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OisSwap> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OisSwapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OisSwapBuilder {
  typedef OisSwap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_swap_type(quantra::enums::SwapType swap_type) {
    fbb_.AddElement<int8_t>(OisSwap::VT_SWAP_TYPE, static_cast<int8_t>(swap_type), 0);
  }
  void add_fixed_leg(::flatbuffers::Offset<quantra::SwapFixedLeg> fixed_leg) {
    fbb_.AddOffset(OisSwap::VT_FIXED_LEG, fixed_leg);
  }
  void add_overnight_leg(::flatbuffers::Offset<quantra::OisFloatingLeg> overnight_leg) {
    fbb_.AddOffset(OisSwap::VT_OVERNIGHT_LEG, overnight_leg);
  }
  explicit OisSwapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OisSwap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OisSwap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OisSwap> CreateOisSwap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::SwapType swap_type = quantra::enums::SwapType_Payer,
    ::flatbuffers::Offset<quantra::SwapFixedLeg> fixed_leg = 0,
    ::flatbuffers::Offset<quantra::OisFloatingLeg> overnight_leg = 0) {
  OisSwapBuilder builder_(_fbb);
  builder_.add_overnight_leg(overnight_leg);
  builder_.add_fixed_leg(fixed_leg);
  builder_.add_swap_type(swap_type);
  return builder_.Finish();
}

::flatbuffers::Offset<OisSwap> CreateOisSwap(::flatbuffers::FlatBufferBuilder &_fbb, const OisSwapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline OisFloatingLegT::OisFloatingLegT(const OisFloatingLegT &o)
      : schedule((o.schedule) ? new quantra::ScheduleT(*o.schedule) : nullptr),
        notional(o.notional),
        index((o.index) ? new quantra::IndexRefT(*o.index) : nullptr),
        spread(o.spread),
        day_counter(o.day_counter),
        payment_convention(o.payment_convention),
        payment_calendar(o.payment_calendar),
        payment_lag(o.payment_lag),
        averaging_method(o.averaging_method),
        lookback_days(o.lookback_days),
        lockout_days(o.lockout_days),
        apply_observation_shift(o.apply_observation_shift),
        telescopic_value_dates(o.telescopic_value_dates) {
}

inline OisFloatingLegT &OisFloatingLegT::operator=(OisFloatingLegT o) FLATBUFFERS_NOEXCEPT {
  std::swap(schedule, o.schedule);
  std::swap(notional, o.notional);
  std::swap(index, o.index);
  std::swap(spread, o.spread);
  std::swap(day_counter, o.day_counter);
  std::swap(payment_convention, o.payment_convention);
  std::swap(payment_calendar, o.payment_calendar);
  std::swap(payment_lag, o.payment_lag);
  std::swap(averaging_method, o.averaging_method);
  std::swap(lookback_days, o.lookback_days);
  std::swap(lockout_days, o.lockout_days);
  std::swap(apply_observation_shift, o.apply_observation_shift);
  std::swap(telescopic_value_dates, o.telescopic_value_dates);
  return *this;
}

inline OisFloatingLegT *OisFloatingLeg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OisFloatingLegT>(new OisFloatingLegT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OisFloatingLeg::UnPackTo(OisFloatingLegT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = schedule(); if (_e) { if(_o->schedule) { _e->UnPackTo(_o->schedule.get(), _resolver); } else { _o->schedule = std::unique_ptr<quantra::ScheduleT>(_e->UnPack(_resolver)); } } else if (_o->schedule) { _o->schedule.reset(); } }
  { auto _e = notional(); _o->notional = _e; }
  { auto _e = index(); if (_e) { if(_o->index) { _e->UnPackTo(_o->index.get(), _resolver); } else { _o->index = std::unique_ptr<quantra::IndexRefT>(_e->UnPack(_resolver)); } } else if (_o->index) { _o->index.reset(); } }
  { auto _e = spread(); _o->spread = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = payment_convention(); _o->payment_convention = _e; }
  { auto _e = payment_calendar(); _o->payment_calendar = _e; }
  { auto _e = payment_lag(); _o->payment_lag = _e; }
  { auto _e = averaging_method(); _o->averaging_method = _e; }
  { auto _e = lookback_days(); _o->lookback_days = _e; }
  { auto _e = lockout_days(); _o->lockout_days = _e; }
  { auto _e = apply_observation_shift(); _o->apply_observation_shift = _e; }
  { auto _e = telescopic_value_dates(); _o->telescopic_value_dates = _e; }
}

inline ::flatbuffers::Offset<OisFloatingLeg> OisFloatingLeg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OisFloatingLegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOisFloatingLeg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OisFloatingLeg> CreateOisFloatingLeg(::flatbuffers::FlatBufferBuilder &_fbb, const OisFloatingLegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OisFloatingLegT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _schedule = _o->schedule ? CreateSchedule(_fbb, _o->schedule.get(), _rehasher) : 0;
  auto _notional = _o->notional;
  auto _index = _o->index ? CreateIndexRef(_fbb, _o->index.get(), _rehasher) : 0;
  auto _spread = _o->spread;
  auto _day_counter = _o->day_counter;
  auto _payment_convention = _o->payment_convention;
  auto _payment_calendar = _o->payment_calendar;
  auto _payment_lag = _o->payment_lag;
  auto _averaging_method = _o->averaging_method;
  auto _lookback_days = _o->lookback_days;
  auto _lockout_days = _o->lockout_days;
  auto _apply_observation_shift = _o->apply_observation_shift;
  auto _telescopic_value_dates = _o->telescopic_value_dates;
  return quantra::CreateOisFloatingLeg(
      _fbb,
      _schedule,
      _notional,
      _index,
      _spread,
      _day_counter,
      _payment_convention,
      _payment_calendar,
      _payment_lag,
      _averaging_method,
      _lookback_days,
      _lockout_days,
      _apply_observation_shift,
      _telescopic_value_dates);
}

inline OisSwapT::OisSwapT(const OisSwapT &o)
      : swap_type(o.swap_type),
        fixed_leg((o.fixed_leg) ? new quantra::SwapFixedLegT(*o.fixed_leg) : nullptr),
        overnight_leg((o.overnight_leg) ? new quantra::OisFloatingLegT(*o.overnight_leg) : nullptr) {
}

inline OisSwapT &OisSwapT::operator=(OisSwapT o) FLATBUFFERS_NOEXCEPT {
  std::swap(swap_type, o.swap_type);
  std::swap(fixed_leg, o.fixed_leg);
  std::swap(overnight_leg, o.overnight_leg);
  return *this;
}

inline OisSwapT *OisSwap::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OisSwapT>(new OisSwapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OisSwap::UnPackTo(OisSwapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = swap_type(); _o->swap_type = _e; }
  { auto _e = fixed_leg(); if (_e) { if(_o->fixed_leg) { _e->UnPackTo(_o->fixed_leg.get(), _resolver); } else { _o->fixed_leg = std::unique_ptr<quantra::SwapFixedLegT>(_e->UnPack(_resolver)); } } else if (_o->fixed_leg) { _o->fixed_leg.reset(); } }
  { auto _e = overnight_leg(); if (_e) { if(_o->overnight_leg) { _e->UnPackTo(_o->overnight_leg.get(), _resolver); } else { _o->overnight_leg = std::unique_ptr<quantra::OisFloatingLegT>(_e->UnPack(_resolver)); } } else if (_o->overnight_leg) { _o->overnight_leg.reset(); } }
}

inline ::flatbuffers::Offset<OisSwap> OisSwap::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OisSwapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOisSwap(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OisSwap> CreateOisSwap(::flatbuffers::FlatBufferBuilder &_fbb, const OisSwapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OisSwapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _swap_type = _o->swap_type;
  auto _fixed_leg = _o->fixed_leg ? CreateSwapFixedLeg(_fbb, _o->fixed_leg.get(), _rehasher) : 0;
  auto _overnight_leg = _o->overnight_leg ? CreateOisFloatingLeg(_fbb, _o->overnight_leg.get(), _rehasher) : 0;
  return quantra::CreateOisSwap(
      _fbb,
      _swap_type,
      _fixed_leg,
      _overnight_leg);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_OISSWAP_QUANTRA_H_
