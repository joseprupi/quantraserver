// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VOLATILITY_QUANTRA_H_
#define FLATBUFFERS_GENERATED_VOLATILITY_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"

namespace quantra {

struct IrVolBaseSpec;
struct IrVolBaseSpecBuilder;
struct IrVolBaseSpecT;

struct BlackVolBaseSpec;
struct BlackVolBaseSpecBuilder;
struct BlackVolBaseSpecT;

struct OptionletVolSpec;
struct OptionletVolSpecBuilder;
struct OptionletVolSpecT;

struct SwaptionVolSpec;
struct SwaptionVolSpecBuilder;
struct SwaptionVolSpecT;

struct BlackVolSpec;
struct BlackVolSpecBuilder;
struct BlackVolSpecT;

struct VolSurfaceSpec;
struct VolSurfaceSpecBuilder;
struct VolSurfaceSpecT;

/// Union of all volatility types
enum VolPayload : uint8_t {
  VolPayload_NONE = 0,
  VolPayload_OptionletVolSpec = 1,
  VolPayload_SwaptionVolSpec = 2,
  VolPayload_BlackVolSpec = 3,
  VolPayload_MIN = VolPayload_NONE,
  VolPayload_MAX = VolPayload_BlackVolSpec
};

inline const VolPayload (&EnumValuesVolPayload())[4] {
  static const VolPayload values[] = {
    VolPayload_NONE,
    VolPayload_OptionletVolSpec,
    VolPayload_SwaptionVolSpec,
    VolPayload_BlackVolSpec
  };
  return values;
}

inline const char * const *EnumNamesVolPayload() {
  static const char * const names[5] = {
    "NONE",
    "OptionletVolSpec",
    "SwaptionVolSpec",
    "BlackVolSpec",
    nullptr
  };
  return names;
}

inline const char *EnumNameVolPayload(VolPayload e) {
  if (::flatbuffers::IsOutRange(e, VolPayload_NONE, VolPayload_BlackVolSpec)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVolPayload()[index];
}

template<typename T> struct VolPayloadTraits {
  static const VolPayload enum_value = VolPayload_NONE;
};

template<> struct VolPayloadTraits<quantra::OptionletVolSpec> {
  static const VolPayload enum_value = VolPayload_OptionletVolSpec;
};

template<> struct VolPayloadTraits<quantra::SwaptionVolSpec> {
  static const VolPayload enum_value = VolPayload_SwaptionVolSpec;
};

template<> struct VolPayloadTraits<quantra::BlackVolSpec> {
  static const VolPayload enum_value = VolPayload_BlackVolSpec;
};

template<typename T> struct VolPayloadUnionTraits {
  static const VolPayload enum_value = VolPayload_NONE;
};

template<> struct VolPayloadUnionTraits<quantra::OptionletVolSpecT> {
  static const VolPayload enum_value = VolPayload_OptionletVolSpec;
};

template<> struct VolPayloadUnionTraits<quantra::SwaptionVolSpecT> {
  static const VolPayload enum_value = VolPayload_SwaptionVolSpec;
};

template<> struct VolPayloadUnionTraits<quantra::BlackVolSpecT> {
  static const VolPayload enum_value = VolPayload_BlackVolSpec;
};

struct VolPayloadUnion {
  VolPayload type;
  void *value;

  VolPayloadUnion() : type(VolPayload_NONE), value(nullptr) {}
  VolPayloadUnion(VolPayloadUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(VolPayload_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  VolPayloadUnion(const VolPayloadUnion &);
  VolPayloadUnion &operator=(const VolPayloadUnion &u)
    { VolPayloadUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  VolPayloadUnion &operator=(VolPayloadUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~VolPayloadUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = VolPayloadUnionTraits<RT>::enum_value;
    if (type != VolPayload_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, VolPayload type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::OptionletVolSpecT *AsOptionletVolSpec() {
    return type == VolPayload_OptionletVolSpec ?
      reinterpret_cast<quantra::OptionletVolSpecT *>(value) : nullptr;
  }
  const quantra::OptionletVolSpecT *AsOptionletVolSpec() const {
    return type == VolPayload_OptionletVolSpec ?
      reinterpret_cast<const quantra::OptionletVolSpecT *>(value) : nullptr;
  }
  quantra::SwaptionVolSpecT *AsSwaptionVolSpec() {
    return type == VolPayload_SwaptionVolSpec ?
      reinterpret_cast<quantra::SwaptionVolSpecT *>(value) : nullptr;
  }
  const quantra::SwaptionVolSpecT *AsSwaptionVolSpec() const {
    return type == VolPayload_SwaptionVolSpec ?
      reinterpret_cast<const quantra::SwaptionVolSpecT *>(value) : nullptr;
  }
  quantra::BlackVolSpecT *AsBlackVolSpec() {
    return type == VolPayload_BlackVolSpec ?
      reinterpret_cast<quantra::BlackVolSpecT *>(value) : nullptr;
  }
  const quantra::BlackVolSpecT *AsBlackVolSpec() const {
    return type == VolPayload_BlackVolSpec ?
      reinterpret_cast<const quantra::BlackVolSpecT *>(value) : nullptr;
  }
};

bool VerifyVolPayload(::flatbuffers::Verifier &verifier, const void *obj, VolPayload type);
bool VerifyVolPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct IrVolBaseSpecT : public ::flatbuffers::NativeTable {
  typedef IrVolBaseSpec TableType;
  std::string reference_date{};
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::VolSurfaceShape shape = quantra::enums::VolSurfaceShape_Constant;
  quantra::enums::VolatilityType volatility_type = quantra::enums::VolatilityType_Normal;
  double displacement = 0.0;
  double constant_vol = 0.0;
};

struct IrVolBaseSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IrVolBaseSpecT NativeTableType;
  typedef IrVolBaseSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_DATE = 4,
    VT_CALENDAR = 6,
    VT_BUSINESS_DAY_CONVENTION = 8,
    VT_DAY_COUNTER = 10,
    VT_SHAPE = 12,
    VT_VOLATILITY_TYPE = 14,
    VT_DISPLACEMENT = 16,
    VT_CONSTANT_VOL = 18
  };
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::VolSurfaceShape shape() const {
    return static_cast<quantra::enums::VolSurfaceShape>(GetField<int8_t>(VT_SHAPE, 0));
  }
  quantra::enums::VolatilityType volatility_type() const {
    return static_cast<quantra::enums::VolatilityType>(GetField<int8_t>(VT_VOLATILITY_TYPE, 0));
  }
  double displacement() const {
    return GetField<double>(VT_DISPLACEMENT, 0.0);
  }
  double constant_vol() const {
    return GetField<double>(VT_CONSTANT_VOL, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_SHAPE, 1) &&
           VerifyField<int8_t>(verifier, VT_VOLATILITY_TYPE, 1) &&
           VerifyField<double>(verifier, VT_DISPLACEMENT, 8) &&
           VerifyField<double>(verifier, VT_CONSTANT_VOL, 8) &&
           verifier.EndTable();
  }
  IrVolBaseSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IrVolBaseSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IrVolBaseSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IrVolBaseSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IrVolBaseSpecBuilder {
  typedef IrVolBaseSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(IrVolBaseSpec::VT_REFERENCE_DATE, reference_date);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(IrVolBaseSpec::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(IrVolBaseSpec::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(IrVolBaseSpec::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_shape(quantra::enums::VolSurfaceShape shape) {
    fbb_.AddElement<int8_t>(IrVolBaseSpec::VT_SHAPE, static_cast<int8_t>(shape), 0);
  }
  void add_volatility_type(quantra::enums::VolatilityType volatility_type) {
    fbb_.AddElement<int8_t>(IrVolBaseSpec::VT_VOLATILITY_TYPE, static_cast<int8_t>(volatility_type), 0);
  }
  void add_displacement(double displacement) {
    fbb_.AddElement<double>(IrVolBaseSpec::VT_DISPLACEMENT, displacement, 0.0);
  }
  void add_constant_vol(double constant_vol) {
    fbb_.AddElement<double>(IrVolBaseSpec::VT_CONSTANT_VOL, constant_vol, 0.0);
  }
  explicit IrVolBaseSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IrVolBaseSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IrVolBaseSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IrVolBaseSpec> CreateIrVolBaseSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::VolSurfaceShape shape = quantra::enums::VolSurfaceShape_Constant,
    quantra::enums::VolatilityType volatility_type = quantra::enums::VolatilityType_Normal,
    double displacement = 0.0,
    double constant_vol = 0.0) {
  IrVolBaseSpecBuilder builder_(_fbb);
  builder_.add_constant_vol(constant_vol);
  builder_.add_displacement(displacement);
  builder_.add_reference_date(reference_date);
  builder_.add_volatility_type(volatility_type);
  builder_.add_shape(shape);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IrVolBaseSpec> CreateIrVolBaseSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *reference_date = nullptr,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::VolSurfaceShape shape = quantra::enums::VolSurfaceShape_Constant,
    quantra::enums::VolatilityType volatility_type = quantra::enums::VolatilityType_Normal,
    double displacement = 0.0,
    double constant_vol = 0.0) {
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  return quantra::CreateIrVolBaseSpec(
      _fbb,
      reference_date__,
      calendar,
      business_day_convention,
      day_counter,
      shape,
      volatility_type,
      displacement,
      constant_vol);
}

::flatbuffers::Offset<IrVolBaseSpec> CreateIrVolBaseSpec(::flatbuffers::FlatBufferBuilder &_fbb, const IrVolBaseSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlackVolBaseSpecT : public ::flatbuffers::NativeTable {
  typedef BlackVolBaseSpec TableType;
  std::string reference_date{};
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::VolSurfaceShape shape = quantra::enums::VolSurfaceShape_Constant;
  double constant_vol = 0.0;
};

struct BlackVolBaseSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlackVolBaseSpecT NativeTableType;
  typedef BlackVolBaseSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_DATE = 4,
    VT_CALENDAR = 6,
    VT_BUSINESS_DAY_CONVENTION = 8,
    VT_DAY_COUNTER = 10,
    VT_SHAPE = 12,
    VT_CONSTANT_VOL = 14
  };
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::VolSurfaceShape shape() const {
    return static_cast<quantra::enums::VolSurfaceShape>(GetField<int8_t>(VT_SHAPE, 0));
  }
  double constant_vol() const {
    return GetField<double>(VT_CONSTANT_VOL, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_SHAPE, 1) &&
           VerifyField<double>(verifier, VT_CONSTANT_VOL, 8) &&
           verifier.EndTable();
  }
  BlackVolBaseSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlackVolBaseSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BlackVolBaseSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolBaseSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlackVolBaseSpecBuilder {
  typedef BlackVolBaseSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(BlackVolBaseSpec::VT_REFERENCE_DATE, reference_date);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(BlackVolBaseSpec::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(BlackVolBaseSpec::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(BlackVolBaseSpec::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_shape(quantra::enums::VolSurfaceShape shape) {
    fbb_.AddElement<int8_t>(BlackVolBaseSpec::VT_SHAPE, static_cast<int8_t>(shape), 0);
  }
  void add_constant_vol(double constant_vol) {
    fbb_.AddElement<double>(BlackVolBaseSpec::VT_CONSTANT_VOL, constant_vol, 0.0);
  }
  explicit BlackVolBaseSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlackVolBaseSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlackVolBaseSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlackVolBaseSpec> CreateBlackVolBaseSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::VolSurfaceShape shape = quantra::enums::VolSurfaceShape_Constant,
    double constant_vol = 0.0) {
  BlackVolBaseSpecBuilder builder_(_fbb);
  builder_.add_constant_vol(constant_vol);
  builder_.add_reference_date(reference_date);
  builder_.add_shape(shape);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BlackVolBaseSpec> CreateBlackVolBaseSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *reference_date = nullptr,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::VolSurfaceShape shape = quantra::enums::VolSurfaceShape_Constant,
    double constant_vol = 0.0) {
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  return quantra::CreateBlackVolBaseSpec(
      _fbb,
      reference_date__,
      calendar,
      business_day_convention,
      day_counter,
      shape,
      constant_vol);
}

::flatbuffers::Offset<BlackVolBaseSpec> CreateBlackVolBaseSpec(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolBaseSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OptionletVolSpecT : public ::flatbuffers::NativeTable {
  typedef OptionletVolSpec TableType;
  std::unique_ptr<quantra::IrVolBaseSpecT> base{};
  OptionletVolSpecT() = default;
  OptionletVolSpecT(const OptionletVolSpecT &o);
  OptionletVolSpecT(OptionletVolSpecT&&) FLATBUFFERS_NOEXCEPT = default;
  OptionletVolSpecT &operator=(OptionletVolSpecT o) FLATBUFFERS_NOEXCEPT;
};

/// Optionlet volatility for Caps/Floors
struct OptionletVolSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionletVolSpecT NativeTableType;
  typedef OptionletVolSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4
  };
  const quantra::IrVolBaseSpec *base() const {
    return GetPointer<const quantra::IrVolBaseSpec *>(VT_BASE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
  OptionletVolSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OptionletVolSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OptionletVolSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionletVolSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OptionletVolSpecBuilder {
  typedef OptionletVolSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<quantra::IrVolBaseSpec> base) {
    fbb_.AddOffset(OptionletVolSpec::VT_BASE, base);
  }
  explicit OptionletVolSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionletVolSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionletVolSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionletVolSpec> CreateOptionletVolSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::IrVolBaseSpec> base = 0) {
  OptionletVolSpecBuilder builder_(_fbb);
  builder_.add_base(base);
  return builder_.Finish();
}

::flatbuffers::Offset<OptionletVolSpec> CreateOptionletVolSpec(::flatbuffers::FlatBufferBuilder &_fbb, const OptionletVolSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwaptionVolSpecT : public ::flatbuffers::NativeTable {
  typedef SwaptionVolSpec TableType;
  std::unique_ptr<quantra::IrVolBaseSpecT> base{};
  SwaptionVolSpecT() = default;
  SwaptionVolSpecT(const SwaptionVolSpecT &o);
  SwaptionVolSpecT(SwaptionVolSpecT&&) FLATBUFFERS_NOEXCEPT = default;
  SwaptionVolSpecT &operator=(SwaptionVolSpecT o) FLATBUFFERS_NOEXCEPT;
};

/// Swaption volatility
struct SwaptionVolSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwaptionVolSpecT NativeTableType;
  typedef SwaptionVolSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4
  };
  const quantra::IrVolBaseSpec *base() const {
    return GetPointer<const quantra::IrVolBaseSpec *>(VT_BASE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
  SwaptionVolSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwaptionVolSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwaptionVolSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionVolSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwaptionVolSpecBuilder {
  typedef SwaptionVolSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<quantra::IrVolBaseSpec> base) {
    fbb_.AddOffset(SwaptionVolSpec::VT_BASE, base);
  }
  explicit SwaptionVolSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwaptionVolSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwaptionVolSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwaptionVolSpec> CreateSwaptionVolSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::IrVolBaseSpec> base = 0) {
  SwaptionVolSpecBuilder builder_(_fbb);
  builder_.add_base(base);
  return builder_.Finish();
}

::flatbuffers::Offset<SwaptionVolSpec> CreateSwaptionVolSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionVolSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BlackVolSpecT : public ::flatbuffers::NativeTable {
  typedef BlackVolSpec TableType;
  std::unique_ptr<quantra::BlackVolBaseSpecT> base{};
  BlackVolSpecT() = default;
  BlackVolSpecT(const BlackVolSpecT &o);
  BlackVolSpecT(BlackVolSpecT&&) FLATBUFFERS_NOEXCEPT = default;
  BlackVolSpecT &operator=(BlackVolSpecT o) FLATBUFFERS_NOEXCEPT;
};

/// Black volatility for Equity/FX/Commodity options
struct BlackVolSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlackVolSpecT NativeTableType;
  typedef BlackVolSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4
  };
  const quantra::BlackVolBaseSpec *base() const {
    return GetPointer<const quantra::BlackVolBaseSpec *>(VT_BASE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
  BlackVolSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BlackVolSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BlackVolSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BlackVolSpecBuilder {
  typedef BlackVolSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_base(::flatbuffers::Offset<quantra::BlackVolBaseSpec> base) {
    fbb_.AddOffset(BlackVolSpec::VT_BASE, base);
  }
  explicit BlackVolSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlackVolSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlackVolSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlackVolSpec> CreateBlackVolSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::BlackVolBaseSpec> base = 0) {
  BlackVolSpecBuilder builder_(_fbb);
  builder_.add_base(base);
  return builder_.Finish();
}

::flatbuffers::Offset<BlackVolSpec> CreateBlackVolSpec(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VolSurfaceSpecT : public ::flatbuffers::NativeTable {
  typedef VolSurfaceSpec TableType;
  std::string id{};
  quantra::VolPayloadUnion payload{};
};

/// Volatility surface specification - referenced by id in trade requests
struct VolSurfaceSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VolSurfaceSpecT NativeTableType;
  typedef VolSurfaceSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::VolPayload payload_type() const {
    return static_cast<quantra::VolPayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const quantra::OptionletVolSpec *payload_as_OptionletVolSpec() const {
    return payload_type() == quantra::VolPayload_OptionletVolSpec ? static_cast<const quantra::OptionletVolSpec *>(payload()) : nullptr;
  }
  const quantra::SwaptionVolSpec *payload_as_SwaptionVolSpec() const {
    return payload_type() == quantra::VolPayload_SwaptionVolSpec ? static_cast<const quantra::SwaptionVolSpec *>(payload()) : nullptr;
  }
  const quantra::BlackVolSpec *payload_as_BlackVolSpec() const {
    return payload_type() == quantra::VolPayload_BlackVolSpec ? static_cast<const quantra::BlackVolSpec *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyVolPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
  VolSurfaceSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VolSurfaceSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VolSurfaceSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::OptionletVolSpec *VolSurfaceSpec::payload_as<quantra::OptionletVolSpec>() const {
  return payload_as_OptionletVolSpec();
}

template<> inline const quantra::SwaptionVolSpec *VolSurfaceSpec::payload_as<quantra::SwaptionVolSpec>() const {
  return payload_as_SwaptionVolSpec();
}

template<> inline const quantra::BlackVolSpec *VolSurfaceSpec::payload_as<quantra::BlackVolSpec>() const {
  return payload_as_BlackVolSpec();
}

struct VolSurfaceSpecBuilder {
  typedef VolSurfaceSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(VolSurfaceSpec::VT_ID, id);
  }
  void add_payload_type(quantra::VolPayload payload_type) {
    fbb_.AddElement<uint8_t>(VolSurfaceSpec::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(VolSurfaceSpec::VT_PAYLOAD, payload);
  }
  explicit VolSurfaceSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VolSurfaceSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VolSurfaceSpec>(end);
    fbb_.Required(o, VolSurfaceSpec::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<VolSurfaceSpec> CreateVolSurfaceSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::VolPayload payload_type = quantra::VolPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  VolSurfaceSpecBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_id(id);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VolSurfaceSpec> CreateVolSurfaceSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::VolPayload payload_type = quantra::VolPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return quantra::CreateVolSurfaceSpec(
      _fbb,
      id__,
      payload_type,
      payload);
}

::flatbuffers::Offset<VolSurfaceSpec> CreateVolSurfaceSpec(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline IrVolBaseSpecT *IrVolBaseSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IrVolBaseSpecT>(new IrVolBaseSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IrVolBaseSpec::UnPackTo(IrVolBaseSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reference_date(); if (_e) _o->reference_date = _e->str(); }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = shape(); _o->shape = _e; }
  { auto _e = volatility_type(); _o->volatility_type = _e; }
  { auto _e = displacement(); _o->displacement = _e; }
  { auto _e = constant_vol(); _o->constant_vol = _e; }
}

inline ::flatbuffers::Offset<IrVolBaseSpec> IrVolBaseSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IrVolBaseSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIrVolBaseSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IrVolBaseSpec> CreateIrVolBaseSpec(::flatbuffers::FlatBufferBuilder &_fbb, const IrVolBaseSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IrVolBaseSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reference_date = _o->reference_date.empty() ? 0 : _fbb.CreateString(_o->reference_date);
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  auto _shape = _o->shape;
  auto _volatility_type = _o->volatility_type;
  auto _displacement = _o->displacement;
  auto _constant_vol = _o->constant_vol;
  return quantra::CreateIrVolBaseSpec(
      _fbb,
      _reference_date,
      _calendar,
      _business_day_convention,
      _day_counter,
      _shape,
      _volatility_type,
      _displacement,
      _constant_vol);
}

inline BlackVolBaseSpecT *BlackVolBaseSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BlackVolBaseSpecT>(new BlackVolBaseSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BlackVolBaseSpec::UnPackTo(BlackVolBaseSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reference_date(); if (_e) _o->reference_date = _e->str(); }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = shape(); _o->shape = _e; }
  { auto _e = constant_vol(); _o->constant_vol = _e; }
}

inline ::flatbuffers::Offset<BlackVolBaseSpec> BlackVolBaseSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolBaseSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlackVolBaseSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BlackVolBaseSpec> CreateBlackVolBaseSpec(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolBaseSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BlackVolBaseSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reference_date = _o->reference_date.empty() ? 0 : _fbb.CreateString(_o->reference_date);
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  auto _shape = _o->shape;
  auto _constant_vol = _o->constant_vol;
  return quantra::CreateBlackVolBaseSpec(
      _fbb,
      _reference_date,
      _calendar,
      _business_day_convention,
      _day_counter,
      _shape,
      _constant_vol);
}

inline OptionletVolSpecT::OptionletVolSpecT(const OptionletVolSpecT &o)
      : base((o.base) ? new quantra::IrVolBaseSpecT(*o.base) : nullptr) {
}

inline OptionletVolSpecT &OptionletVolSpecT::operator=(OptionletVolSpecT o) FLATBUFFERS_NOEXCEPT {
  std::swap(base, o.base);
  return *this;
}

inline OptionletVolSpecT *OptionletVolSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OptionletVolSpecT>(new OptionletVolSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OptionletVolSpec::UnPackTo(OptionletVolSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base(); if (_e) { if(_o->base) { _e->UnPackTo(_o->base.get(), _resolver); } else { _o->base = std::unique_ptr<quantra::IrVolBaseSpecT>(_e->UnPack(_resolver)); } } else if (_o->base) { _o->base.reset(); } }
}

inline ::flatbuffers::Offset<OptionletVolSpec> OptionletVolSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionletVolSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOptionletVolSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OptionletVolSpec> CreateOptionletVolSpec(::flatbuffers::FlatBufferBuilder &_fbb, const OptionletVolSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OptionletVolSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base = _o->base ? CreateIrVolBaseSpec(_fbb, _o->base.get(), _rehasher) : 0;
  return quantra::CreateOptionletVolSpec(
      _fbb,
      _base);
}

inline SwaptionVolSpecT::SwaptionVolSpecT(const SwaptionVolSpecT &o)
      : base((o.base) ? new quantra::IrVolBaseSpecT(*o.base) : nullptr) {
}

inline SwaptionVolSpecT &SwaptionVolSpecT::operator=(SwaptionVolSpecT o) FLATBUFFERS_NOEXCEPT {
  std::swap(base, o.base);
  return *this;
}

inline SwaptionVolSpecT *SwaptionVolSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwaptionVolSpecT>(new SwaptionVolSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwaptionVolSpec::UnPackTo(SwaptionVolSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base(); if (_e) { if(_o->base) { _e->UnPackTo(_o->base.get(), _resolver); } else { _o->base = std::unique_ptr<quantra::IrVolBaseSpecT>(_e->UnPack(_resolver)); } } else if (_o->base) { _o->base.reset(); } }
}

inline ::flatbuffers::Offset<SwaptionVolSpec> SwaptionVolSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionVolSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwaptionVolSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwaptionVolSpec> CreateSwaptionVolSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionVolSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwaptionVolSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base = _o->base ? CreateIrVolBaseSpec(_fbb, _o->base.get(), _rehasher) : 0;
  return quantra::CreateSwaptionVolSpec(
      _fbb,
      _base);
}

inline BlackVolSpecT::BlackVolSpecT(const BlackVolSpecT &o)
      : base((o.base) ? new quantra::BlackVolBaseSpecT(*o.base) : nullptr) {
}

inline BlackVolSpecT &BlackVolSpecT::operator=(BlackVolSpecT o) FLATBUFFERS_NOEXCEPT {
  std::swap(base, o.base);
  return *this;
}

inline BlackVolSpecT *BlackVolSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BlackVolSpecT>(new BlackVolSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BlackVolSpec::UnPackTo(BlackVolSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = base(); if (_e) { if(_o->base) { _e->UnPackTo(_o->base.get(), _resolver); } else { _o->base = std::unique_ptr<quantra::BlackVolBaseSpecT>(_e->UnPack(_resolver)); } } else if (_o->base) { _o->base.reset(); } }
}

inline ::flatbuffers::Offset<BlackVolSpec> BlackVolSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBlackVolSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BlackVolSpec> CreateBlackVolSpec(::flatbuffers::FlatBufferBuilder &_fbb, const BlackVolSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BlackVolSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _base = _o->base ? CreateBlackVolBaseSpec(_fbb, _o->base.get(), _rehasher) : 0;
  return quantra::CreateBlackVolSpec(
      _fbb,
      _base);
}

inline VolSurfaceSpecT *VolSurfaceSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VolSurfaceSpecT>(new VolSurfaceSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VolSurfaceSpec::UnPackTo(VolSurfaceSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = payload_type(); _o->payload.type = _e; }
  { auto _e = payload(); if (_e) _o->payload.value = quantra::VolPayloadUnion::UnPack(_e, payload_type(), _resolver); }
}

inline ::flatbuffers::Offset<VolSurfaceSpec> VolSurfaceSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVolSurfaceSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VolSurfaceSpec> CreateVolSurfaceSpec(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VolSurfaceSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _payload_type = _o->payload.type;
  auto _payload = _o->payload.Pack(_fbb);
  return quantra::CreateVolSurfaceSpec(
      _fbb,
      _id,
      _payload_type,
      _payload);
}

inline bool VerifyVolPayload(::flatbuffers::Verifier &verifier, const void *obj, VolPayload type) {
  switch (type) {
    case VolPayload_NONE: {
      return true;
    }
    case VolPayload_OptionletVolSpec: {
      auto ptr = reinterpret_cast<const quantra::OptionletVolSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VolPayload_SwaptionVolSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionVolSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VolPayload_BlackVolSpec: {
      auto ptr = reinterpret_cast<const quantra::BlackVolSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVolPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVolPayload(
        verifier,  values->Get(i), types->GetEnum<VolPayload>(i))) {
      return false;
    }
  }
  return true;
}

inline void *VolPayloadUnion::UnPack(const void *obj, VolPayload type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case VolPayload_OptionletVolSpec: {
      auto ptr = reinterpret_cast<const quantra::OptionletVolSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case VolPayload_SwaptionVolSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionVolSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case VolPayload_BlackVolSpec: {
      auto ptr = reinterpret_cast<const quantra::BlackVolSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> VolPayloadUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case VolPayload_OptionletVolSpec: {
      auto ptr = reinterpret_cast<const quantra::OptionletVolSpecT *>(value);
      return CreateOptionletVolSpec(_fbb, ptr, _rehasher).Union();
    }
    case VolPayload_SwaptionVolSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionVolSpecT *>(value);
      return CreateSwaptionVolSpec(_fbb, ptr, _rehasher).Union();
    }
    case VolPayload_BlackVolSpec: {
      auto ptr = reinterpret_cast<const quantra::BlackVolSpecT *>(value);
      return CreateBlackVolSpec(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline VolPayloadUnion::VolPayloadUnion(const VolPayloadUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case VolPayload_OptionletVolSpec: {
      value = new quantra::OptionletVolSpecT(*reinterpret_cast<quantra::OptionletVolSpecT *>(u.value));
      break;
    }
    case VolPayload_SwaptionVolSpec: {
      value = new quantra::SwaptionVolSpecT(*reinterpret_cast<quantra::SwaptionVolSpecT *>(u.value));
      break;
    }
    case VolPayload_BlackVolSpec: {
      value = new quantra::BlackVolSpecT(*reinterpret_cast<quantra::BlackVolSpecT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void VolPayloadUnion::Reset() {
  switch (type) {
    case VolPayload_OptionletVolSpec: {
      auto ptr = reinterpret_cast<quantra::OptionletVolSpecT *>(value);
      delete ptr;
      break;
    }
    case VolPayload_SwaptionVolSpec: {
      auto ptr = reinterpret_cast<quantra::SwaptionVolSpecT *>(value);
      delete ptr;
      break;
    }
    case VolPayload_BlackVolSpec: {
      auto ptr = reinterpret_cast<quantra::BlackVolSpecT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = VolPayload_NONE;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_VOLATILITY_QUANTRA_H_
