// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_
#define FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "coupon_pricer_generated.h"
#include "credit_curve_generated.h"
#include "enums_generated.h"
#include "index_generated.h"
#include "model_generated.h"
#include "quotes_generated.h"
#include "term_structure_generated.h"
#include "volatility_generated.h"

namespace quantra {

struct Yield;
struct YieldBuilder;
struct YieldT;

struct Pricing;
struct PricingBuilder;
struct PricingT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct FlowInterest;
struct FlowInterestBuilder;
struct FlowInterestT;

struct FlowInterestFloat;
struct FlowInterestFloatBuilder;
struct FlowInterestFloatT;

struct FlowPastInterestFloat;
struct FlowPastInterestFloatBuilder;
struct FlowPastInterestFloatT;

struct FlowPastInterest;
struct FlowPastInterestBuilder;
struct FlowPastInterestT;

struct FlowNotional;
struct FlowNotionalBuilder;
struct FlowNotionalT;

struct FlowsWrapper;
struct FlowsWrapperBuilder;
struct FlowsWrapperT;

enum Flow : uint8_t {
  Flow_NONE = 0,
  Flow_FlowInterest = 1,
  Flow_FlowPastInterest = 2,
  Flow_FlowNotional = 3,
  Flow_MIN = Flow_NONE,
  Flow_MAX = Flow_FlowNotional
};

inline const Flow (&EnumValuesFlow())[4] {
  static const Flow values[] = {
    Flow_NONE,
    Flow_FlowInterest,
    Flow_FlowPastInterest,
    Flow_FlowNotional
  };
  return values;
}

inline const char * const *EnumNamesFlow() {
  static const char * const names[5] = {
    "NONE",
    "FlowInterest",
    "FlowPastInterest",
    "FlowNotional",
    nullptr
  };
  return names;
}

inline const char *EnumNameFlow(Flow e) {
  if (::flatbuffers::IsOutRange(e, Flow_NONE, Flow_FlowNotional)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFlow()[index];
}

template<typename T> struct FlowTraits {
  static const Flow enum_value = Flow_NONE;
};

template<> struct FlowTraits<quantra::FlowInterest> {
  static const Flow enum_value = Flow_FlowInterest;
};

template<> struct FlowTraits<quantra::FlowPastInterest> {
  static const Flow enum_value = Flow_FlowPastInterest;
};

template<> struct FlowTraits<quantra::FlowNotional> {
  static const Flow enum_value = Flow_FlowNotional;
};

template<typename T> struct FlowUnionTraits {
  static const Flow enum_value = Flow_NONE;
};

template<> struct FlowUnionTraits<quantra::FlowInterestT> {
  static const Flow enum_value = Flow_FlowInterest;
};

template<> struct FlowUnionTraits<quantra::FlowPastInterestT> {
  static const Flow enum_value = Flow_FlowPastInterest;
};

template<> struct FlowUnionTraits<quantra::FlowNotionalT> {
  static const Flow enum_value = Flow_FlowNotional;
};

struct FlowUnion {
  Flow type;
  void *value;

  FlowUnion() : type(Flow_NONE), value(nullptr) {}
  FlowUnion(FlowUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Flow_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  FlowUnion(const FlowUnion &);
  FlowUnion &operator=(const FlowUnion &u)
    { FlowUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  FlowUnion &operator=(FlowUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~FlowUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = FlowUnionTraits<RT>::enum_value;
    if (type != Flow_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Flow type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::FlowInterestT *AsFlowInterest() {
    return type == Flow_FlowInterest ?
      reinterpret_cast<quantra::FlowInterestT *>(value) : nullptr;
  }
  const quantra::FlowInterestT *AsFlowInterest() const {
    return type == Flow_FlowInterest ?
      reinterpret_cast<const quantra::FlowInterestT *>(value) : nullptr;
  }
  quantra::FlowPastInterestT *AsFlowPastInterest() {
    return type == Flow_FlowPastInterest ?
      reinterpret_cast<quantra::FlowPastInterestT *>(value) : nullptr;
  }
  const quantra::FlowPastInterestT *AsFlowPastInterest() const {
    return type == Flow_FlowPastInterest ?
      reinterpret_cast<const quantra::FlowPastInterestT *>(value) : nullptr;
  }
  quantra::FlowNotionalT *AsFlowNotional() {
    return type == Flow_FlowNotional ?
      reinterpret_cast<quantra::FlowNotionalT *>(value) : nullptr;
  }
  const quantra::FlowNotionalT *AsFlowNotional() const {
    return type == Flow_FlowNotional ?
      reinterpret_cast<const quantra::FlowNotionalT *>(value) : nullptr;
  }
};

bool VerifyFlow(::flatbuffers::Verifier &verifier, const void *obj, Flow type);
bool VerifyFlowVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct YieldT : public ::flatbuffers::NativeTable {
  typedef Yield TableType;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::Compounding compounding = quantra::enums::Compounding_Compounded;
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
};

struct Yield FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef YieldT NativeTableType;
  typedef YieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DAY_COUNTER = 4,
    VT_COMPOUNDING = 6,
    VT_FREQUENCY = 8
  };
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 0));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING, 1) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           verifier.EndTable();
  }
  YieldT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(YieldT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Yield> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct YieldBuilder {
  typedef Yield Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(Yield::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(Yield::VT_COMPOUNDING, static_cast<int8_t>(compounding), 0);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(Yield::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  explicit YieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Yield> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Yield>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Yield> CreateYield(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Compounded,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual) {
  YieldBuilder builder_(_fbb);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<Yield> CreateYield(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PricingT : public ::flatbuffers::NativeTable {
  typedef Pricing TableType;
  std::string as_of_date{};
  std::string settlement_date{};
  std::vector<std::unique_ptr<quantra::IndexDefT>> indices{};
  std::vector<std::unique_ptr<quantra::TermStructureT>> curves{};
  std::vector<std::unique_ptr<quantra::CreditCurveSpecT>> credit_curves{};
  std::vector<std::unique_ptr<quantra::QuoteSpecT>> quotes{};
  std::vector<std::unique_ptr<quantra::VolSurfaceSpecT>> vol_surfaces{};
  std::vector<std::unique_ptr<quantra::ModelSpecT>> models{};
  bool bond_pricing_details = false;
  bool bond_pricing_flows = false;
  bool swaption_pricing_details = false;
  bool swaption_pricing_rebump = false;
  std::vector<std::unique_ptr<quantra::CouponPricerT>> coupon_pricers{};
  PricingT() = default;
  PricingT(const PricingT &o);
  PricingT(PricingT&&) FLATBUFFERS_NOEXCEPT = default;
  PricingT &operator=(PricingT o) FLATBUFFERS_NOEXCEPT;
};

struct Pricing FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PricingT NativeTableType;
  typedef PricingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AS_OF_DATE = 4,
    VT_SETTLEMENT_DATE = 6,
    VT_INDICES = 8,
    VT_CURVES = 10,
    VT_CREDIT_CURVES = 12,
    VT_QUOTES = 14,
    VT_VOL_SURFACES = 16,
    VT_MODELS = 18,
    VT_BOND_PRICING_DETAILS = 20,
    VT_BOND_PRICING_FLOWS = 22,
    VT_SWAPTION_PRICING_DETAILS = 24,
    VT_SWAPTION_PRICING_REBUMP = 26,
    VT_COUPON_PRICERS = 28
  };
  /// Valuation date (YYYY-MM-DD). Used by: ALL
  const ::flatbuffers::String *as_of_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AS_OF_DATE);
  }
  /// Settlement date (YYYY-MM-DD). Used by: FixedRateBond, FloatingRateBond
  const ::flatbuffers::String *settlement_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTLEMENT_DATE);
  }
  /// Index definitions. Used by: ALL floating-rate instruments and curve helpers.
  /// Every IndexRef in the request must resolve to an IndexDef here.
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>> *>(VT_INDICES);
  }
  /// Yield curves for discounting/forwarding. Used by: ALL
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>> *curves() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>> *>(VT_CURVES);
  }
  /// Credit curves for CDS pricing. Used by: CDS
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CreditCurveSpec>> *credit_curves() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CreditCurveSpec>> *>(VT_CREDIT_CURVES);
  }
  /// Market quotes (spot prices, FX rates). Used by: EquityOption (future)
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::QuoteSpec>> *quotes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::QuoteSpec>> *>(VT_QUOTES);
  }
  /// Volatility surfaces (typed by product family). Used by: CapFloor, Swaption, EquityOption
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolSurfaceSpec>> *vol_surfaces() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolSurfaceSpec>> *>(VT_VOL_SURFACES);
  }
  /// Pricing models/engines (typed by product family). Used by: CapFloor, Swaption, CDS, EquityOption
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::ModelSpec>> *models() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::ModelSpec>> *>(VT_MODELS);
  }
  /// Include bond analytics (duration, convexity). Used by: FixedRateBond, FloatingRateBond
  bool bond_pricing_details() const {
    return GetField<uint8_t>(VT_BOND_PRICING_DETAILS, 0) != 0;
  }
  /// Include cash flow details. Used by: FixedRateBond, FloatingRateBond
  bool bond_pricing_flows() const {
    return GetField<uint8_t>(VT_BOND_PRICING_FLOWS, 0) != 0;
  }
  /// Include detailed swaption analytics (delta/vega/gamma/theta/DV01).
  bool swaption_pricing_details() const {
    return GetField<uint8_t>(VT_SWAPTION_PRICING_DETAILS, 0) != 0;
  }
  /// Include curve-rebump swaption analytics (Bloomberg-style).
  bool swaption_pricing_rebump() const {
    return GetField<uint8_t>(VT_SWAPTION_PRICING_REBUMP, 0) != 0;
  }
  /// Coupon pricers for floating legs. Used by: FloatingRateBond, VanillaSwap
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>> *coupon_pricers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>> *>(VT_COUPON_PRICERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_AS_OF_DATE) &&
           verifier.VerifyString(as_of_date()) &&
           VerifyOffset(verifier, VT_SETTLEMENT_DATE) &&
           verifier.VerifyString(settlement_date()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.VerifyVectorOfTables(indices()) &&
           VerifyOffsetRequired(verifier, VT_CURVES) &&
           verifier.VerifyVector(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           VerifyOffset(verifier, VT_CREDIT_CURVES) &&
           verifier.VerifyVector(credit_curves()) &&
           verifier.VerifyVectorOfTables(credit_curves()) &&
           VerifyOffset(verifier, VT_QUOTES) &&
           verifier.VerifyVector(quotes()) &&
           verifier.VerifyVectorOfTables(quotes()) &&
           VerifyOffset(verifier, VT_VOL_SURFACES) &&
           verifier.VerifyVector(vol_surfaces()) &&
           verifier.VerifyVectorOfTables(vol_surfaces()) &&
           VerifyOffset(verifier, VT_MODELS) &&
           verifier.VerifyVector(models()) &&
           verifier.VerifyVectorOfTables(models()) &&
           VerifyField<uint8_t>(verifier, VT_BOND_PRICING_DETAILS, 1) &&
           VerifyField<uint8_t>(verifier, VT_BOND_PRICING_FLOWS, 1) &&
           VerifyField<uint8_t>(verifier, VT_SWAPTION_PRICING_DETAILS, 1) &&
           VerifyField<uint8_t>(verifier, VT_SWAPTION_PRICING_REBUMP, 1) &&
           VerifyOffset(verifier, VT_COUPON_PRICERS) &&
           verifier.VerifyVector(coupon_pricers()) &&
           verifier.VerifyVectorOfTables(coupon_pricers()) &&
           verifier.EndTable();
  }
  PricingT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PricingT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Pricing> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PricingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PricingBuilder {
  typedef Pricing Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_as_of_date(::flatbuffers::Offset<::flatbuffers::String> as_of_date) {
    fbb_.AddOffset(Pricing::VT_AS_OF_DATE, as_of_date);
  }
  void add_settlement_date(::flatbuffers::Offset<::flatbuffers::String> settlement_date) {
    fbb_.AddOffset(Pricing::VT_SETTLEMENT_DATE, settlement_date);
  }
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>>> indices) {
    fbb_.AddOffset(Pricing::VT_INDICES, indices);
  }
  void add_curves(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>>> curves) {
    fbb_.AddOffset(Pricing::VT_CURVES, curves);
  }
  void add_credit_curves(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CreditCurveSpec>>> credit_curves) {
    fbb_.AddOffset(Pricing::VT_CREDIT_CURVES, credit_curves);
  }
  void add_quotes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::QuoteSpec>>> quotes) {
    fbb_.AddOffset(Pricing::VT_QUOTES, quotes);
  }
  void add_vol_surfaces(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolSurfaceSpec>>> vol_surfaces) {
    fbb_.AddOffset(Pricing::VT_VOL_SURFACES, vol_surfaces);
  }
  void add_models(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::ModelSpec>>> models) {
    fbb_.AddOffset(Pricing::VT_MODELS, models);
  }
  void add_bond_pricing_details(bool bond_pricing_details) {
    fbb_.AddElement<uint8_t>(Pricing::VT_BOND_PRICING_DETAILS, static_cast<uint8_t>(bond_pricing_details), 0);
  }
  void add_bond_pricing_flows(bool bond_pricing_flows) {
    fbb_.AddElement<uint8_t>(Pricing::VT_BOND_PRICING_FLOWS, static_cast<uint8_t>(bond_pricing_flows), 0);
  }
  void add_swaption_pricing_details(bool swaption_pricing_details) {
    fbb_.AddElement<uint8_t>(Pricing::VT_SWAPTION_PRICING_DETAILS, static_cast<uint8_t>(swaption_pricing_details), 0);
  }
  void add_swaption_pricing_rebump(bool swaption_pricing_rebump) {
    fbb_.AddElement<uint8_t>(Pricing::VT_SWAPTION_PRICING_REBUMP, static_cast<uint8_t>(swaption_pricing_rebump), 0);
  }
  void add_coupon_pricers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>>> coupon_pricers) {
    fbb_.AddOffset(Pricing::VT_COUPON_PRICERS, coupon_pricers);
  }
  explicit PricingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pricing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pricing>(end);
    fbb_.Required(o, Pricing::VT_AS_OF_DATE);
    fbb_.Required(o, Pricing::VT_CURVES);
    return o;
  }
};

inline ::flatbuffers::Offset<Pricing> CreatePricing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> as_of_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> settlement_date = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>>> indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>>> curves = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CreditCurveSpec>>> credit_curves = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::QuoteSpec>>> quotes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolSurfaceSpec>>> vol_surfaces = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::ModelSpec>>> models = 0,
    bool bond_pricing_details = false,
    bool bond_pricing_flows = false,
    bool swaption_pricing_details = false,
    bool swaption_pricing_rebump = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>>> coupon_pricers = 0) {
  PricingBuilder builder_(_fbb);
  builder_.add_coupon_pricers(coupon_pricers);
  builder_.add_models(models);
  builder_.add_vol_surfaces(vol_surfaces);
  builder_.add_quotes(quotes);
  builder_.add_credit_curves(credit_curves);
  builder_.add_curves(curves);
  builder_.add_indices(indices);
  builder_.add_settlement_date(settlement_date);
  builder_.add_as_of_date(as_of_date);
  builder_.add_swaption_pricing_rebump(swaption_pricing_rebump);
  builder_.add_swaption_pricing_details(swaption_pricing_details);
  builder_.add_bond_pricing_flows(bond_pricing_flows);
  builder_.add_bond_pricing_details(bond_pricing_details);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Pricing> CreatePricingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *as_of_date = nullptr,
    const char *settlement_date = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::IndexDef>> *indices = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::TermStructure>> *curves = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::CreditCurveSpec>> *credit_curves = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::QuoteSpec>> *quotes = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::VolSurfaceSpec>> *vol_surfaces = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::ModelSpec>> *models = nullptr,
    bool bond_pricing_details = false,
    bool bond_pricing_flows = false,
    bool swaption_pricing_details = false,
    bool swaption_pricing_rebump = false,
    const std::vector<::flatbuffers::Offset<quantra::CouponPricer>> *coupon_pricers = nullptr) {
  auto as_of_date__ = as_of_date ? _fbb.CreateString(as_of_date) : 0;
  auto settlement_date__ = settlement_date ? _fbb.CreateString(settlement_date) : 0;
  auto indices__ = indices ? _fbb.CreateVector<::flatbuffers::Offset<quantra::IndexDef>>(*indices) : 0;
  auto curves__ = curves ? _fbb.CreateVector<::flatbuffers::Offset<quantra::TermStructure>>(*curves) : 0;
  auto credit_curves__ = credit_curves ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CreditCurveSpec>>(*credit_curves) : 0;
  auto quotes__ = quotes ? _fbb.CreateVector<::flatbuffers::Offset<quantra::QuoteSpec>>(*quotes) : 0;
  auto vol_surfaces__ = vol_surfaces ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VolSurfaceSpec>>(*vol_surfaces) : 0;
  auto models__ = models ? _fbb.CreateVector<::flatbuffers::Offset<quantra::ModelSpec>>(*models) : 0;
  auto coupon_pricers__ = coupon_pricers ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CouponPricer>>(*coupon_pricers) : 0;
  return quantra::CreatePricing(
      _fbb,
      as_of_date__,
      settlement_date__,
      indices__,
      curves__,
      credit_curves__,
      quotes__,
      vol_surfaces__,
      models__,
      bond_pricing_details,
      bond_pricing_flows,
      swaption_pricing_details,
      swaption_pricing_rebump,
      coupon_pricers__);
}

::flatbuffers::Offset<Pricing> CreatePricing(::flatbuffers::FlatBufferBuilder &_fbb, const PricingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public ::flatbuffers::NativeTable {
  typedef Error TableType;
  std::string error_message{};
};

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorT NativeTableType;
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_MESSAGE = 4
  };
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Error> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(Error::VT_ERROR_MESSAGE, error_message);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return quantra::CreateError(
      _fbb,
      error_message__);
}

::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowInterestT : public ::flatbuffers::NativeTable {
  typedef FlowInterest TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float discount = 0.0f;
  float rate = 0.0f;
  float price = 0.0f;
};

struct FlowInterest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowInterestT NativeTableType;
  typedef FlowInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
  FlowInterestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowInterest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowInterestBuilder {
  typedef FlowInterest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterest::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterest::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterest::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowInterest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

::flatbuffers::Offset<FlowInterest> CreateFlowInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowInterestFloatT : public ::flatbuffers::NativeTable {
  typedef FlowInterestFloat TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float discount = 0.0f;
  float rate = 0.0f;
  float price = 0.0f;
};

struct FlowInterestFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowInterestFloatT NativeTableType;
  typedef FlowInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
  FlowInterestFloatT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowInterestFloat> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowInterestFloatBuilder {
  typedef FlowInterestFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowInterestFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowPastInterestFloatT : public ::flatbuffers::NativeTable {
  typedef FlowPastInterestFloat TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float rate = 0.0f;
};

struct FlowPastInterestFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowPastInterestFloatT NativeTableType;
  typedef FlowPastInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           verifier.EndTable();
  }
  FlowPastInterestFloatT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowPastInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowPastInterestFloat> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowPastInterestFloatBuilder {
  typedef FlowPastInterestFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterestFloat::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowPastInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowPastInterestFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowPastInterestT : public ::flatbuffers::NativeTable {
  typedef FlowPastInterest TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float rate = 0.0f;
};

struct FlowPastInterest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowPastInterestT NativeTableType;
  typedef FlowPastInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           verifier.EndTable();
  }
  FlowPastInterestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowPastInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowPastInterest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowPastInterestBuilder {
  typedef FlowPastInterest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterest::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowPastInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowPastInterest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowNotionalT : public ::flatbuffers::NativeTable {
  typedef FlowNotional TableType;
  std::string date{};
  double amount = 0.0;
  float discount = 0.0f;
  float price = 0.0f;
};

struct FlowNotional FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowNotionalT NativeTableType;
  typedef FlowNotionalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_AMOUNT = 6,
    VT_DISCOUNT = 8,
    VT_PRICE = 10
  };
  const ::flatbuffers::String *date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
  FlowNotionalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowNotionalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowNotional> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowNotionalBuilder {
  typedef FlowNotional Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_date(::flatbuffers::Offset<::flatbuffers::String> date) {
    fbb_.AddOffset(FlowNotional::VT_DATE, date);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowNotional::VT_AMOUNT, amount, 0.0);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowNotional::VT_DISCOUNT, discount, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowNotional::VT_PRICE, price, 0.0f);
  }
  explicit FlowNotionalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowNotional> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowNotional>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotional(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> date = 0,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  FlowNotionalBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_discount(discount);
  builder_.add_date(date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotionalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *date = nullptr,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  auto date__ = date ? _fbb.CreateString(date) : 0;
  return quantra::CreateFlowNotional(
      _fbb,
      date__,
      amount,
      discount,
      price);
}

::flatbuffers::Offset<FlowNotional> CreateFlowNotional(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowsWrapperT : public ::flatbuffers::NativeTable {
  typedef FlowsWrapper TableType;
  quantra::FlowUnion flow{};
};

struct FlowsWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowsWrapperT NativeTableType;
  typedef FlowsWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOW_TYPE = 4,
    VT_FLOW = 6
  };
  quantra::Flow flow_type() const {
    return static_cast<quantra::Flow>(GetField<uint8_t>(VT_FLOW_TYPE, 0));
  }
  const void *flow() const {
    return GetPointer<const void *>(VT_FLOW);
  }
  template<typename T> const T *flow_as() const;
  const quantra::FlowInterest *flow_as_FlowInterest() const {
    return flow_type() == quantra::Flow_FlowInterest ? static_cast<const quantra::FlowInterest *>(flow()) : nullptr;
  }
  const quantra::FlowPastInterest *flow_as_FlowPastInterest() const {
    return flow_type() == quantra::Flow_FlowPastInterest ? static_cast<const quantra::FlowPastInterest *>(flow()) : nullptr;
  }
  const quantra::FlowNotional *flow_as_FlowNotional() const {
    return flow_type() == quantra::Flow_FlowNotional ? static_cast<const quantra::FlowNotional *>(flow()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLOW_TYPE, 1) &&
           VerifyOffset(verifier, VT_FLOW) &&
           VerifyFlow(verifier, flow(), flow_type()) &&
           verifier.EndTable();
  }
  FlowsWrapperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowsWrapper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::FlowInterest *FlowsWrapper::flow_as<quantra::FlowInterest>() const {
  return flow_as_FlowInterest();
}

template<> inline const quantra::FlowPastInterest *FlowsWrapper::flow_as<quantra::FlowPastInterest>() const {
  return flow_as_FlowPastInterest();
}

template<> inline const quantra::FlowNotional *FlowsWrapper::flow_as<quantra::FlowNotional>() const {
  return flow_as_FlowNotional();
}

struct FlowsWrapperBuilder {
  typedef FlowsWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flow_type(quantra::Flow flow_type) {
    fbb_.AddElement<uint8_t>(FlowsWrapper::VT_FLOW_TYPE, static_cast<uint8_t>(flow_type), 0);
  }
  void add_flow(::flatbuffers::Offset<void> flow) {
    fbb_.AddOffset(FlowsWrapper::VT_FLOW, flow);
  }
  explicit FlowsWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowsWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowsWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::Flow flow_type = quantra::Flow_NONE,
    ::flatbuffers::Offset<void> flow = 0) {
  FlowsWrapperBuilder builder_(_fbb);
  builder_.add_flow(flow);
  builder_.add_flow_type(flow_type);
  return builder_.Finish();
}

::flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline YieldT *Yield::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<YieldT>(new YieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Yield::UnPackTo(YieldT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = compounding(); _o->compounding = _e; }
  { auto _e = frequency(); _o->frequency = _e; }
}

inline ::flatbuffers::Offset<Yield> Yield::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateYield(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Yield> CreateYield(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const YieldT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _day_counter = _o->day_counter;
  auto _compounding = _o->compounding;
  auto _frequency = _o->frequency;
  return quantra::CreateYield(
      _fbb,
      _day_counter,
      _compounding,
      _frequency);
}

inline PricingT::PricingT(const PricingT &o)
      : as_of_date(o.as_of_date),
        settlement_date(o.settlement_date),
        bond_pricing_details(o.bond_pricing_details),
        bond_pricing_flows(o.bond_pricing_flows),
        swaption_pricing_details(o.swaption_pricing_details),
        swaption_pricing_rebump(o.swaption_pricing_rebump) {
  indices.reserve(o.indices.size());
  for (const auto &indices_ : o.indices) { indices.emplace_back((indices_) ? new quantra::IndexDefT(*indices_) : nullptr); }
  curves.reserve(o.curves.size());
  for (const auto &curves_ : o.curves) { curves.emplace_back((curves_) ? new quantra::TermStructureT(*curves_) : nullptr); }
  credit_curves.reserve(o.credit_curves.size());
  for (const auto &credit_curves_ : o.credit_curves) { credit_curves.emplace_back((credit_curves_) ? new quantra::CreditCurveSpecT(*credit_curves_) : nullptr); }
  quotes.reserve(o.quotes.size());
  for (const auto &quotes_ : o.quotes) { quotes.emplace_back((quotes_) ? new quantra::QuoteSpecT(*quotes_) : nullptr); }
  vol_surfaces.reserve(o.vol_surfaces.size());
  for (const auto &vol_surfaces_ : o.vol_surfaces) { vol_surfaces.emplace_back((vol_surfaces_) ? new quantra::VolSurfaceSpecT(*vol_surfaces_) : nullptr); }
  models.reserve(o.models.size());
  for (const auto &models_ : o.models) { models.emplace_back((models_) ? new quantra::ModelSpecT(*models_) : nullptr); }
  coupon_pricers.reserve(o.coupon_pricers.size());
  for (const auto &coupon_pricers_ : o.coupon_pricers) { coupon_pricers.emplace_back((coupon_pricers_) ? new quantra::CouponPricerT(*coupon_pricers_) : nullptr); }
}

inline PricingT &PricingT::operator=(PricingT o) FLATBUFFERS_NOEXCEPT {
  std::swap(as_of_date, o.as_of_date);
  std::swap(settlement_date, o.settlement_date);
  std::swap(indices, o.indices);
  std::swap(curves, o.curves);
  std::swap(credit_curves, o.credit_curves);
  std::swap(quotes, o.quotes);
  std::swap(vol_surfaces, o.vol_surfaces);
  std::swap(models, o.models);
  std::swap(bond_pricing_details, o.bond_pricing_details);
  std::swap(bond_pricing_flows, o.bond_pricing_flows);
  std::swap(swaption_pricing_details, o.swaption_pricing_details);
  std::swap(swaption_pricing_rebump, o.swaption_pricing_rebump);
  std::swap(coupon_pricers, o.coupon_pricers);
  return *this;
}

inline PricingT *Pricing::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PricingT>(new PricingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pricing::UnPackTo(PricingT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = as_of_date(); if (_e) _o->as_of_date = _e->str(); }
  { auto _e = settlement_date(); if (_e) _o->settlement_date = _e->str(); }
  { auto _e = indices(); if (_e) { _o->indices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->indices[_i]) { _e->Get(_i)->UnPackTo(_o->indices[_i].get(), _resolver); } else { _o->indices[_i] = std::unique_ptr<quantra::IndexDefT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->indices.resize(0); } }
  { auto _e = curves(); if (_e) { _o->curves.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->curves[_i]) { _e->Get(_i)->UnPackTo(_o->curves[_i].get(), _resolver); } else { _o->curves[_i] = std::unique_ptr<quantra::TermStructureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->curves.resize(0); } }
  { auto _e = credit_curves(); if (_e) { _o->credit_curves.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->credit_curves[_i]) { _e->Get(_i)->UnPackTo(_o->credit_curves[_i].get(), _resolver); } else { _o->credit_curves[_i] = std::unique_ptr<quantra::CreditCurveSpecT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->credit_curves.resize(0); } }
  { auto _e = quotes(); if (_e) { _o->quotes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->quotes[_i]) { _e->Get(_i)->UnPackTo(_o->quotes[_i].get(), _resolver); } else { _o->quotes[_i] = std::unique_ptr<quantra::QuoteSpecT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->quotes.resize(0); } }
  { auto _e = vol_surfaces(); if (_e) { _o->vol_surfaces.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->vol_surfaces[_i]) { _e->Get(_i)->UnPackTo(_o->vol_surfaces[_i].get(), _resolver); } else { _o->vol_surfaces[_i] = std::unique_ptr<quantra::VolSurfaceSpecT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->vol_surfaces.resize(0); } }
  { auto _e = models(); if (_e) { _o->models.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->models[_i]) { _e->Get(_i)->UnPackTo(_o->models[_i].get(), _resolver); } else { _o->models[_i] = std::unique_ptr<quantra::ModelSpecT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->models.resize(0); } }
  { auto _e = bond_pricing_details(); _o->bond_pricing_details = _e; }
  { auto _e = bond_pricing_flows(); _o->bond_pricing_flows = _e; }
  { auto _e = swaption_pricing_details(); _o->swaption_pricing_details = _e; }
  { auto _e = swaption_pricing_rebump(); _o->swaption_pricing_rebump = _e; }
  { auto _e = coupon_pricers(); if (_e) { _o->coupon_pricers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->coupon_pricers[_i]) { _e->Get(_i)->UnPackTo(_o->coupon_pricers[_i].get(), _resolver); } else { _o->coupon_pricers[_i] = std::unique_ptr<quantra::CouponPricerT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->coupon_pricers.resize(0); } }
}

inline ::flatbuffers::Offset<Pricing> Pricing::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PricingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePricing(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Pricing> CreatePricing(::flatbuffers::FlatBufferBuilder &_fbb, const PricingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PricingT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _as_of_date = _fbb.CreateString(_o->as_of_date);
  auto _settlement_date = _o->settlement_date.empty() ? 0 : _fbb.CreateString(_o->settlement_date);
  auto _indices = _o->indices.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::IndexDef>> (_o->indices.size(), [](size_t i, _VectorArgs *__va) { return CreateIndexDef(*__va->__fbb, __va->__o->indices[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _curves = _fbb.CreateVector<::flatbuffers::Offset<quantra::TermStructure>> (_o->curves.size(), [](size_t i, _VectorArgs *__va) { return CreateTermStructure(*__va->__fbb, __va->__o->curves[i].get(), __va->__rehasher); }, &_va );
  auto _credit_curves = _o->credit_curves.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CreditCurveSpec>> (_o->credit_curves.size(), [](size_t i, _VectorArgs *__va) { return CreateCreditCurveSpec(*__va->__fbb, __va->__o->credit_curves[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _quotes = _o->quotes.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::QuoteSpec>> (_o->quotes.size(), [](size_t i, _VectorArgs *__va) { return CreateQuoteSpec(*__va->__fbb, __va->__o->quotes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _vol_surfaces = _o->vol_surfaces.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VolSurfaceSpec>> (_o->vol_surfaces.size(), [](size_t i, _VectorArgs *__va) { return CreateVolSurfaceSpec(*__va->__fbb, __va->__o->vol_surfaces[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _models = _o->models.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::ModelSpec>> (_o->models.size(), [](size_t i, _VectorArgs *__va) { return CreateModelSpec(*__va->__fbb, __va->__o->models[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _bond_pricing_details = _o->bond_pricing_details;
  auto _bond_pricing_flows = _o->bond_pricing_flows;
  auto _swaption_pricing_details = _o->swaption_pricing_details;
  auto _swaption_pricing_rebump = _o->swaption_pricing_rebump;
  auto _coupon_pricers = _o->coupon_pricers.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CouponPricer>> (_o->coupon_pricers.size(), [](size_t i, _VectorArgs *__va) { return CreateCouponPricer(*__va->__fbb, __va->__o->coupon_pricers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return quantra::CreatePricing(
      _fbb,
      _as_of_date,
      _settlement_date,
      _indices,
      _curves,
      _credit_curves,
      _quotes,
      _vol_surfaces,
      _models,
      _bond_pricing_details,
      _bond_pricing_flows,
      _swaption_pricing_details,
      _swaption_pricing_rebump,
      _coupon_pricers);
}

inline ErrorT *Error::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErrorT>(new ErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Error::UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_message(); if (_e) _o->error_message = _e->str(); }
}

inline ::flatbuffers::Offset<Error> Error::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error_message = _o->error_message.empty() ? 0 : _fbb.CreateString(_o->error_message);
  return quantra::CreateError(
      _fbb,
      _error_message);
}

inline FlowInterestT *FlowInterest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowInterestT>(new FlowInterestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowInterest::UnPackTo(FlowInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline ::flatbuffers::Offset<FlowInterest> FlowInterest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowInterest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowInterestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _discount = _o->discount;
  auto _rate = _o->rate;
  auto _price = _o->price;
  return quantra::CreateFlowInterest(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _discount,
      _rate,
      _price);
}

inline FlowInterestFloatT *FlowInterestFloat::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowInterestFloatT>(new FlowInterestFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowInterestFloat::UnPackTo(FlowInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline ::flatbuffers::Offset<FlowInterestFloat> FlowInterestFloat::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowInterestFloat(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowInterestFloatT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _discount = _o->discount;
  auto _rate = _o->rate;
  auto _price = _o->price;
  return quantra::CreateFlowInterestFloat(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _discount,
      _rate,
      _price);
}

inline FlowPastInterestFloatT *FlowPastInterestFloat::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowPastInterestFloatT>(new FlowPastInterestFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowPastInterestFloat::UnPackTo(FlowPastInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = rate(); _o->rate = _e; }
}

inline ::flatbuffers::Offset<FlowPastInterestFloat> FlowPastInterestFloat::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowPastInterestFloat(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowPastInterestFloatT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _rate = _o->rate;
  return quantra::CreateFlowPastInterestFloat(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _rate);
}

inline FlowPastInterestT *FlowPastInterest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowPastInterestT>(new FlowPastInterestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowPastInterest::UnPackTo(FlowPastInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = rate(); _o->rate = _e; }
}

inline ::flatbuffers::Offset<FlowPastInterest> FlowPastInterest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowPastInterest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowPastInterestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _rate = _o->rate;
  return quantra::CreateFlowPastInterest(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _rate);
}

inline FlowNotionalT *FlowNotional::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowNotionalT>(new FlowNotionalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowNotional::UnPackTo(FlowNotionalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = date(); if (_e) _o->date = _e->str(); }
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline ::flatbuffers::Offset<FlowNotional> FlowNotional::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowNotional(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotional(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowNotionalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _date = _o->date.empty() ? 0 : _fbb.CreateString(_o->date);
  auto _amount = _o->amount;
  auto _discount = _o->discount;
  auto _price = _o->price;
  return quantra::CreateFlowNotional(
      _fbb,
      _date,
      _amount,
      _discount,
      _price);
}

inline FlowsWrapperT *FlowsWrapper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowsWrapperT>(new FlowsWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowsWrapper::UnPackTo(FlowsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flow_type(); _o->flow.type = _e; }
  { auto _e = flow(); if (_e) _o->flow.value = quantra::FlowUnion::UnPack(_e, flow_type(), _resolver); }
}

inline ::flatbuffers::Offset<FlowsWrapper> FlowsWrapper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowsWrapper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowsWrapperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flow_type = _o->flow.type;
  auto _flow = _o->flow.Pack(_fbb);
  return quantra::CreateFlowsWrapper(
      _fbb,
      _flow_type,
      _flow);
}

inline bool VerifyFlow(::flatbuffers::Verifier &verifier, const void *obj, Flow type) {
  switch (type) {
    case Flow_NONE: {
      return true;
    }
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotional *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFlowVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFlow(
        verifier,  values->Get(i), types->GetEnum<Flow>(i))) {
      return false;
    }
  }
  return true;
}

inline void *FlowUnion::UnPack(const void *obj, Flow type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotional *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> FlowUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterestT *>(value);
      return CreateFlowInterest(_fbb, ptr, _rehasher).Union();
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterestT *>(value);
      return CreateFlowPastInterest(_fbb, ptr, _rehasher).Union();
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotionalT *>(value);
      return CreateFlowNotional(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline FlowUnion::FlowUnion(const FlowUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Flow_FlowInterest: {
      value = new quantra::FlowInterestT(*reinterpret_cast<quantra::FlowInterestT *>(u.value));
      break;
    }
    case Flow_FlowPastInterest: {
      value = new quantra::FlowPastInterestT(*reinterpret_cast<quantra::FlowPastInterestT *>(u.value));
      break;
    }
    case Flow_FlowNotional: {
      value = new quantra::FlowNotionalT(*reinterpret_cast<quantra::FlowNotionalT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void FlowUnion::Reset() {
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<quantra::FlowInterestT *>(value);
      delete ptr;
      break;
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<quantra::FlowPastInterestT *>(value);
      delete ptr;
      break;
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<quantra::FlowNotionalT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Flow_NONE;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_
