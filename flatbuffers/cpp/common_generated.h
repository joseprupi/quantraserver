// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_
#define FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"

namespace quantra {

struct Period;
struct PeriodBuilder;
struct PeriodT;

struct Yield;
struct YieldBuilder;
struct YieldT;

struct Error;
struct ErrorBuilder;
struct ErrorT;

struct FlowInterest;
struct FlowInterestBuilder;
struct FlowInterestT;

struct FlowInterestFloat;
struct FlowInterestFloatBuilder;
struct FlowInterestFloatT;

struct FlowPastInterestFloat;
struct FlowPastInterestFloatBuilder;
struct FlowPastInterestFloatT;

struct FlowPastInterest;
struct FlowPastInterestBuilder;
struct FlowPastInterestT;

struct FlowNotional;
struct FlowNotionalBuilder;
struct FlowNotionalT;

struct FlowsWrapper;
struct FlowsWrapperBuilder;
struct FlowsWrapperT;

enum Flow : uint8_t {
  Flow_NONE = 0,
  Flow_FlowInterest = 1,
  Flow_FlowPastInterest = 2,
  Flow_FlowNotional = 3,
  Flow_MIN = Flow_NONE,
  Flow_MAX = Flow_FlowNotional
};

inline const Flow (&EnumValuesFlow())[4] {
  static const Flow values[] = {
    Flow_NONE,
    Flow_FlowInterest,
    Flow_FlowPastInterest,
    Flow_FlowNotional
  };
  return values;
}

inline const char * const *EnumNamesFlow() {
  static const char * const names[5] = {
    "NONE",
    "FlowInterest",
    "FlowPastInterest",
    "FlowNotional",
    nullptr
  };
  return names;
}

inline const char *EnumNameFlow(Flow e) {
  if (::flatbuffers::IsOutRange(e, Flow_NONE, Flow_FlowNotional)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFlow()[index];
}

template<typename T> struct FlowTraits {
  static const Flow enum_value = Flow_NONE;
};

template<> struct FlowTraits<quantra::FlowInterest> {
  static const Flow enum_value = Flow_FlowInterest;
};

template<> struct FlowTraits<quantra::FlowPastInterest> {
  static const Flow enum_value = Flow_FlowPastInterest;
};

template<> struct FlowTraits<quantra::FlowNotional> {
  static const Flow enum_value = Flow_FlowNotional;
};

template<typename T> struct FlowUnionTraits {
  static const Flow enum_value = Flow_NONE;
};

template<> struct FlowUnionTraits<quantra::FlowInterestT> {
  static const Flow enum_value = Flow_FlowInterest;
};

template<> struct FlowUnionTraits<quantra::FlowPastInterestT> {
  static const Flow enum_value = Flow_FlowPastInterest;
};

template<> struct FlowUnionTraits<quantra::FlowNotionalT> {
  static const Flow enum_value = Flow_FlowNotional;
};

struct FlowUnion {
  Flow type;
  void *value;

  FlowUnion() : type(Flow_NONE), value(nullptr) {}
  FlowUnion(FlowUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Flow_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  FlowUnion(const FlowUnion &);
  FlowUnion &operator=(const FlowUnion &u)
    { FlowUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  FlowUnion &operator=(FlowUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~FlowUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = FlowUnionTraits<RT>::enum_value;
    if (type != Flow_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Flow type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::FlowInterestT *AsFlowInterest() {
    return type == Flow_FlowInterest ?
      reinterpret_cast<quantra::FlowInterestT *>(value) : nullptr;
  }
  const quantra::FlowInterestT *AsFlowInterest() const {
    return type == Flow_FlowInterest ?
      reinterpret_cast<const quantra::FlowInterestT *>(value) : nullptr;
  }
  quantra::FlowPastInterestT *AsFlowPastInterest() {
    return type == Flow_FlowPastInterest ?
      reinterpret_cast<quantra::FlowPastInterestT *>(value) : nullptr;
  }
  const quantra::FlowPastInterestT *AsFlowPastInterest() const {
    return type == Flow_FlowPastInterest ?
      reinterpret_cast<const quantra::FlowPastInterestT *>(value) : nullptr;
  }
  quantra::FlowNotionalT *AsFlowNotional() {
    return type == Flow_FlowNotional ?
      reinterpret_cast<quantra::FlowNotionalT *>(value) : nullptr;
  }
  const quantra::FlowNotionalT *AsFlowNotional() const {
    return type == Flow_FlowNotional ?
      reinterpret_cast<const quantra::FlowNotionalT *>(value) : nullptr;
  }
};

bool VerifyFlow(::flatbuffers::Verifier &verifier, const void *obj, Flow type);
bool VerifyFlowVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct PeriodT : public ::flatbuffers::NativeTable {
  typedef Period TableType;
  int32_t n = 0;
  quantra::enums::TimeUnit unit = quantra::enums::TimeUnit_Months;
};

struct Period FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PeriodT NativeTableType;
  typedef PeriodBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N = 4,
    VT_UNIT = 6
  };
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  quantra::enums::TimeUnit unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_UNIT, 5));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N, 4) &&
           VerifyField<int8_t>(verifier, VT_UNIT, 1) &&
           verifier.EndTable();
  }
  PeriodT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PeriodT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Period> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PeriodT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PeriodBuilder {
  typedef Period Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Period::VT_N, n, 0);
  }
  void add_unit(quantra::enums::TimeUnit unit) {
    fbb_.AddElement<int8_t>(Period::VT_UNIT, static_cast<int8_t>(unit), 5);
  }
  explicit PeriodBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Period> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Period>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Period> CreatePeriod(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t n = 0,
    quantra::enums::TimeUnit unit = quantra::enums::TimeUnit_Months) {
  PeriodBuilder builder_(_fbb);
  builder_.add_n(n);
  builder_.add_unit(unit);
  return builder_.Finish();
}

::flatbuffers::Offset<Period> CreatePeriod(::flatbuffers::FlatBufferBuilder &_fbb, const PeriodT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct YieldT : public ::flatbuffers::NativeTable {
  typedef Yield TableType;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::Compounding compounding = quantra::enums::Compounding_Compounded;
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
};

struct Yield FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef YieldT NativeTableType;
  typedef YieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DAY_COUNTER = 4,
    VT_COMPOUNDING = 6,
    VT_FREQUENCY = 8
  };
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 0));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING, 1) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           verifier.EndTable();
  }
  YieldT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(YieldT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Yield> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct YieldBuilder {
  typedef Yield Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(Yield::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(Yield::VT_COMPOUNDING, static_cast<int8_t>(compounding), 0);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(Yield::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  explicit YieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Yield> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Yield>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Yield> CreateYield(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Compounded,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual) {
  YieldBuilder builder_(_fbb);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<Yield> CreateYield(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public ::flatbuffers::NativeTable {
  typedef Error TableType;
  std::string error_message{};
};

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorT NativeTableType;
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_MESSAGE = 4
  };
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Error> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(Error::VT_ERROR_MESSAGE, error_message);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return quantra::CreateError(
      _fbb,
      error_message__);
}

::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowInterestT : public ::flatbuffers::NativeTable {
  typedef FlowInterest TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float discount = 0.0f;
  float rate = 0.0f;
  float price = 0.0f;
};

struct FlowInterest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowInterestT NativeTableType;
  typedef FlowInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
  FlowInterestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowInterest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowInterestBuilder {
  typedef FlowInterest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterest::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterest::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterest::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowInterest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

::flatbuffers::Offset<FlowInterest> CreateFlowInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowInterestFloatT : public ::flatbuffers::NativeTable {
  typedef FlowInterestFloat TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float discount = 0.0f;
  float rate = 0.0f;
  float price = 0.0f;
};

struct FlowInterestFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowInterestFloatT NativeTableType;
  typedef FlowInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
  FlowInterestFloatT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowInterestFloat> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowInterestFloatBuilder {
  typedef FlowInterestFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowInterestFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowPastInterestFloatT : public ::flatbuffers::NativeTable {
  typedef FlowPastInterestFloat TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float rate = 0.0f;
};

struct FlowPastInterestFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowPastInterestFloatT NativeTableType;
  typedef FlowPastInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           verifier.EndTable();
  }
  FlowPastInterestFloatT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowPastInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowPastInterestFloat> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowPastInterestFloatBuilder {
  typedef FlowPastInterestFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterestFloat::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowPastInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowPastInterestFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowPastInterestT : public ::flatbuffers::NativeTable {
  typedef FlowPastInterest TableType;
  double amount = 0.0;
  std::string fixing_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  float rate = 0.0f;
};

struct FlowPastInterest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowPastInterestT NativeTableType;
  typedef FlowPastInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           verifier.EndTable();
  }
  FlowPastInterestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowPastInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowPastInterest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowPastInterestBuilder {
  typedef FlowPastInterest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterest::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowPastInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowPastInterest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowNotionalT : public ::flatbuffers::NativeTable {
  typedef FlowNotional TableType;
  std::string date{};
  double amount = 0.0;
  float discount = 0.0f;
  float price = 0.0f;
};

struct FlowNotional FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowNotionalT NativeTableType;
  typedef FlowNotionalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_AMOUNT = 6,
    VT_DISCOUNT = 8,
    VT_PRICE = 10
  };
  const ::flatbuffers::String *date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
  FlowNotionalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowNotionalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowNotional> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FlowNotionalBuilder {
  typedef FlowNotional Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_date(::flatbuffers::Offset<::flatbuffers::String> date) {
    fbb_.AddOffset(FlowNotional::VT_DATE, date);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowNotional::VT_AMOUNT, amount, 0.0);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowNotional::VT_DISCOUNT, discount, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowNotional::VT_PRICE, price, 0.0f);
  }
  explicit FlowNotionalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowNotional> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowNotional>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotional(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> date = 0,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  FlowNotionalBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_discount(discount);
  builder_.add_date(date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotionalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *date = nullptr,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  auto date__ = date ? _fbb.CreateString(date) : 0;
  return quantra::CreateFlowNotional(
      _fbb,
      date__,
      amount,
      discount,
      price);
}

::flatbuffers::Offset<FlowNotional> CreateFlowNotional(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FlowsWrapperT : public ::flatbuffers::NativeTable {
  typedef FlowsWrapper TableType;
  quantra::FlowUnion flow{};
};

struct FlowsWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowsWrapperT NativeTableType;
  typedef FlowsWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOW_TYPE = 4,
    VT_FLOW = 6
  };
  quantra::Flow flow_type() const {
    return static_cast<quantra::Flow>(GetField<uint8_t>(VT_FLOW_TYPE, 0));
  }
  const void *flow() const {
    return GetPointer<const void *>(VT_FLOW);
  }
  template<typename T> const T *flow_as() const;
  const quantra::FlowInterest *flow_as_FlowInterest() const {
    return flow_type() == quantra::Flow_FlowInterest ? static_cast<const quantra::FlowInterest *>(flow()) : nullptr;
  }
  const quantra::FlowPastInterest *flow_as_FlowPastInterest() const {
    return flow_type() == quantra::Flow_FlowPastInterest ? static_cast<const quantra::FlowPastInterest *>(flow()) : nullptr;
  }
  const quantra::FlowNotional *flow_as_FlowNotional() const {
    return flow_type() == quantra::Flow_FlowNotional ? static_cast<const quantra::FlowNotional *>(flow()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLOW_TYPE, 1) &&
           VerifyOffset(verifier, VT_FLOW) &&
           VerifyFlow(verifier, flow(), flow_type()) &&
           verifier.EndTable();
  }
  FlowsWrapperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FlowsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FlowsWrapper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::FlowInterest *FlowsWrapper::flow_as<quantra::FlowInterest>() const {
  return flow_as_FlowInterest();
}

template<> inline const quantra::FlowPastInterest *FlowsWrapper::flow_as<quantra::FlowPastInterest>() const {
  return flow_as_FlowPastInterest();
}

template<> inline const quantra::FlowNotional *FlowsWrapper::flow_as<quantra::FlowNotional>() const {
  return flow_as_FlowNotional();
}

struct FlowsWrapperBuilder {
  typedef FlowsWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flow_type(quantra::Flow flow_type) {
    fbb_.AddElement<uint8_t>(FlowsWrapper::VT_FLOW_TYPE, static_cast<uint8_t>(flow_type), 0);
  }
  void add_flow(::flatbuffers::Offset<void> flow) {
    fbb_.AddOffset(FlowsWrapper::VT_FLOW, flow);
  }
  explicit FlowsWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowsWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowsWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::Flow flow_type = quantra::Flow_NONE,
    ::flatbuffers::Offset<void> flow = 0) {
  FlowsWrapperBuilder builder_(_fbb);
  builder_.add_flow(flow);
  builder_.add_flow_type(flow_type);
  return builder_.Finish();
}

::flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PeriodT *Period::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PeriodT>(new PeriodT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Period::UnPackTo(PeriodT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = n(); _o->n = _e; }
  { auto _e = unit(); _o->unit = _e; }
}

inline ::flatbuffers::Offset<Period> Period::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PeriodT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePeriod(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Period> CreatePeriod(::flatbuffers::FlatBufferBuilder &_fbb, const PeriodT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PeriodT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _n = _o->n;
  auto _unit = _o->unit;
  return quantra::CreatePeriod(
      _fbb,
      _n,
      _unit);
}

inline YieldT *Yield::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<YieldT>(new YieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Yield::UnPackTo(YieldT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = compounding(); _o->compounding = _e; }
  { auto _e = frequency(); _o->frequency = _e; }
}

inline ::flatbuffers::Offset<Yield> Yield::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateYield(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Yield> CreateYield(::flatbuffers::FlatBufferBuilder &_fbb, const YieldT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const YieldT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _day_counter = _o->day_counter;
  auto _compounding = _o->compounding;
  auto _frequency = _o->frequency;
  return quantra::CreateYield(
      _fbb,
      _day_counter,
      _compounding,
      _frequency);
}

inline ErrorT *Error::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ErrorT>(new ErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Error::UnPackTo(ErrorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_message(); if (_e) _o->error_message = _e->str(); }
}

inline ::flatbuffers::Offset<Error> Error::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Error> CreateError(::flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error_message = _o->error_message.empty() ? 0 : _fbb.CreateString(_o->error_message);
  return quantra::CreateError(
      _fbb,
      _error_message);
}

inline FlowInterestT *FlowInterest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowInterestT>(new FlowInterestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowInterest::UnPackTo(FlowInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline ::flatbuffers::Offset<FlowInterest> FlowInterest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowInterest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowInterestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _discount = _o->discount;
  auto _rate = _o->rate;
  auto _price = _o->price;
  return quantra::CreateFlowInterest(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _discount,
      _rate,
      _price);
}

inline FlowInterestFloatT *FlowInterestFloat::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowInterestFloatT>(new FlowInterestFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowInterestFloat::UnPackTo(FlowInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline ::flatbuffers::Offset<FlowInterestFloat> FlowInterestFloat::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowInterestFloat(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowInterestFloatT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _discount = _o->discount;
  auto _rate = _o->rate;
  auto _price = _o->price;
  return quantra::CreateFlowInterestFloat(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _discount,
      _rate,
      _price);
}

inline FlowPastInterestFloatT *FlowPastInterestFloat::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowPastInterestFloatT>(new FlowPastInterestFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowPastInterestFloat::UnPackTo(FlowPastInterestFloatT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = rate(); _o->rate = _e; }
}

inline ::flatbuffers::Offset<FlowPastInterestFloat> FlowPastInterestFloat::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowPastInterestFloat(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestFloatT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowPastInterestFloatT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _rate = _o->rate;
  return quantra::CreateFlowPastInterestFloat(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _rate);
}

inline FlowPastInterestT *FlowPastInterest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowPastInterestT>(new FlowPastInterestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowPastInterest::UnPackTo(FlowPastInterestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = rate(); _o->rate = _e; }
}

inline ::flatbuffers::Offset<FlowPastInterest> FlowPastInterest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowPastInterest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(::flatbuffers::FlatBufferBuilder &_fbb, const FlowPastInterestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowPastInterestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _amount = _o->amount;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _rate = _o->rate;
  return quantra::CreateFlowPastInterest(
      _fbb,
      _amount,
      _fixing_date,
      _accrual_start_date,
      _accrual_end_date,
      _rate);
}

inline FlowNotionalT *FlowNotional::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowNotionalT>(new FlowNotionalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowNotional::UnPackTo(FlowNotionalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = date(); if (_e) _o->date = _e->str(); }
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline ::flatbuffers::Offset<FlowNotional> FlowNotional::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowNotional(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotional(::flatbuffers::FlatBufferBuilder &_fbb, const FlowNotionalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowNotionalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _date = _o->date.empty() ? 0 : _fbb.CreateString(_o->date);
  auto _amount = _o->amount;
  auto _discount = _o->discount;
  auto _price = _o->price;
  return quantra::CreateFlowNotional(
      _fbb,
      _date,
      _amount,
      _discount,
      _price);
}

inline FlowsWrapperT *FlowsWrapper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FlowsWrapperT>(new FlowsWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FlowsWrapper::UnPackTo(FlowsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flow_type(); _o->flow.type = _e; }
  { auto _e = flow(); if (_e) _o->flow.value = quantra::FlowUnion::UnPack(_e, flow_type(), _resolver); }
}

inline ::flatbuffers::Offset<FlowsWrapper> FlowsWrapper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFlowsWrapper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const FlowsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FlowsWrapperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flow_type = _o->flow.type;
  auto _flow = _o->flow.Pack(_fbb);
  return quantra::CreateFlowsWrapper(
      _fbb,
      _flow_type,
      _flow);
}

inline bool VerifyFlow(::flatbuffers::Verifier &verifier, const void *obj, Flow type) {
  switch (type) {
    case Flow_NONE: {
      return true;
    }
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotional *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFlowVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFlow(
        verifier,  values->Get(i), types->GetEnum<Flow>(i))) {
      return false;
    }
  }
  return true;
}

inline void *FlowUnion::UnPack(const void *obj, Flow type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotional *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> FlowUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterestT *>(value);
      return CreateFlowInterest(_fbb, ptr, _rehasher).Union();
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterestT *>(value);
      return CreateFlowPastInterest(_fbb, ptr, _rehasher).Union();
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotionalT *>(value);
      return CreateFlowNotional(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline FlowUnion::FlowUnion(const FlowUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Flow_FlowInterest: {
      value = new quantra::FlowInterestT(*reinterpret_cast<quantra::FlowInterestT *>(u.value));
      break;
    }
    case Flow_FlowPastInterest: {
      value = new quantra::FlowPastInterestT(*reinterpret_cast<quantra::FlowPastInterestT *>(u.value));
      break;
    }
    case Flow_FlowNotional: {
      value = new quantra::FlowNotionalT(*reinterpret_cast<quantra::FlowNotionalT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void FlowUnion::Reset() {
  switch (type) {
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<quantra::FlowInterestT *>(value);
      delete ptr;
      break;
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<quantra::FlowPastInterestT *>(value);
      delete ptr;
      break;
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<quantra::FlowNotionalT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Flow_NONE;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_COMMON_QUANTRA_H_
