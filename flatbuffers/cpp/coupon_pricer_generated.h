// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COUPONPRICER_QUANTRA_H_
#define FLATBUFFERS_GENERATED_COUPONPRICER_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"

namespace quantra {

struct ConstantOptionletVolatility;
struct ConstantOptionletVolatilityBuilder;

struct BlackIborCouponPricer;
struct BlackIborCouponPricerBuilder;

struct CouponPricer;
struct CouponPricerBuilder;

enum OptionletVolatilityStructure : uint8_t {
  OptionletVolatilityStructure_NONE = 0,
  OptionletVolatilityStructure_ConstantOptionletVolatility = 1,
  OptionletVolatilityStructure_MIN = OptionletVolatilityStructure_NONE,
  OptionletVolatilityStructure_MAX = OptionletVolatilityStructure_ConstantOptionletVolatility
};

inline const OptionletVolatilityStructure (&EnumValuesOptionletVolatilityStructure())[2] {
  static const OptionletVolatilityStructure values[] = {
    OptionletVolatilityStructure_NONE,
    OptionletVolatilityStructure_ConstantOptionletVolatility
  };
  return values;
}

inline const char * const *EnumNamesOptionletVolatilityStructure() {
  static const char * const names[3] = {
    "NONE",
    "ConstantOptionletVolatility",
    nullptr
  };
  return names;
}

inline const char *EnumNameOptionletVolatilityStructure(OptionletVolatilityStructure e) {
  if (::flatbuffers::IsOutRange(e, OptionletVolatilityStructure_NONE, OptionletVolatilityStructure_ConstantOptionletVolatility)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptionletVolatilityStructure()[index];
}

template<typename T> struct OptionletVolatilityStructureTraits {
  static const OptionletVolatilityStructure enum_value = OptionletVolatilityStructure_NONE;
};

template<> struct OptionletVolatilityStructureTraits<quantra::ConstantOptionletVolatility> {
  static const OptionletVolatilityStructure enum_value = OptionletVolatilityStructure_ConstantOptionletVolatility;
};

bool VerifyOptionletVolatilityStructure(::flatbuffers::Verifier &verifier, const void *obj, OptionletVolatilityStructure type);
bool VerifyOptionletVolatilityStructureVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Pricer : uint8_t {
  Pricer_NONE = 0,
  Pricer_BlackIborCouponPricer = 1,
  Pricer_MIN = Pricer_NONE,
  Pricer_MAX = Pricer_BlackIborCouponPricer
};

inline const Pricer (&EnumValuesPricer())[2] {
  static const Pricer values[] = {
    Pricer_NONE,
    Pricer_BlackIborCouponPricer
  };
  return values;
}

inline const char * const *EnumNamesPricer() {
  static const char * const names[3] = {
    "NONE",
    "BlackIborCouponPricer",
    nullptr
  };
  return names;
}

inline const char *EnumNamePricer(Pricer e) {
  if (::flatbuffers::IsOutRange(e, Pricer_NONE, Pricer_BlackIborCouponPricer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPricer()[index];
}

template<typename T> struct PricerTraits {
  static const Pricer enum_value = Pricer_NONE;
};

template<> struct PricerTraits<quantra::BlackIborCouponPricer> {
  static const Pricer enum_value = Pricer_BlackIborCouponPricer;
};

bool VerifyPricer(::flatbuffers::Verifier &verifier, const void *obj, Pricer type);
bool VerifyPricerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct ConstantOptionletVolatility FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstantOptionletVolatilityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTLEMENT_DAYS = 4,
    VT_CALENDAR = 6,
    VT_BUSINESS_DAY_CONVENTION = 8,
    VT_VOLATILITY = 10,
    VT_DAY_COUNTER = 12
  };
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  double volatility() const {
    return GetField<double>(VT_VOLATILITY, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<double>(verifier, VT_VOLATILITY, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
};

struct ConstantOptionletVolatilityBuilder {
  typedef ConstantOptionletVolatility Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(ConstantOptionletVolatility::VT_SETTLEMENT_DAYS, settlement_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(ConstantOptionletVolatility::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(ConstantOptionletVolatility::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_volatility(double volatility) {
    fbb_.AddElement<double>(ConstantOptionletVolatility::VT_VOLATILITY, volatility, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(ConstantOptionletVolatility::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit ConstantOptionletVolatilityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstantOptionletVolatility> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstantOptionletVolatility>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstantOptionletVolatility> CreateConstantOptionletVolatility(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t settlement_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double volatility = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  ConstantOptionletVolatilityBuilder builder_(_fbb);
  builder_.add_volatility(volatility);
  builder_.add_settlement_days(settlement_days);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

struct BlackIborCouponPricer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlackIborCouponPricerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE = 4,
    VT_OPTIONLET_VOLATILITY_STRUCTURE = 6
  };
  quantra::OptionletVolatilityStructure optionlet_volatility_structure_type() const {
    return static_cast<quantra::OptionletVolatilityStructure>(GetField<uint8_t>(VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE, 0));
  }
  const void *optionlet_volatility_structure() const {
    return GetPointer<const void *>(VT_OPTIONLET_VOLATILITY_STRUCTURE);
  }
  template<typename T> const T *optionlet_volatility_structure_as() const;
  const quantra::ConstantOptionletVolatility *optionlet_volatility_structure_as_ConstantOptionletVolatility() const {
    return optionlet_volatility_structure_type() == quantra::OptionletVolatilityStructure_ConstantOptionletVolatility ? static_cast<const quantra::ConstantOptionletVolatility *>(optionlet_volatility_structure()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE, 1) &&
           VerifyOffset(verifier, VT_OPTIONLET_VOLATILITY_STRUCTURE) &&
           VerifyOptionletVolatilityStructure(verifier, optionlet_volatility_structure(), optionlet_volatility_structure_type()) &&
           verifier.EndTable();
  }
};

template<> inline const quantra::ConstantOptionletVolatility *BlackIborCouponPricer::optionlet_volatility_structure_as<quantra::ConstantOptionletVolatility>() const {
  return optionlet_volatility_structure_as_ConstantOptionletVolatility();
}

struct BlackIborCouponPricerBuilder {
  typedef BlackIborCouponPricer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_optionlet_volatility_structure_type(quantra::OptionletVolatilityStructure optionlet_volatility_structure_type) {
    fbb_.AddElement<uint8_t>(BlackIborCouponPricer::VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE, static_cast<uint8_t>(optionlet_volatility_structure_type), 0);
  }
  void add_optionlet_volatility_structure(::flatbuffers::Offset<void> optionlet_volatility_structure) {
    fbb_.AddOffset(BlackIborCouponPricer::VT_OPTIONLET_VOLATILITY_STRUCTURE, optionlet_volatility_structure);
  }
  explicit BlackIborCouponPricerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlackIborCouponPricer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlackIborCouponPricer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlackIborCouponPricer> CreateBlackIborCouponPricer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::OptionletVolatilityStructure optionlet_volatility_structure_type = quantra::OptionletVolatilityStructure_NONE,
    ::flatbuffers::Offset<void> optionlet_volatility_structure = 0) {
  BlackIborCouponPricerBuilder builder_(_fbb);
  builder_.add_optionlet_volatility_structure(optionlet_volatility_structure);
  builder_.add_optionlet_volatility_structure_type(optionlet_volatility_structure_type);
  return builder_.Finish();
}

struct CouponPricer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CouponPricerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PRICER_TYPE = 6,
    VT_PRICER = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::Pricer pricer_type() const {
    return static_cast<quantra::Pricer>(GetField<uint8_t>(VT_PRICER_TYPE, 0));
  }
  const void *pricer() const {
    return GetPointer<const void *>(VT_PRICER);
  }
  template<typename T> const T *pricer_as() const;
  const quantra::BlackIborCouponPricer *pricer_as_BlackIborCouponPricer() const {
    return pricer_type() == quantra::Pricer_BlackIborCouponPricer ? static_cast<const quantra::BlackIborCouponPricer *>(pricer()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_PRICER_TYPE, 1) &&
           VerifyOffset(verifier, VT_PRICER) &&
           VerifyPricer(verifier, pricer(), pricer_type()) &&
           verifier.EndTable();
  }
};

template<> inline const quantra::BlackIborCouponPricer *CouponPricer::pricer_as<quantra::BlackIborCouponPricer>() const {
  return pricer_as_BlackIborCouponPricer();
}

struct CouponPricerBuilder {
  typedef CouponPricer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CouponPricer::VT_ID, id);
  }
  void add_pricer_type(quantra::Pricer pricer_type) {
    fbb_.AddElement<uint8_t>(CouponPricer::VT_PRICER_TYPE, static_cast<uint8_t>(pricer_type), 0);
  }
  void add_pricer(::flatbuffers::Offset<void> pricer) {
    fbb_.AddOffset(CouponPricer::VT_PRICER, pricer);
  }
  explicit CouponPricerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CouponPricer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CouponPricer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CouponPricer> CreateCouponPricer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::Pricer pricer_type = quantra::Pricer_NONE,
    ::flatbuffers::Offset<void> pricer = 0) {
  CouponPricerBuilder builder_(_fbb);
  builder_.add_pricer(pricer);
  builder_.add_id(id);
  builder_.add_pricer_type(pricer_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CouponPricer> CreateCouponPricerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::Pricer pricer_type = quantra::Pricer_NONE,
    ::flatbuffers::Offset<void> pricer = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return quantra::CreateCouponPricer(
      _fbb,
      id__,
      pricer_type,
      pricer);
}

inline bool VerifyOptionletVolatilityStructure(::flatbuffers::Verifier &verifier, const void *obj, OptionletVolatilityStructure type) {
  switch (type) {
    case OptionletVolatilityStructure_NONE: {
      return true;
    }
    case OptionletVolatilityStructure_ConstantOptionletVolatility: {
      auto ptr = reinterpret_cast<const quantra::ConstantOptionletVolatility *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOptionletVolatilityStructureVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOptionletVolatilityStructure(
        verifier,  values->Get(i), types->GetEnum<OptionletVolatilityStructure>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPricer(::flatbuffers::Verifier &verifier, const void *obj, Pricer type) {
  switch (type) {
    case Pricer_NONE: {
      return true;
    }
    case Pricer_BlackIborCouponPricer: {
      auto ptr = reinterpret_cast<const quantra::BlackIborCouponPricer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPricerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPricer(
        verifier,  values->Get(i), types->GetEnum<Pricer>(i))) {
      return false;
    }
  }
  return true;
}

inline const quantra::CouponPricer *GetCouponPricer(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::CouponPricer>(buf);
}

inline const quantra::CouponPricer *GetSizePrefixedCouponPricer(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::CouponPricer>(buf);
}

inline bool VerifyCouponPricerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::CouponPricer>(nullptr);
}

inline bool VerifySizePrefixedCouponPricerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::CouponPricer>(nullptr);
}

inline void FinishCouponPricerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::CouponPricer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCouponPricerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::CouponPricer> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_COUPONPRICER_QUANTRA_H_
