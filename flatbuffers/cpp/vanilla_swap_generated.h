// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VANILLASWAP_QUANTRA_H_
#define FLATBUFFERS_GENERATED_VANILLASWAP_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"
#include "index_generated.h"
#include "schedule_generated.h"

namespace quantra {

struct SwapFixedLeg;
struct SwapFixedLegBuilder;
struct SwapFixedLegT;

struct SwapFloatingLeg;
struct SwapFloatingLegBuilder;
struct SwapFloatingLegT;

struct VanillaSwap;
struct VanillaSwapBuilder;
struct VanillaSwapT;

struct SwapFixedLegT : public ::flatbuffers::NativeTable {
  typedef SwapFixedLeg TableType;
  std::unique_ptr<quantra::ScheduleT> schedule{};
  double notional = 0.0;
  double rate = 0.0;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::BusinessDayConvention payment_convention = quantra::enums::BusinessDayConvention_Following;
  SwapFixedLegT() = default;
  SwapFixedLegT(const SwapFixedLegT &o);
  SwapFixedLegT(SwapFixedLegT&&) FLATBUFFERS_NOEXCEPT = default;
  SwapFixedLegT &operator=(SwapFixedLegT o) FLATBUFFERS_NOEXCEPT;
};

struct SwapFixedLeg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapFixedLegT NativeTableType;
  typedef SwapFixedLegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEDULE = 4,
    VT_NOTIONAL = 6,
    VT_RATE = 8,
    VT_DAY_COUNTER = 10,
    VT_PAYMENT_CONVENTION = 12
  };
  const quantra::Schedule *schedule() const {
    return GetPointer<const quantra::Schedule *>(VT_SCHEDULE);
  }
  double notional() const {
    return GetField<double>(VT_NOTIONAL, 0.0);
  }
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::BusinessDayConvention payment_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_PAYMENT_CONVENTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.VerifyTable(schedule()) &&
           VerifyField<double>(verifier, VT_NOTIONAL, 8) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_PAYMENT_CONVENTION, 1) &&
           verifier.EndTable();
  }
  SwapFixedLegT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapFixedLegT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapFixedLeg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFixedLegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapFixedLegBuilder {
  typedef SwapFixedLeg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_schedule(::flatbuffers::Offset<quantra::Schedule> schedule) {
    fbb_.AddOffset(SwapFixedLeg::VT_SCHEDULE, schedule);
  }
  void add_notional(double notional) {
    fbb_.AddElement<double>(SwapFixedLeg::VT_NOTIONAL, notional, 0.0);
  }
  void add_rate(double rate) {
    fbb_.AddElement<double>(SwapFixedLeg::VT_RATE, rate, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(SwapFixedLeg::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_payment_convention(quantra::enums::BusinessDayConvention payment_convention) {
    fbb_.AddElement<int8_t>(SwapFixedLeg::VT_PAYMENT_CONVENTION, static_cast<int8_t>(payment_convention), 0);
  }
  explicit SwapFixedLegBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapFixedLeg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapFixedLeg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapFixedLeg> CreateSwapFixedLeg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double notional = 0.0,
    double rate = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention payment_convention = quantra::enums::BusinessDayConvention_Following) {
  SwapFixedLegBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_notional(notional);
  builder_.add_schedule(schedule);
  builder_.add_payment_convention(payment_convention);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<SwapFixedLeg> CreateSwapFixedLeg(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFixedLegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwapFloatingLegT : public ::flatbuffers::NativeTable {
  typedef SwapFloatingLeg TableType;
  std::unique_ptr<quantra::ScheduleT> schedule{};
  double notional = 0.0;
  std::unique_ptr<quantra::IndexRefT> index{};
  double spread = 0.0;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::BusinessDayConvention payment_convention = quantra::enums::BusinessDayConvention_Following;
  int32_t fixing_days = 2;
  bool in_arrears = false;
  SwapFloatingLegT() = default;
  SwapFloatingLegT(const SwapFloatingLegT &o);
  SwapFloatingLegT(SwapFloatingLegT&&) FLATBUFFERS_NOEXCEPT = default;
  SwapFloatingLegT &operator=(SwapFloatingLegT o) FLATBUFFERS_NOEXCEPT;
};

struct SwapFloatingLeg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapFloatingLegT NativeTableType;
  typedef SwapFloatingLegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEDULE = 4,
    VT_NOTIONAL = 6,
    VT_INDEX = 8,
    VT_SPREAD = 10,
    VT_DAY_COUNTER = 12,
    VT_PAYMENT_CONVENTION = 14,
    VT_FIXING_DAYS = 16,
    VT_IN_ARREARS = 18
  };
  const quantra::Schedule *schedule() const {
    return GetPointer<const quantra::Schedule *>(VT_SCHEDULE);
  }
  double notional() const {
    return GetField<double>(VT_NOTIONAL, 0.0);
  }
  /// Reference to an IndexDef by id (e.g., "EUR_6M")
  const quantra::IndexRef *index() const {
    return GetPointer<const quantra::IndexRef *>(VT_INDEX);
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::BusinessDayConvention payment_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_PAYMENT_CONVENTION, 0));
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 2);
  }
  bool in_arrears() const {
    return GetField<uint8_t>(VT_IN_ARREARS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.VerifyTable(schedule()) &&
           VerifyField<double>(verifier, VT_NOTIONAL, 8) &&
           VerifyOffsetRequired(verifier, VT_INDEX) &&
           verifier.VerifyTable(index()) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_PAYMENT_CONVENTION, 1) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<uint8_t>(verifier, VT_IN_ARREARS, 1) &&
           verifier.EndTable();
  }
  SwapFloatingLegT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapFloatingLegT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapFloatingLeg> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFloatingLegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapFloatingLegBuilder {
  typedef SwapFloatingLeg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_schedule(::flatbuffers::Offset<quantra::Schedule> schedule) {
    fbb_.AddOffset(SwapFloatingLeg::VT_SCHEDULE, schedule);
  }
  void add_notional(double notional) {
    fbb_.AddElement<double>(SwapFloatingLeg::VT_NOTIONAL, notional, 0.0);
  }
  void add_index(::flatbuffers::Offset<quantra::IndexRef> index) {
    fbb_.AddOffset(SwapFloatingLeg::VT_INDEX, index);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(SwapFloatingLeg::VT_SPREAD, spread, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(SwapFloatingLeg::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_payment_convention(quantra::enums::BusinessDayConvention payment_convention) {
    fbb_.AddElement<int8_t>(SwapFloatingLeg::VT_PAYMENT_CONVENTION, static_cast<int8_t>(payment_convention), 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(SwapFloatingLeg::VT_FIXING_DAYS, fixing_days, 2);
  }
  void add_in_arrears(bool in_arrears) {
    fbb_.AddElement<uint8_t>(SwapFloatingLeg::VT_IN_ARREARS, static_cast<uint8_t>(in_arrears), 0);
  }
  explicit SwapFloatingLegBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapFloatingLeg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapFloatingLeg>(end);
    fbb_.Required(o, SwapFloatingLeg::VT_INDEX);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapFloatingLeg> CreateSwapFloatingLeg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double notional = 0.0,
    ::flatbuffers::Offset<quantra::IndexRef> index = 0,
    double spread = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention payment_convention = quantra::enums::BusinessDayConvention_Following,
    int32_t fixing_days = 2,
    bool in_arrears = false) {
  SwapFloatingLegBuilder builder_(_fbb);
  builder_.add_spread(spread);
  builder_.add_notional(notional);
  builder_.add_fixing_days(fixing_days);
  builder_.add_index(index);
  builder_.add_schedule(schedule);
  builder_.add_in_arrears(in_arrears);
  builder_.add_payment_convention(payment_convention);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<SwapFloatingLeg> CreateSwapFloatingLeg(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFloatingLegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VanillaSwapT : public ::flatbuffers::NativeTable {
  typedef VanillaSwap TableType;
  quantra::enums::SwapType swap_type = quantra::enums::SwapType_Payer;
  std::unique_ptr<quantra::SwapFixedLegT> fixed_leg{};
  std::unique_ptr<quantra::SwapFloatingLegT> floating_leg{};
  VanillaSwapT() = default;
  VanillaSwapT(const VanillaSwapT &o);
  VanillaSwapT(VanillaSwapT&&) FLATBUFFERS_NOEXCEPT = default;
  VanillaSwapT &operator=(VanillaSwapT o) FLATBUFFERS_NOEXCEPT;
};

struct VanillaSwap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VanillaSwapT NativeTableType;
  typedef VanillaSwapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SWAP_TYPE = 4,
    VT_FIXED_LEG = 6,
    VT_FLOATING_LEG = 8
  };
  quantra::enums::SwapType swap_type() const {
    return static_cast<quantra::enums::SwapType>(GetField<int8_t>(VT_SWAP_TYPE, 0));
  }
  const quantra::SwapFixedLeg *fixed_leg() const {
    return GetPointer<const quantra::SwapFixedLeg *>(VT_FIXED_LEG);
  }
  const quantra::SwapFloatingLeg *floating_leg() const {
    return GetPointer<const quantra::SwapFloatingLeg *>(VT_FLOATING_LEG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SWAP_TYPE, 1) &&
           VerifyOffset(verifier, VT_FIXED_LEG) &&
           verifier.VerifyTable(fixed_leg()) &&
           VerifyOffset(verifier, VT_FLOATING_LEG) &&
           verifier.VerifyTable(floating_leg()) &&
           verifier.EndTable();
  }
  VanillaSwapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VanillaSwapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VanillaSwap> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VanillaSwapBuilder {
  typedef VanillaSwap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_swap_type(quantra::enums::SwapType swap_type) {
    fbb_.AddElement<int8_t>(VanillaSwap::VT_SWAP_TYPE, static_cast<int8_t>(swap_type), 0);
  }
  void add_fixed_leg(::flatbuffers::Offset<quantra::SwapFixedLeg> fixed_leg) {
    fbb_.AddOffset(VanillaSwap::VT_FIXED_LEG, fixed_leg);
  }
  void add_floating_leg(::flatbuffers::Offset<quantra::SwapFloatingLeg> floating_leg) {
    fbb_.AddOffset(VanillaSwap::VT_FLOATING_LEG, floating_leg);
  }
  explicit VanillaSwapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VanillaSwap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VanillaSwap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VanillaSwap> CreateVanillaSwap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::SwapType swap_type = quantra::enums::SwapType_Payer,
    ::flatbuffers::Offset<quantra::SwapFixedLeg> fixed_leg = 0,
    ::flatbuffers::Offset<quantra::SwapFloatingLeg> floating_leg = 0) {
  VanillaSwapBuilder builder_(_fbb);
  builder_.add_floating_leg(floating_leg);
  builder_.add_fixed_leg(fixed_leg);
  builder_.add_swap_type(swap_type);
  return builder_.Finish();
}

::flatbuffers::Offset<VanillaSwap> CreateVanillaSwap(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SwapFixedLegT::SwapFixedLegT(const SwapFixedLegT &o)
      : schedule((o.schedule) ? new quantra::ScheduleT(*o.schedule) : nullptr),
        notional(o.notional),
        rate(o.rate),
        day_counter(o.day_counter),
        payment_convention(o.payment_convention) {
}

inline SwapFixedLegT &SwapFixedLegT::operator=(SwapFixedLegT o) FLATBUFFERS_NOEXCEPT {
  std::swap(schedule, o.schedule);
  std::swap(notional, o.notional);
  std::swap(rate, o.rate);
  std::swap(day_counter, o.day_counter);
  std::swap(payment_convention, o.payment_convention);
  return *this;
}

inline SwapFixedLegT *SwapFixedLeg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapFixedLegT>(new SwapFixedLegT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapFixedLeg::UnPackTo(SwapFixedLegT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = schedule(); if (_e) { if(_o->schedule) { _e->UnPackTo(_o->schedule.get(), _resolver); } else { _o->schedule = std::unique_ptr<quantra::ScheduleT>(_e->UnPack(_resolver)); } } else if (_o->schedule) { _o->schedule.reset(); } }
  { auto _e = notional(); _o->notional = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = payment_convention(); _o->payment_convention = _e; }
}

inline ::flatbuffers::Offset<SwapFixedLeg> SwapFixedLeg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFixedLegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapFixedLeg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapFixedLeg> CreateSwapFixedLeg(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFixedLegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapFixedLegT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _schedule = _o->schedule ? CreateSchedule(_fbb, _o->schedule.get(), _rehasher) : 0;
  auto _notional = _o->notional;
  auto _rate = _o->rate;
  auto _day_counter = _o->day_counter;
  auto _payment_convention = _o->payment_convention;
  return quantra::CreateSwapFixedLeg(
      _fbb,
      _schedule,
      _notional,
      _rate,
      _day_counter,
      _payment_convention);
}

inline SwapFloatingLegT::SwapFloatingLegT(const SwapFloatingLegT &o)
      : schedule((o.schedule) ? new quantra::ScheduleT(*o.schedule) : nullptr),
        notional(o.notional),
        index((o.index) ? new quantra::IndexRefT(*o.index) : nullptr),
        spread(o.spread),
        day_counter(o.day_counter),
        payment_convention(o.payment_convention),
        fixing_days(o.fixing_days),
        in_arrears(o.in_arrears) {
}

inline SwapFloatingLegT &SwapFloatingLegT::operator=(SwapFloatingLegT o) FLATBUFFERS_NOEXCEPT {
  std::swap(schedule, o.schedule);
  std::swap(notional, o.notional);
  std::swap(index, o.index);
  std::swap(spread, o.spread);
  std::swap(day_counter, o.day_counter);
  std::swap(payment_convention, o.payment_convention);
  std::swap(fixing_days, o.fixing_days);
  std::swap(in_arrears, o.in_arrears);
  return *this;
}

inline SwapFloatingLegT *SwapFloatingLeg::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapFloatingLegT>(new SwapFloatingLegT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapFloatingLeg::UnPackTo(SwapFloatingLegT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = schedule(); if (_e) { if(_o->schedule) { _e->UnPackTo(_o->schedule.get(), _resolver); } else { _o->schedule = std::unique_ptr<quantra::ScheduleT>(_e->UnPack(_resolver)); } } else if (_o->schedule) { _o->schedule.reset(); } }
  { auto _e = notional(); _o->notional = _e; }
  { auto _e = index(); if (_e) { if(_o->index) { _e->UnPackTo(_o->index.get(), _resolver); } else { _o->index = std::unique_ptr<quantra::IndexRefT>(_e->UnPack(_resolver)); } } else if (_o->index) { _o->index.reset(); } }
  { auto _e = spread(); _o->spread = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = payment_convention(); _o->payment_convention = _e; }
  { auto _e = fixing_days(); _o->fixing_days = _e; }
  { auto _e = in_arrears(); _o->in_arrears = _e; }
}

inline ::flatbuffers::Offset<SwapFloatingLeg> SwapFloatingLeg::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFloatingLegT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapFloatingLeg(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapFloatingLeg> CreateSwapFloatingLeg(::flatbuffers::FlatBufferBuilder &_fbb, const SwapFloatingLegT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapFloatingLegT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _schedule = _o->schedule ? CreateSchedule(_fbb, _o->schedule.get(), _rehasher) : 0;
  auto _notional = _o->notional;
  auto _index = _o->index ? CreateIndexRef(_fbb, _o->index.get(), _rehasher) : 0;
  auto _spread = _o->spread;
  auto _day_counter = _o->day_counter;
  auto _payment_convention = _o->payment_convention;
  auto _fixing_days = _o->fixing_days;
  auto _in_arrears = _o->in_arrears;
  return quantra::CreateSwapFloatingLeg(
      _fbb,
      _schedule,
      _notional,
      _index,
      _spread,
      _day_counter,
      _payment_convention,
      _fixing_days,
      _in_arrears);
}

inline VanillaSwapT::VanillaSwapT(const VanillaSwapT &o)
      : swap_type(o.swap_type),
        fixed_leg((o.fixed_leg) ? new quantra::SwapFixedLegT(*o.fixed_leg) : nullptr),
        floating_leg((o.floating_leg) ? new quantra::SwapFloatingLegT(*o.floating_leg) : nullptr) {
}

inline VanillaSwapT &VanillaSwapT::operator=(VanillaSwapT o) FLATBUFFERS_NOEXCEPT {
  std::swap(swap_type, o.swap_type);
  std::swap(fixed_leg, o.fixed_leg);
  std::swap(floating_leg, o.floating_leg);
  return *this;
}

inline VanillaSwapT *VanillaSwap::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VanillaSwapT>(new VanillaSwapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VanillaSwap::UnPackTo(VanillaSwapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = swap_type(); _o->swap_type = _e; }
  { auto _e = fixed_leg(); if (_e) { if(_o->fixed_leg) { _e->UnPackTo(_o->fixed_leg.get(), _resolver); } else { _o->fixed_leg = std::unique_ptr<quantra::SwapFixedLegT>(_e->UnPack(_resolver)); } } else if (_o->fixed_leg) { _o->fixed_leg.reset(); } }
  { auto _e = floating_leg(); if (_e) { if(_o->floating_leg) { _e->UnPackTo(_o->floating_leg.get(), _resolver); } else { _o->floating_leg = std::unique_ptr<quantra::SwapFloatingLegT>(_e->UnPack(_resolver)); } } else if (_o->floating_leg) { _o->floating_leg.reset(); } }
}

inline ::flatbuffers::Offset<VanillaSwap> VanillaSwap::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVanillaSwap(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VanillaSwap> CreateVanillaSwap(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VanillaSwapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _swap_type = _o->swap_type;
  auto _fixed_leg = _o->fixed_leg ? CreateSwapFixedLeg(_fbb, _o->fixed_leg.get(), _rehasher) : 0;
  auto _floating_leg = _o->floating_leg ? CreateSwapFloatingLeg(_fbb, _o->floating_leg.get(), _rehasher) : 0;
  return quantra::CreateVanillaSwap(
      _fbb,
      _swap_type,
      _fixed_leg,
      _floating_leg);
}

inline const quantra::VanillaSwap *GetVanillaSwap(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::VanillaSwap>(buf);
}

inline const quantra::VanillaSwap *GetSizePrefixedVanillaSwap(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::VanillaSwap>(buf);
}

inline bool VerifyVanillaSwapBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::VanillaSwap>(nullptr);
}

inline bool VerifySizePrefixedVanillaSwapBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::VanillaSwap>(nullptr);
}

inline void FinishVanillaSwapBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::VanillaSwap> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedVanillaSwapBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::VanillaSwap> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<quantra::VanillaSwapT> UnPackVanillaSwap(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::VanillaSwapT>(GetVanillaSwap(buf)->UnPack(res));
}

inline std::unique_ptr<quantra::VanillaSwapT> UnPackSizePrefixedVanillaSwap(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::VanillaSwapT>(GetSizePrefixedVanillaSwap(buf)->UnPack(res));
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_VANILLASWAP_QUANTRA_H_
