// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BOOTSTRAPCURVESRESPONSE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_BOOTSTRAPCURVESRESPONSE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "bootstrap_curves_request_generated.h"
#include "common_generated.h"

namespace quantra {

struct CurveSeries;
struct CurveSeriesBuilder;
struct CurveSeriesT;

struct BootstrapCurveResult;
struct BootstrapCurveResultBuilder;
struct BootstrapCurveResultT;

struct BootstrapCurvesResponse;
struct BootstrapCurvesResponseBuilder;
struct BootstrapCurvesResponseT;

struct CurveSeriesT : public ::flatbuffers::NativeTable {
  typedef CurveSeries TableType;
  quantra::CurveMeasure measure = quantra::CurveMeasure_DF;
  std::vector<double> values{};
};

/// One series aligned to grid_dates.
struct CurveSeries FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurveSeriesT NativeTableType;
  typedef CurveSeriesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEASURE = 4,
    VT_VALUES = 6
  };
  /// Which measure this series represents.
  quantra::CurveMeasure measure() const {
    return static_cast<quantra::CurveMeasure>(GetField<int8_t>(VT_MEASURE, 0));
  }
  /// Values aligned to grid_dates (same length).
  const ::flatbuffers::Vector<double> *values() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MEASURE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  CurveSeriesT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CurveSeriesT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CurveSeries> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveSeriesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CurveSeriesBuilder {
  typedef CurveSeries Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_measure(quantra::CurveMeasure measure) {
    fbb_.AddElement<int8_t>(CurveSeries::VT_MEASURE, static_cast<int8_t>(measure), 0);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<double>> values) {
    fbb_.AddOffset(CurveSeries::VT_VALUES, values);
  }
  explicit CurveSeriesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CurveSeries> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CurveSeries>(end);
    fbb_.Required(o, CurveSeries::VT_VALUES);
    return o;
  }
};

inline ::flatbuffers::Offset<CurveSeries> CreateCurveSeries(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::CurveMeasure measure = quantra::CurveMeasure_DF,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> values = 0) {
  CurveSeriesBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_measure(measure);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CurveSeries> CreateCurveSeriesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::CurveMeasure measure = quantra::CurveMeasure_DF,
    const std::vector<double> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<double>(*values) : 0;
  return quantra::CreateCurveSeries(
      _fbb,
      measure,
      values__);
}

::flatbuffers::Offset<CurveSeries> CreateCurveSeries(::flatbuffers::FlatBufferBuilder &_fbb, const CurveSeriesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BootstrapCurveResultT : public ::flatbuffers::NativeTable {
  typedef BootstrapCurveResult TableType;
  std::string id{};
  std::string reference_date{};
  std::vector<std::string> grid_dates{};
  std::vector<std::unique_ptr<quantra::CurveSeriesT>> series{};
  std::vector<std::string> pillar_dates{};
  std::unique_ptr<quantra::ErrorT> error{};
  BootstrapCurveResultT() = default;
  BootstrapCurveResultT(const BootstrapCurveResultT &o);
  BootstrapCurveResultT(BootstrapCurveResultT&&) FLATBUFFERS_NOEXCEPT = default;
  BootstrapCurveResultT &operator=(BootstrapCurveResultT o) FLATBUFFERS_NOEXCEPT;
};

/// Result for a single curve.
struct BootstrapCurveResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BootstrapCurveResultT NativeTableType;
  typedef BootstrapCurveResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_REFERENCE_DATE = 6,
    VT_GRID_DATES = 8,
    VT_SERIES = 10,
    VT_PILLAR_DATES = 12,
    VT_ERROR = 14
  };
  /// Curve id (copied from TermStructure.id).
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Reference date actually used (YYYY-MM-DD).
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  /// The realized grid (dates) used for sampling (YYYY-MM-DD).
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *grid_dates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_GRID_DATES);
  }
  /// Series returned, each aligned to grid_dates.
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CurveSeries>> *series() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CurveSeries>> *>(VT_SERIES);
  }
  /// Bootstrapped pillar dates from the curve instruments (YYYY-MM-DD).
  /// Useful for debugging to see where the curve "nodes" are.
  /// May be empty if pillar extraction is not supported for the curve type.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *pillar_dates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PILLAR_DATES);
  }
  /// Error if this curve failed (null if ok).
  const quantra::Error *error() const {
    return GetPointer<const quantra::Error *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           VerifyOffset(verifier, VT_GRID_DATES) &&
           verifier.VerifyVector(grid_dates()) &&
           verifier.VerifyVectorOfStrings(grid_dates()) &&
           VerifyOffset(verifier, VT_SERIES) &&
           verifier.VerifyVector(series()) &&
           verifier.VerifyVectorOfTables(series()) &&
           VerifyOffset(verifier, VT_PILLAR_DATES) &&
           verifier.VerifyVector(pillar_dates()) &&
           verifier.VerifyVectorOfStrings(pillar_dates()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  BootstrapCurveResultT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BootstrapCurveResultT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BootstrapCurveResult> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BootstrapCurveResultBuilder {
  typedef BootstrapCurveResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(BootstrapCurveResult::VT_ID, id);
  }
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(BootstrapCurveResult::VT_REFERENCE_DATE, reference_date);
  }
  void add_grid_dates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> grid_dates) {
    fbb_.AddOffset(BootstrapCurveResult::VT_GRID_DATES, grid_dates);
  }
  void add_series(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CurveSeries>>> series) {
    fbb_.AddOffset(BootstrapCurveResult::VT_SERIES, series);
  }
  void add_pillar_dates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> pillar_dates) {
    fbb_.AddOffset(BootstrapCurveResult::VT_PILLAR_DATES, pillar_dates);
  }
  void add_error(::flatbuffers::Offset<quantra::Error> error) {
    fbb_.AddOffset(BootstrapCurveResult::VT_ERROR, error);
  }
  explicit BootstrapCurveResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BootstrapCurveResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BootstrapCurveResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BootstrapCurveResult> CreateBootstrapCurveResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> grid_dates = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CurveSeries>>> series = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> pillar_dates = 0,
    ::flatbuffers::Offset<quantra::Error> error = 0) {
  BootstrapCurveResultBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_pillar_dates(pillar_dates);
  builder_.add_series(series);
  builder_.add_grid_dates(grid_dates);
  builder_.add_reference_date(reference_date);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BootstrapCurveResult> CreateBootstrapCurveResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *reference_date = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *grid_dates = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::CurveSeries>> *series = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *pillar_dates = nullptr,
    ::flatbuffers::Offset<quantra::Error> error = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  auto grid_dates__ = grid_dates ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*grid_dates) : 0;
  auto series__ = series ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CurveSeries>>(*series) : 0;
  auto pillar_dates__ = pillar_dates ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*pillar_dates) : 0;
  return quantra::CreateBootstrapCurveResult(
      _fbb,
      id__,
      reference_date__,
      grid_dates__,
      series__,
      pillar_dates__,
      error);
}

::flatbuffers::Offset<BootstrapCurveResult> CreateBootstrapCurveResult(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BootstrapCurvesResponseT : public ::flatbuffers::NativeTable {
  typedef BootstrapCurvesResponse TableType;
  std::vector<std::unique_ptr<quantra::BootstrapCurveResultT>> results{};
  BootstrapCurvesResponseT() = default;
  BootstrapCurvesResponseT(const BootstrapCurvesResponseT &o);
  BootstrapCurvesResponseT(BootstrapCurvesResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  BootstrapCurvesResponseT &operator=(BootstrapCurvesResponseT o) FLATBUFFERS_NOEXCEPT;
};

/// Response containing results for all requested curves.
struct BootstrapCurvesResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BootstrapCurvesResponseT NativeTableType;
  typedef BootstrapCurvesResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveResult>> *results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveResult>> *>(VT_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.VerifyVectorOfTables(results()) &&
           verifier.EndTable();
  }
  BootstrapCurvesResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BootstrapCurvesResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BootstrapCurvesResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BootstrapCurvesResponseBuilder {
  typedef BootstrapCurvesResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveResult>>> results) {
    fbb_.AddOffset(BootstrapCurvesResponse::VT_RESULTS, results);
  }
  explicit BootstrapCurvesResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BootstrapCurvesResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BootstrapCurvesResponse>(end);
    fbb_.Required(o, BootstrapCurvesResponse::VT_RESULTS);
    return o;
  }
};

inline ::flatbuffers::Offset<BootstrapCurvesResponse> CreateBootstrapCurvesResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveResult>>> results = 0) {
  BootstrapCurvesResponseBuilder builder_(_fbb);
  builder_.add_results(results);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BootstrapCurvesResponse> CreateBootstrapCurvesResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::BootstrapCurveResult>> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<::flatbuffers::Offset<quantra::BootstrapCurveResult>>(*results) : 0;
  return quantra::CreateBootstrapCurvesResponse(
      _fbb,
      results__);
}

::flatbuffers::Offset<BootstrapCurvesResponse> CreateBootstrapCurvesResponse(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CurveSeriesT *CurveSeries::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CurveSeriesT>(new CurveSeriesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CurveSeries::UnPackTo(CurveSeriesT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = measure(); _o->measure = _e; }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->values[_i] = _e->Get(_i); } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<CurveSeries> CurveSeries::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveSeriesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCurveSeries(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CurveSeries> CreateCurveSeries(::flatbuffers::FlatBufferBuilder &_fbb, const CurveSeriesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CurveSeriesT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _measure = _o->measure;
  auto _values = _fbb.CreateVector(_o->values);
  return quantra::CreateCurveSeries(
      _fbb,
      _measure,
      _values);
}

inline BootstrapCurveResultT::BootstrapCurveResultT(const BootstrapCurveResultT &o)
      : id(o.id),
        reference_date(o.reference_date),
        grid_dates(o.grid_dates),
        pillar_dates(o.pillar_dates),
        error((o.error) ? new quantra::ErrorT(*o.error) : nullptr) {
  series.reserve(o.series.size());
  for (const auto &series_ : o.series) { series.emplace_back((series_) ? new quantra::CurveSeriesT(*series_) : nullptr); }
}

inline BootstrapCurveResultT &BootstrapCurveResultT::operator=(BootstrapCurveResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(reference_date, o.reference_date);
  std::swap(grid_dates, o.grid_dates);
  std::swap(series, o.series);
  std::swap(pillar_dates, o.pillar_dates);
  std::swap(error, o.error);
  return *this;
}

inline BootstrapCurveResultT *BootstrapCurveResult::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BootstrapCurveResultT>(new BootstrapCurveResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BootstrapCurveResult::UnPackTo(BootstrapCurveResultT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = reference_date(); if (_e) _o->reference_date = _e->str(); }
  { auto _e = grid_dates(); if (_e) { _o->grid_dates.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->grid_dates[_i] = _e->Get(_i)->str(); } } else { _o->grid_dates.resize(0); } }
  { auto _e = series(); if (_e) { _o->series.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->series[_i]) { _e->Get(_i)->UnPackTo(_o->series[_i].get(), _resolver); } else { _o->series[_i] = std::unique_ptr<quantra::CurveSeriesT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->series.resize(0); } }
  { auto _e = pillar_dates(); if (_e) { _o->pillar_dates.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pillar_dates[_i] = _e->Get(_i)->str(); } } else { _o->pillar_dates.resize(0); } }
  { auto _e = error(); if (_e) { if(_o->error) { _e->UnPackTo(_o->error.get(), _resolver); } else { _o->error = std::unique_ptr<quantra::ErrorT>(_e->UnPack(_resolver)); } } else if (_o->error) { _o->error.reset(); } }
}

inline ::flatbuffers::Offset<BootstrapCurveResult> BootstrapCurveResult::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveResultT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBootstrapCurveResult(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BootstrapCurveResult> CreateBootstrapCurveResult(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveResultT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BootstrapCurveResultT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _reference_date = _o->reference_date.empty() ? 0 : _fbb.CreateString(_o->reference_date);
  auto _grid_dates = _o->grid_dates.size() ? _fbb.CreateVectorOfStrings(_o->grid_dates) : 0;
  auto _series = _o->series.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CurveSeries>> (_o->series.size(), [](size_t i, _VectorArgs *__va) { return CreateCurveSeries(*__va->__fbb, __va->__o->series[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _pillar_dates = _o->pillar_dates.size() ? _fbb.CreateVectorOfStrings(_o->pillar_dates) : 0;
  auto _error = _o->error ? CreateError(_fbb, _o->error.get(), _rehasher) : 0;
  return quantra::CreateBootstrapCurveResult(
      _fbb,
      _id,
      _reference_date,
      _grid_dates,
      _series,
      _pillar_dates,
      _error);
}

inline BootstrapCurvesResponseT::BootstrapCurvesResponseT(const BootstrapCurvesResponseT &o) {
  results.reserve(o.results.size());
  for (const auto &results_ : o.results) { results.emplace_back((results_) ? new quantra::BootstrapCurveResultT(*results_) : nullptr); }
}

inline BootstrapCurvesResponseT &BootstrapCurvesResponseT::operator=(BootstrapCurvesResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(results, o.results);
  return *this;
}

inline BootstrapCurvesResponseT *BootstrapCurvesResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BootstrapCurvesResponseT>(new BootstrapCurvesResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BootstrapCurvesResponse::UnPackTo(BootstrapCurvesResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = results(); if (_e) { _o->results.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->results[_i]) { _e->Get(_i)->UnPackTo(_o->results[_i].get(), _resolver); } else { _o->results[_i] = std::unique_ptr<quantra::BootstrapCurveResultT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->results.resize(0); } }
}

inline ::flatbuffers::Offset<BootstrapCurvesResponse> BootstrapCurvesResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBootstrapCurvesResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BootstrapCurvesResponse> CreateBootstrapCurvesResponse(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BootstrapCurvesResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _results = _fbb.CreateVector<::flatbuffers::Offset<quantra::BootstrapCurveResult>> (_o->results.size(), [](size_t i, _VectorArgs *__va) { return CreateBootstrapCurveResult(*__va->__fbb, __va->__o->results[i].get(), __va->__rehasher); }, &_va );
  return quantra::CreateBootstrapCurvesResponse(
      _fbb,
      _results);
}

inline const quantra::BootstrapCurvesResponse *GetBootstrapCurvesResponse(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::BootstrapCurvesResponse>(buf);
}

inline const quantra::BootstrapCurvesResponse *GetSizePrefixedBootstrapCurvesResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::BootstrapCurvesResponse>(buf);
}

inline bool VerifyBootstrapCurvesResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::BootstrapCurvesResponse>(nullptr);
}

inline bool VerifySizePrefixedBootstrapCurvesResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::BootstrapCurvesResponse>(nullptr);
}

inline void FinishBootstrapCurvesResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::BootstrapCurvesResponse> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBootstrapCurvesResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::BootstrapCurvesResponse> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<quantra::BootstrapCurvesResponseT> UnPackBootstrapCurvesResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::BootstrapCurvesResponseT>(GetBootstrapCurvesResponse(buf)->UnPack(res));
}

inline std::unique_ptr<quantra::BootstrapCurvesResponseT> UnPackSizePrefixedBootstrapCurvesResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::BootstrapCurvesResponseT>(GetSizePrefixedBootstrapCurvesResponse(buf)->UnPack(res));
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_BOOTSTRAPCURVESRESPONSE_QUANTRA_H_
