// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"
#include "schedule_generated.h"

namespace quantra {

struct DepositHelper;
struct DepositHelperBuilder;
struct DepositHelperT;

struct FRAHelper;
struct FRAHelperBuilder;
struct FRAHelperT;

struct FutureHelper;
struct FutureHelperBuilder;
struct FutureHelperT;

struct SwapHelper;
struct SwapHelperBuilder;
struct SwapHelperT;

struct BondHelper;
struct BondHelperBuilder;
struct BondHelperT;

struct PointsWrapper;
struct PointsWrapperBuilder;
struct PointsWrapperT;

struct TermStructure;
struct TermStructureBuilder;
struct TermStructureT;

enum Point : uint8_t {
  Point_NONE = 0,
  Point_DepositHelper = 1,
  Point_FRAHelper = 2,
  Point_FutureHelper = 3,
  Point_SwapHelper = 4,
  Point_BondHelper = 5,
  Point_MIN = Point_NONE,
  Point_MAX = Point_BondHelper
};

inline const Point (&EnumValuesPoint())[6] {
  static const Point values[] = {
    Point_NONE,
    Point_DepositHelper,
    Point_FRAHelper,
    Point_FutureHelper,
    Point_SwapHelper,
    Point_BondHelper
  };
  return values;
}

inline const char * const *EnumNamesPoint() {
  static const char * const names[7] = {
    "NONE",
    "DepositHelper",
    "FRAHelper",
    "FutureHelper",
    "SwapHelper",
    "BondHelper",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoint(Point e) {
  if (::flatbuffers::IsOutRange(e, Point_NONE, Point_BondHelper)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoint()[index];
}

template<typename T> struct PointTraits {
  static const Point enum_value = Point_NONE;
};

template<> struct PointTraits<quantra::DepositHelper> {
  static const Point enum_value = Point_DepositHelper;
};

template<> struct PointTraits<quantra::FRAHelper> {
  static const Point enum_value = Point_FRAHelper;
};

template<> struct PointTraits<quantra::FutureHelper> {
  static const Point enum_value = Point_FutureHelper;
};

template<> struct PointTraits<quantra::SwapHelper> {
  static const Point enum_value = Point_SwapHelper;
};

template<> struct PointTraits<quantra::BondHelper> {
  static const Point enum_value = Point_BondHelper;
};

template<typename T> struct PointUnionTraits {
  static const Point enum_value = Point_NONE;
};

template<> struct PointUnionTraits<quantra::DepositHelperT> {
  static const Point enum_value = Point_DepositHelper;
};

template<> struct PointUnionTraits<quantra::FRAHelperT> {
  static const Point enum_value = Point_FRAHelper;
};

template<> struct PointUnionTraits<quantra::FutureHelperT> {
  static const Point enum_value = Point_FutureHelper;
};

template<> struct PointUnionTraits<quantra::SwapHelperT> {
  static const Point enum_value = Point_SwapHelper;
};

template<> struct PointUnionTraits<quantra::BondHelperT> {
  static const Point enum_value = Point_BondHelper;
};

struct PointUnion {
  Point type;
  void *value;

  PointUnion() : type(Point_NONE), value(nullptr) {}
  PointUnion(PointUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Point_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PointUnion(const PointUnion &);
  PointUnion &operator=(const PointUnion &u)
    { PointUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PointUnion &operator=(PointUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PointUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = PointUnionTraits<RT>::enum_value;
    if (type != Point_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Point type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::DepositHelperT *AsDepositHelper() {
    return type == Point_DepositHelper ?
      reinterpret_cast<quantra::DepositHelperT *>(value) : nullptr;
  }
  const quantra::DepositHelperT *AsDepositHelper() const {
    return type == Point_DepositHelper ?
      reinterpret_cast<const quantra::DepositHelperT *>(value) : nullptr;
  }
  quantra::FRAHelperT *AsFRAHelper() {
    return type == Point_FRAHelper ?
      reinterpret_cast<quantra::FRAHelperT *>(value) : nullptr;
  }
  const quantra::FRAHelperT *AsFRAHelper() const {
    return type == Point_FRAHelper ?
      reinterpret_cast<const quantra::FRAHelperT *>(value) : nullptr;
  }
  quantra::FutureHelperT *AsFutureHelper() {
    return type == Point_FutureHelper ?
      reinterpret_cast<quantra::FutureHelperT *>(value) : nullptr;
  }
  const quantra::FutureHelperT *AsFutureHelper() const {
    return type == Point_FutureHelper ?
      reinterpret_cast<const quantra::FutureHelperT *>(value) : nullptr;
  }
  quantra::SwapHelperT *AsSwapHelper() {
    return type == Point_SwapHelper ?
      reinterpret_cast<quantra::SwapHelperT *>(value) : nullptr;
  }
  const quantra::SwapHelperT *AsSwapHelper() const {
    return type == Point_SwapHelper ?
      reinterpret_cast<const quantra::SwapHelperT *>(value) : nullptr;
  }
  quantra::BondHelperT *AsBondHelper() {
    return type == Point_BondHelper ?
      reinterpret_cast<quantra::BondHelperT *>(value) : nullptr;
  }
  const quantra::BondHelperT *AsBondHelper() const {
    return type == Point_BondHelper ?
      reinterpret_cast<const quantra::BondHelperT *>(value) : nullptr;
  }
};

bool VerifyPoint(::flatbuffers::Verifier &verifier, const void *obj, Point type);
bool VerifyPointVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct DepositHelperT : public ::flatbuffers::NativeTable {
  typedef DepositHelper TableType;
  double rate = 0.0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  int32_t tenor_number = 0;
  int32_t fixing_days = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
};

struct DepositHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepositHelperT NativeTableType;
  typedef DepositHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
  DepositHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepositHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DepositHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepositHelperBuilder {
  typedef DepositHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(DepositHelper::VT_RATE, rate, 0.0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(DepositHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(DepositHelper::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit DepositHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepositHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepositHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepositHelper> CreateDepositHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  DepositHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_fixing_days(fixing_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

::flatbuffers::Offset<DepositHelper> CreateDepositHelper(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FRAHelperT : public ::flatbuffers::NativeTable {
  typedef FRAHelper TableType;
  double rate = 0.0;
  int32_t months_to_start = 0;
  int32_t months_to_end = 0;
  int32_t fixing_days = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
};

struct FRAHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FRAHelperT NativeTableType;
  typedef FRAHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_MONTHS_TO_START = 6,
    VT_MONTHS_TO_END = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  int32_t months_to_start() const {
    return GetField<int32_t>(VT_MONTHS_TO_START, 0);
  }
  int32_t months_to_end() const {
    return GetField<int32_t>(VT_MONTHS_TO_END, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_START, 4) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_END, 4) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
  FRAHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FRAHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FRAHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FRAHelperBuilder {
  typedef FRAHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(FRAHelper::VT_RATE, rate, 0.0);
  }
  void add_months_to_start(int32_t months_to_start) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_MONTHS_TO_START, months_to_start, 0);
  }
  void add_months_to_end(int32_t months_to_end) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_MONTHS_TO_END, months_to_end, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit FRAHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FRAHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FRAHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FRAHelper> CreateFRAHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t months_to_start = 0,
    int32_t months_to_end = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  FRAHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_fixing_days(fixing_days);
  builder_.add_months_to_end(months_to_end);
  builder_.add_months_to_start(months_to_start);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

::flatbuffers::Offset<FRAHelper> CreateFRAHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FutureHelperT : public ::flatbuffers::NativeTable {
  typedef FutureHelper TableType;
  double rate = 0.0;
  std::string future_start_date{};
  int32_t future_months = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
};

struct FutureHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FutureHelperT NativeTableType;
  typedef FutureHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_FUTURE_START_DATE = 6,
    VT_FUTURE_MONTHS = 8,
    VT_CALENDAR = 10,
    VT_BUSINESS_DAY_CONVENTION = 12,
    VT_DAY_COUNTER = 14
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  const ::flatbuffers::String *future_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUTURE_START_DATE);
  }
  int32_t future_months() const {
    return GetField<int32_t>(VT_FUTURE_MONTHS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyOffset(verifier, VT_FUTURE_START_DATE) &&
           verifier.VerifyString(future_start_date()) &&
           VerifyField<int32_t>(verifier, VT_FUTURE_MONTHS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
  FutureHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FutureHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FutureHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FutureHelperBuilder {
  typedef FutureHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(FutureHelper::VT_RATE, rate, 0.0);
  }
  void add_future_start_date(::flatbuffers::Offset<::flatbuffers::String> future_start_date) {
    fbb_.AddOffset(FutureHelper::VT_FUTURE_START_DATE, future_start_date);
  }
  void add_future_months(int32_t future_months) {
    fbb_.AddElement<int32_t>(FutureHelper::VT_FUTURE_MONTHS, future_months, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit FutureHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FutureHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FutureHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> future_start_date = 0,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  FutureHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_future_months(future_months);
  builder_.add_future_start_date(future_start_date);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    const char *future_start_date = nullptr,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  auto future_start_date__ = future_start_date ? _fbb.CreateString(future_start_date) : 0;
  return quantra::CreateFutureHelper(
      _fbb,
      rate,
      future_start_date__,
      future_months,
      calendar,
      business_day_convention,
      day_counter);
}

::flatbuffers::Offset<FutureHelper> CreateFutureHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwapHelperT : public ::flatbuffers::NativeTable {
  typedef SwapHelper TableType;
  double rate = 0.0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  int32_t tenor_number = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::Frequency sw_fixed_leg_frequency = quantra::enums::Frequency_Annual;
  quantra::enums::BusinessDayConvention sw_fixed_leg_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter sw_fixed_leg_day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::Ibor sw_floating_leg_index = quantra::enums::Ibor_Euribor10M;
  double spread = 0.0;
  int32_t fwd_start_days = 0;
};

struct SwapHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapHelperT NativeTableType;
  typedef SwapHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_CALENDAR = 10,
    VT_SW_FIXED_LEG_FREQUENCY = 12,
    VT_SW_FIXED_LEG_CONVENTION = 14,
    VT_SW_FIXED_LEG_DAY_COUNTER = 16,
    VT_SW_FLOATING_LEG_INDEX = 18,
    VT_SPREAD = 20,
    VT_FWD_START_DAYS = 22
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::Frequency sw_fixed_leg_frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_SW_FIXED_LEG_FREQUENCY, 0));
  }
  quantra::enums::BusinessDayConvention sw_fixed_leg_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_SW_FIXED_LEG_CONVENTION, 0));
  }
  quantra::enums::DayCounter sw_fixed_leg_day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_SW_FIXED_LEG_DAY_COUNTER, 0));
  }
  quantra::enums::Ibor sw_floating_leg_index() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_SW_FLOATING_LEG_INDEX, 0));
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  int32_t fwd_start_days() const {
    return GetField<int32_t>(VT_FWD_START_DAYS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FLOATING_LEG_INDEX, 1) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<int32_t>(verifier, VT_FWD_START_DAYS, 4) &&
           verifier.EndTable();
  }
  SwapHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapHelperBuilder {
  typedef SwapHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(SwapHelper::VT_RATE, rate, 0.0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(SwapHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_sw_fixed_leg_frequency(quantra::enums::Frequency sw_fixed_leg_frequency) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_FREQUENCY, static_cast<int8_t>(sw_fixed_leg_frequency), 0);
  }
  void add_sw_fixed_leg_convention(quantra::enums::BusinessDayConvention sw_fixed_leg_convention) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_CONVENTION, static_cast<int8_t>(sw_fixed_leg_convention), 0);
  }
  void add_sw_fixed_leg_day_counter(quantra::enums::DayCounter sw_fixed_leg_day_counter) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_DAY_COUNTER, static_cast<int8_t>(sw_fixed_leg_day_counter), 0);
  }
  void add_sw_floating_leg_index(quantra::enums::Ibor sw_floating_leg_index) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FLOATING_LEG_INDEX, static_cast<int8_t>(sw_floating_leg_index), 0);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(SwapHelper::VT_SPREAD, spread, 0.0);
  }
  void add_fwd_start_days(int32_t fwd_start_days) {
    fbb_.AddElement<int32_t>(SwapHelper::VT_FWD_START_DAYS, fwd_start_days, 0);
  }
  explicit SwapHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapHelper> CreateSwapHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::Frequency sw_fixed_leg_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention sw_fixed_leg_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter sw_fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Ibor sw_floating_leg_index = quantra::enums::Ibor_Euribor10M,
    double spread = 0.0,
    int32_t fwd_start_days = 0) {
  SwapHelperBuilder builder_(_fbb);
  builder_.add_spread(spread);
  builder_.add_rate(rate);
  builder_.add_fwd_start_days(fwd_start_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_sw_floating_leg_index(sw_floating_leg_index);
  builder_.add_sw_fixed_leg_day_counter(sw_fixed_leg_day_counter);
  builder_.add_sw_fixed_leg_convention(sw_fixed_leg_convention);
  builder_.add_sw_fixed_leg_frequency(sw_fixed_leg_frequency);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

::flatbuffers::Offset<SwapHelper> CreateSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BondHelperT : public ::flatbuffers::NativeTable {
  typedef BondHelper TableType;
  double rate = 0.0;
  int32_t settlement_days = 0;
  double face_amount = 0.0;
  std::unique_ptr<quantra::ScheduleT> schedule{};
  double coupon_rate = 0.0;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  double redemption = 0.0;
  std::string issue_date{};
  BondHelperT() = default;
  BondHelperT(const BondHelperT &o);
  BondHelperT(BondHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  BondHelperT &operator=(BondHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct BondHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BondHelperT NativeTableType;
  typedef BondHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_SETTLEMENT_DAYS = 6,
    VT_FACE_AMOUNT = 8,
    VT_SCHEDULE = 10,
    VT_COUPON_RATE = 12,
    VT_DAY_COUNTER = 14,
    VT_BUSINESS_DAY_CONVENTION = 16,
    VT_REDEMPTION = 18,
    VT_ISSUE_DATE = 20
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 0);
  }
  double face_amount() const {
    return GetField<double>(VT_FACE_AMOUNT, 0.0);
  }
  const quantra::Schedule *schedule() const {
    return GetPointer<const quantra::Schedule *>(VT_SCHEDULE);
  }
  double coupon_rate() const {
    return GetField<double>(VT_COUPON_RATE, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  double redemption() const {
    return GetField<double>(VT_REDEMPTION, 0.0);
  }
  const ::flatbuffers::String *issue_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ISSUE_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<double>(verifier, VT_FACE_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.VerifyTable(schedule()) &&
           VerifyField<double>(verifier, VT_COUPON_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<double>(verifier, VT_REDEMPTION, 8) &&
           VerifyOffset(verifier, VT_ISSUE_DATE) &&
           verifier.VerifyString(issue_date()) &&
           verifier.EndTable();
  }
  BondHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BondHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BondHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BondHelperBuilder {
  typedef BondHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(BondHelper::VT_RATE, rate, 0.0);
  }
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(BondHelper::VT_SETTLEMENT_DAYS, settlement_days, 0);
  }
  void add_face_amount(double face_amount) {
    fbb_.AddElement<double>(BondHelper::VT_FACE_AMOUNT, face_amount, 0.0);
  }
  void add_schedule(::flatbuffers::Offset<quantra::Schedule> schedule) {
    fbb_.AddOffset(BondHelper::VT_SCHEDULE, schedule);
  }
  void add_coupon_rate(double coupon_rate) {
    fbb_.AddElement<double>(BondHelper::VT_COUPON_RATE, coupon_rate, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(BondHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(BondHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_redemption(double redemption) {
    fbb_.AddElement<double>(BondHelper::VT_REDEMPTION, redemption, 0.0);
  }
  void add_issue_date(::flatbuffers::Offset<::flatbuffers::String> issue_date) {
    fbb_.AddOffset(BondHelper::VT_ISSUE_DATE, issue_date);
  }
  explicit BondHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BondHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BondHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BondHelper> CreateBondHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t settlement_days = 0,
    double face_amount = 0.0,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double coupon_rate = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double redemption = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> issue_date = 0) {
  BondHelperBuilder builder_(_fbb);
  builder_.add_redemption(redemption);
  builder_.add_coupon_rate(coupon_rate);
  builder_.add_face_amount(face_amount);
  builder_.add_rate(rate);
  builder_.add_issue_date(issue_date);
  builder_.add_schedule(schedule);
  builder_.add_settlement_days(settlement_days);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BondHelper> CreateBondHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t settlement_days = 0,
    double face_amount = 0.0,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double coupon_rate = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double redemption = 0.0,
    const char *issue_date = nullptr) {
  auto issue_date__ = issue_date ? _fbb.CreateString(issue_date) : 0;
  return quantra::CreateBondHelper(
      _fbb,
      rate,
      settlement_days,
      face_amount,
      schedule,
      coupon_rate,
      day_counter,
      business_day_convention,
      redemption,
      issue_date__);
}

::flatbuffers::Offset<BondHelper> CreateBondHelper(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointsWrapperT : public ::flatbuffers::NativeTable {
  typedef PointsWrapper TableType;
  quantra::PointUnion point{};
};

struct PointsWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointsWrapperT NativeTableType;
  typedef PointsWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINT_TYPE = 4,
    VT_POINT = 6
  };
  quantra::Point point_type() const {
    return static_cast<quantra::Point>(GetField<uint8_t>(VT_POINT_TYPE, 0));
  }
  const void *point() const {
    return GetPointer<const void *>(VT_POINT);
  }
  template<typename T> const T *point_as() const;
  const quantra::DepositHelper *point_as_DepositHelper() const {
    return point_type() == quantra::Point_DepositHelper ? static_cast<const quantra::DepositHelper *>(point()) : nullptr;
  }
  const quantra::FRAHelper *point_as_FRAHelper() const {
    return point_type() == quantra::Point_FRAHelper ? static_cast<const quantra::FRAHelper *>(point()) : nullptr;
  }
  const quantra::FutureHelper *point_as_FutureHelper() const {
    return point_type() == quantra::Point_FutureHelper ? static_cast<const quantra::FutureHelper *>(point()) : nullptr;
  }
  const quantra::SwapHelper *point_as_SwapHelper() const {
    return point_type() == quantra::Point_SwapHelper ? static_cast<const quantra::SwapHelper *>(point()) : nullptr;
  }
  const quantra::BondHelper *point_as_BondHelper() const {
    return point_type() == quantra::Point_BondHelper ? static_cast<const quantra::BondHelper *>(point()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POINT_TYPE, 1) &&
           VerifyOffset(verifier, VT_POINT) &&
           VerifyPoint(verifier, point(), point_type()) &&
           verifier.EndTable();
  }
  PointsWrapperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PointsWrapper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::DepositHelper *PointsWrapper::point_as<quantra::DepositHelper>() const {
  return point_as_DepositHelper();
}

template<> inline const quantra::FRAHelper *PointsWrapper::point_as<quantra::FRAHelper>() const {
  return point_as_FRAHelper();
}

template<> inline const quantra::FutureHelper *PointsWrapper::point_as<quantra::FutureHelper>() const {
  return point_as_FutureHelper();
}

template<> inline const quantra::SwapHelper *PointsWrapper::point_as<quantra::SwapHelper>() const {
  return point_as_SwapHelper();
}

template<> inline const quantra::BondHelper *PointsWrapper::point_as<quantra::BondHelper>() const {
  return point_as_BondHelper();
}

struct PointsWrapperBuilder {
  typedef PointsWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_point_type(quantra::Point point_type) {
    fbb_.AddElement<uint8_t>(PointsWrapper::VT_POINT_TYPE, static_cast<uint8_t>(point_type), 0);
  }
  void add_point(::flatbuffers::Offset<void> point) {
    fbb_.AddOffset(PointsWrapper::VT_POINT, point);
  }
  explicit PointsWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointsWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointsWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointsWrapper> CreatePointsWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::Point point_type = quantra::Point_NONE,
    ::flatbuffers::Offset<void> point = 0) {
  PointsWrapperBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_point_type(point_type);
  return builder_.Finish();
}

::flatbuffers::Offset<PointsWrapper> CreatePointsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TermStructureT : public ::flatbuffers::NativeTable {
  typedef TermStructure TableType;
  std::string id{};
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat;
  quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount;
  std::vector<std::unique_ptr<quantra::PointsWrapperT>> points{};
  std::string reference_date{};
  TermStructureT() = default;
  TermStructureT(const TermStructureT &o);
  TermStructureT(TermStructureT&&) FLATBUFFERS_NOEXCEPT = default;
  TermStructureT &operator=(TermStructureT o) FLATBUFFERS_NOEXCEPT;
};

struct TermStructure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TermStructureT NativeTableType;
  typedef TermStructureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DAY_COUNTER = 6,
    VT_INTERPOLATOR = 8,
    VT_BOOTSTRAP_TRAIT = 10,
    VT_POINTS = 12,
    VT_REFERENCE_DATE = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Interpolator interpolator() const {
    return static_cast<quantra::enums::Interpolator>(GetField<int8_t>(VT_INTERPOLATOR, 0));
  }
  quantra::enums::BootstrapTrait bootstrap_trait() const {
    return static_cast<quantra::enums::BootstrapTrait>(GetField<int8_t>(VT_BOOTSTRAP_TRAIT, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>> *>(VT_POINTS);
  }
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_INTERPOLATOR, 1) &&
           VerifyField<int8_t>(verifier, VT_BOOTSTRAP_TRAIT, 1) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           verifier.EndTable();
  }
  TermStructureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TermStructureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TermStructure> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TermStructureBuilder {
  typedef TermStructure Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TermStructure::VT_ID, id);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(TermStructure::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_interpolator(quantra::enums::Interpolator interpolator) {
    fbb_.AddElement<int8_t>(TermStructure::VT_INTERPOLATOR, static_cast<int8_t>(interpolator), 0);
  }
  void add_bootstrap_trait(quantra::enums::BootstrapTrait bootstrap_trait) {
    fbb_.AddElement<int8_t>(TermStructure::VT_BOOTSTRAP_TRAIT, static_cast<int8_t>(bootstrap_trait), 0);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>>> points) {
    fbb_.AddOffset(TermStructure::VT_POINTS, points);
  }
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(TermStructure::VT_REFERENCE_DATE, reference_date);
  }
  explicit TermStructureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TermStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TermStructure>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TermStructure> CreateTermStructure(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0) {
  TermStructureBuilder builder_(_fbb);
  builder_.add_reference_date(reference_date);
  builder_.add_points(points);
  builder_.add_id(id);
  builder_.add_bootstrap_trait(bootstrap_trait);
  builder_.add_interpolator(interpolator);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TermStructure> CreateTermStructureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    const std::vector<::flatbuffers::Offset<quantra::PointsWrapper>> *points = nullptr,
    const char *reference_date = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<quantra::PointsWrapper>>(*points) : 0;
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  return quantra::CreateTermStructure(
      _fbb,
      id__,
      day_counter,
      interpolator,
      bootstrap_trait,
      points__,
      reference_date__);
}

::flatbuffers::Offset<TermStructure> CreateTermStructure(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline DepositHelperT *DepositHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepositHelperT>(new DepositHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepositHelper::UnPackTo(DepositHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = fixing_days(); _o->fixing_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
}

inline ::flatbuffers::Offset<DepositHelper> DepositHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepositHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DepositHelper> CreateDepositHelper(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DepositHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _tenor_number = _o->tenor_number;
  auto _fixing_days = _o->fixing_days;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  return quantra::CreateDepositHelper(
      _fbb,
      _rate,
      _tenor_time_unit,
      _tenor_number,
      _fixing_days,
      _calendar,
      _business_day_convention,
      _day_counter);
}

inline FRAHelperT *FRAHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FRAHelperT>(new FRAHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FRAHelper::UnPackTo(FRAHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = months_to_start(); _o->months_to_start = _e; }
  { auto _e = months_to_end(); _o->months_to_end = _e; }
  { auto _e = fixing_days(); _o->fixing_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
}

inline ::flatbuffers::Offset<FRAHelper> FRAHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFRAHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FRAHelper> CreateFRAHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FRAHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _months_to_start = _o->months_to_start;
  auto _months_to_end = _o->months_to_end;
  auto _fixing_days = _o->fixing_days;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  return quantra::CreateFRAHelper(
      _fbb,
      _rate,
      _months_to_start,
      _months_to_end,
      _fixing_days,
      _calendar,
      _business_day_convention,
      _day_counter);
}

inline FutureHelperT *FutureHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FutureHelperT>(new FutureHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FutureHelper::UnPackTo(FutureHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = future_start_date(); if (_e) _o->future_start_date = _e->str(); }
  { auto _e = future_months(); _o->future_months = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
}

inline ::flatbuffers::Offset<FutureHelper> FutureHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFutureHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FutureHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _future_start_date = _o->future_start_date.empty() ? 0 : _fbb.CreateString(_o->future_start_date);
  auto _future_months = _o->future_months;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  return quantra::CreateFutureHelper(
      _fbb,
      _rate,
      _future_start_date,
      _future_months,
      _calendar,
      _business_day_convention,
      _day_counter);
}

inline SwapHelperT *SwapHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapHelperT>(new SwapHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapHelper::UnPackTo(SwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = sw_fixed_leg_frequency(); _o->sw_fixed_leg_frequency = _e; }
  { auto _e = sw_fixed_leg_convention(); _o->sw_fixed_leg_convention = _e; }
  { auto _e = sw_fixed_leg_day_counter(); _o->sw_fixed_leg_day_counter = _e; }
  { auto _e = sw_floating_leg_index(); _o->sw_floating_leg_index = _e; }
  { auto _e = spread(); _o->spread = _e; }
  { auto _e = fwd_start_days(); _o->fwd_start_days = _e; }
}

inline ::flatbuffers::Offset<SwapHelper> SwapHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapHelper> CreateSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _tenor_number = _o->tenor_number;
  auto _calendar = _o->calendar;
  auto _sw_fixed_leg_frequency = _o->sw_fixed_leg_frequency;
  auto _sw_fixed_leg_convention = _o->sw_fixed_leg_convention;
  auto _sw_fixed_leg_day_counter = _o->sw_fixed_leg_day_counter;
  auto _sw_floating_leg_index = _o->sw_floating_leg_index;
  auto _spread = _o->spread;
  auto _fwd_start_days = _o->fwd_start_days;
  return quantra::CreateSwapHelper(
      _fbb,
      _rate,
      _tenor_time_unit,
      _tenor_number,
      _calendar,
      _sw_fixed_leg_frequency,
      _sw_fixed_leg_convention,
      _sw_fixed_leg_day_counter,
      _sw_floating_leg_index,
      _spread,
      _fwd_start_days);
}

inline BondHelperT::BondHelperT(const BondHelperT &o)
      : rate(o.rate),
        settlement_days(o.settlement_days),
        face_amount(o.face_amount),
        schedule((o.schedule) ? new quantra::ScheduleT(*o.schedule) : nullptr),
        coupon_rate(o.coupon_rate),
        day_counter(o.day_counter),
        business_day_convention(o.business_day_convention),
        redemption(o.redemption),
        issue_date(o.issue_date) {
}

inline BondHelperT &BondHelperT::operator=(BondHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(rate, o.rate);
  std::swap(settlement_days, o.settlement_days);
  std::swap(face_amount, o.face_amount);
  std::swap(schedule, o.schedule);
  std::swap(coupon_rate, o.coupon_rate);
  std::swap(day_counter, o.day_counter);
  std::swap(business_day_convention, o.business_day_convention);
  std::swap(redemption, o.redemption);
  std::swap(issue_date, o.issue_date);
  return *this;
}

inline BondHelperT *BondHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BondHelperT>(new BondHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BondHelper::UnPackTo(BondHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = settlement_days(); _o->settlement_days = _e; }
  { auto _e = face_amount(); _o->face_amount = _e; }
  { auto _e = schedule(); if (_e) { if(_o->schedule) { _e->UnPackTo(_o->schedule.get(), _resolver); } else { _o->schedule = std::unique_ptr<quantra::ScheduleT>(_e->UnPack(_resolver)); } } else if (_o->schedule) { _o->schedule.reset(); } }
  { auto _e = coupon_rate(); _o->coupon_rate = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = redemption(); _o->redemption = _e; }
  { auto _e = issue_date(); if (_e) _o->issue_date = _e->str(); }
}

inline ::flatbuffers::Offset<BondHelper> BondHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBondHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BondHelper> CreateBondHelper(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BondHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _settlement_days = _o->settlement_days;
  auto _face_amount = _o->face_amount;
  auto _schedule = _o->schedule ? CreateSchedule(_fbb, _o->schedule.get(), _rehasher) : 0;
  auto _coupon_rate = _o->coupon_rate;
  auto _day_counter = _o->day_counter;
  auto _business_day_convention = _o->business_day_convention;
  auto _redemption = _o->redemption;
  auto _issue_date = _o->issue_date.empty() ? 0 : _fbb.CreateString(_o->issue_date);
  return quantra::CreateBondHelper(
      _fbb,
      _rate,
      _settlement_days,
      _face_amount,
      _schedule,
      _coupon_rate,
      _day_counter,
      _business_day_convention,
      _redemption,
      _issue_date);
}

inline PointsWrapperT *PointsWrapper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PointsWrapperT>(new PointsWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointsWrapper::UnPackTo(PointsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = point_type(); _o->point.type = _e; }
  { auto _e = point(); if (_e) _o->point.value = quantra::PointUnion::UnPack(_e, point_type(), _resolver); }
}

inline ::flatbuffers::Offset<PointsWrapper> PointsWrapper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointsWrapper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PointsWrapper> CreatePointsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PointsWrapperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _point_type = _o->point.type;
  auto _point = _o->point.Pack(_fbb);
  return quantra::CreatePointsWrapper(
      _fbb,
      _point_type,
      _point);
}

inline TermStructureT::TermStructureT(const TermStructureT &o)
      : id(o.id),
        day_counter(o.day_counter),
        interpolator(o.interpolator),
        bootstrap_trait(o.bootstrap_trait),
        reference_date(o.reference_date) {
  points.reserve(o.points.size());
  for (const auto &points_ : o.points) { points.emplace_back((points_) ? new quantra::PointsWrapperT(*points_) : nullptr); }
}

inline TermStructureT &TermStructureT::operator=(TermStructureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(day_counter, o.day_counter);
  std::swap(interpolator, o.interpolator);
  std::swap(bootstrap_trait, o.bootstrap_trait);
  std::swap(points, o.points);
  std::swap(reference_date, o.reference_date);
  return *this;
}

inline TermStructureT *TermStructure::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TermStructureT>(new TermStructureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TermStructure::UnPackTo(TermStructureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = interpolator(); _o->interpolator = _e; }
  { auto _e = bootstrap_trait(); _o->bootstrap_trait = _e; }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<quantra::PointsWrapperT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->points.resize(0); } }
  { auto _e = reference_date(); if (_e) _o->reference_date = _e->str(); }
}

inline ::flatbuffers::Offset<TermStructure> TermStructure::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTermStructure(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TermStructure> CreateTermStructure(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TermStructureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _day_counter = _o->day_counter;
  auto _interpolator = _o->interpolator;
  auto _bootstrap_trait = _o->bootstrap_trait;
  auto _points = _o->points.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::PointsWrapper>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreatePointsWrapper(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _reference_date = _o->reference_date.empty() ? 0 : _fbb.CreateString(_o->reference_date);
  return quantra::CreateTermStructure(
      _fbb,
      _id,
      _day_counter,
      _interpolator,
      _bootstrap_trait,
      _points,
      _reference_date);
}

inline bool VerifyPoint(::flatbuffers::Verifier &verifier, const void *obj, Point type) {
  switch (type) {
    case Point_NONE: {
      return true;
    }
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<const quantra::DepositHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<const quantra::FRAHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<const quantra::FutureHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<const quantra::SwapHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<const quantra::BondHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPointVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPoint(
        verifier,  values->Get(i), types->GetEnum<Point>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PointUnion::UnPack(const void *obj, Point type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<const quantra::DepositHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<const quantra::FRAHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<const quantra::FutureHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<const quantra::SwapHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<const quantra::BondHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> PointUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<const quantra::DepositHelperT *>(value);
      return CreateDepositHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<const quantra::FRAHelperT *>(value);
      return CreateFRAHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<const quantra::FutureHelperT *>(value);
      return CreateFutureHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<const quantra::SwapHelperT *>(value);
      return CreateSwapHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<const quantra::BondHelperT *>(value);
      return CreateBondHelper(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PointUnion::PointUnion(const PointUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Point_DepositHelper: {
      value = new quantra::DepositHelperT(*reinterpret_cast<quantra::DepositHelperT *>(u.value));
      break;
    }
    case Point_FRAHelper: {
      value = new quantra::FRAHelperT(*reinterpret_cast<quantra::FRAHelperT *>(u.value));
      break;
    }
    case Point_FutureHelper: {
      value = new quantra::FutureHelperT(*reinterpret_cast<quantra::FutureHelperT *>(u.value));
      break;
    }
    case Point_SwapHelper: {
      value = new quantra::SwapHelperT(*reinterpret_cast<quantra::SwapHelperT *>(u.value));
      break;
    }
    case Point_BondHelper: {
      value = new quantra::BondHelperT(*reinterpret_cast<quantra::BondHelperT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PointUnion::Reset() {
  switch (type) {
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<quantra::DepositHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<quantra::FRAHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<quantra::FutureHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<quantra::SwapHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<quantra::BondHelperT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Point_NONE;
}

inline const quantra::TermStructure *GetTermStructure(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::TermStructure>(buf);
}

inline const quantra::TermStructure *GetSizePrefixedTermStructure(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::TermStructure>(buf);
}

inline bool VerifyTermStructureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::TermStructure>(nullptr);
}

inline bool VerifySizePrefixedTermStructureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::TermStructure>(nullptr);
}

inline void FinishTermStructureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::TermStructure> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTermStructureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::TermStructure> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<quantra::TermStructureT> UnPackTermStructure(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::TermStructureT>(GetTermStructure(buf)->UnPack(res));
}

inline std::unique_ptr<quantra::TermStructureT> UnPackSizePrefixedTermStructure(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::TermStructureT>(GetSizePrefixedTermStructure(buf)->UnPack(res));
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_
