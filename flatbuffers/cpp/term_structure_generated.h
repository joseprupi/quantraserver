// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"
#include "schedule_generated.h"

namespace quantra {

struct IborIndexSpec;
struct IborIndexSpecBuilder;
struct IborIndexSpecT;

struct OvernightIndexSpec;
struct OvernightIndexSpecBuilder;
struct OvernightIndexSpecT;

struct CurveRef;
struct CurveRefBuilder;
struct CurveRefT;

struct HelperDependencies;
struct HelperDependenciesBuilder;
struct HelperDependenciesT;

struct Fixing;
struct FixingBuilder;
struct FixingT;

struct IndexFixings;
struct IndexFixingsBuilder;
struct IndexFixingsT;

struct DepositHelper;
struct DepositHelperBuilder;
struct DepositHelperT;

struct FRAHelper;
struct FRAHelperBuilder;
struct FRAHelperT;

struct FutureHelper;
struct FutureHelperBuilder;
struct FutureHelperT;

struct SwapHelper;
struct SwapHelperBuilder;
struct SwapHelperT;

struct BondHelper;
struct BondHelperBuilder;
struct BondHelperT;

struct OISHelper;
struct OISHelperBuilder;
struct OISHelperT;

struct DatedOISHelper;
struct DatedOISHelperBuilder;
struct DatedOISHelperT;

struct TenorBasisSwapHelper;
struct TenorBasisSwapHelperBuilder;
struct TenorBasisSwapHelperT;

struct FxSwapHelper;
struct FxSwapHelperBuilder;
struct FxSwapHelperT;

struct CrossCcyBasisHelper;
struct CrossCcyBasisHelperBuilder;
struct CrossCcyBasisHelperT;

struct PointsWrapper;
struct PointsWrapperBuilder;
struct PointsWrapperT;

struct TermStructure;
struct TermStructureBuilder;
struct TermStructureT;

enum IndexSpec : uint8_t {
  IndexSpec_NONE = 0,
  IndexSpec_IborIndexSpec = 1,
  IndexSpec_OvernightIndexSpec = 2,
  IndexSpec_MIN = IndexSpec_NONE,
  IndexSpec_MAX = IndexSpec_OvernightIndexSpec
};

inline const IndexSpec (&EnumValuesIndexSpec())[3] {
  static const IndexSpec values[] = {
    IndexSpec_NONE,
    IndexSpec_IborIndexSpec,
    IndexSpec_OvernightIndexSpec
  };
  return values;
}

inline const char * const *EnumNamesIndexSpec() {
  static const char * const names[4] = {
    "NONE",
    "IborIndexSpec",
    "OvernightIndexSpec",
    nullptr
  };
  return names;
}

inline const char *EnumNameIndexSpec(IndexSpec e) {
  if (::flatbuffers::IsOutRange(e, IndexSpec_NONE, IndexSpec_OvernightIndexSpec)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIndexSpec()[index];
}

template<typename T> struct IndexSpecTraits {
  static const IndexSpec enum_value = IndexSpec_NONE;
};

template<> struct IndexSpecTraits<quantra::IborIndexSpec> {
  static const IndexSpec enum_value = IndexSpec_IborIndexSpec;
};

template<> struct IndexSpecTraits<quantra::OvernightIndexSpec> {
  static const IndexSpec enum_value = IndexSpec_OvernightIndexSpec;
};

template<typename T> struct IndexSpecUnionTraits {
  static const IndexSpec enum_value = IndexSpec_NONE;
};

template<> struct IndexSpecUnionTraits<quantra::IborIndexSpecT> {
  static const IndexSpec enum_value = IndexSpec_IborIndexSpec;
};

template<> struct IndexSpecUnionTraits<quantra::OvernightIndexSpecT> {
  static const IndexSpec enum_value = IndexSpec_OvernightIndexSpec;
};

struct IndexSpecUnion {
  IndexSpec type;
  void *value;

  IndexSpecUnion() : type(IndexSpec_NONE), value(nullptr) {}
  IndexSpecUnion(IndexSpecUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(IndexSpec_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  IndexSpecUnion(const IndexSpecUnion &);
  IndexSpecUnion &operator=(const IndexSpecUnion &u)
    { IndexSpecUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  IndexSpecUnion &operator=(IndexSpecUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~IndexSpecUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = IndexSpecUnionTraits<RT>::enum_value;
    if (type != IndexSpec_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, IndexSpec type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::IborIndexSpecT *AsIborIndexSpec() {
    return type == IndexSpec_IborIndexSpec ?
      reinterpret_cast<quantra::IborIndexSpecT *>(value) : nullptr;
  }
  const quantra::IborIndexSpecT *AsIborIndexSpec() const {
    return type == IndexSpec_IborIndexSpec ?
      reinterpret_cast<const quantra::IborIndexSpecT *>(value) : nullptr;
  }
  quantra::OvernightIndexSpecT *AsOvernightIndexSpec() {
    return type == IndexSpec_OvernightIndexSpec ?
      reinterpret_cast<quantra::OvernightIndexSpecT *>(value) : nullptr;
  }
  const quantra::OvernightIndexSpecT *AsOvernightIndexSpec() const {
    return type == IndexSpec_OvernightIndexSpec ?
      reinterpret_cast<const quantra::OvernightIndexSpecT *>(value) : nullptr;
  }
};

bool VerifyIndexSpec(::flatbuffers::Verifier &verifier, const void *obj, IndexSpec type);
bool VerifyIndexSpecVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Point : uint8_t {
  Point_NONE = 0,
  Point_DepositHelper = 1,
  Point_FRAHelper = 2,
  Point_FutureHelper = 3,
  Point_SwapHelper = 4,
  Point_BondHelper = 5,
  Point_OISHelper = 6,
  Point_DatedOISHelper = 7,
  Point_TenorBasisSwapHelper = 8,
  Point_FxSwapHelper = 9,
  Point_CrossCcyBasisHelper = 10,
  Point_MIN = Point_NONE,
  Point_MAX = Point_CrossCcyBasisHelper
};

inline const Point (&EnumValuesPoint())[11] {
  static const Point values[] = {
    Point_NONE,
    Point_DepositHelper,
    Point_FRAHelper,
    Point_FutureHelper,
    Point_SwapHelper,
    Point_BondHelper,
    Point_OISHelper,
    Point_DatedOISHelper,
    Point_TenorBasisSwapHelper,
    Point_FxSwapHelper,
    Point_CrossCcyBasisHelper
  };
  return values;
}

inline const char * const *EnumNamesPoint() {
  static const char * const names[12] = {
    "NONE",
    "DepositHelper",
    "FRAHelper",
    "FutureHelper",
    "SwapHelper",
    "BondHelper",
    "OISHelper",
    "DatedOISHelper",
    "TenorBasisSwapHelper",
    "FxSwapHelper",
    "CrossCcyBasisHelper",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoint(Point e) {
  if (::flatbuffers::IsOutRange(e, Point_NONE, Point_CrossCcyBasisHelper)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoint()[index];
}

template<typename T> struct PointTraits {
  static const Point enum_value = Point_NONE;
};

template<> struct PointTraits<quantra::DepositHelper> {
  static const Point enum_value = Point_DepositHelper;
};

template<> struct PointTraits<quantra::FRAHelper> {
  static const Point enum_value = Point_FRAHelper;
};

template<> struct PointTraits<quantra::FutureHelper> {
  static const Point enum_value = Point_FutureHelper;
};

template<> struct PointTraits<quantra::SwapHelper> {
  static const Point enum_value = Point_SwapHelper;
};

template<> struct PointTraits<quantra::BondHelper> {
  static const Point enum_value = Point_BondHelper;
};

template<> struct PointTraits<quantra::OISHelper> {
  static const Point enum_value = Point_OISHelper;
};

template<> struct PointTraits<quantra::DatedOISHelper> {
  static const Point enum_value = Point_DatedOISHelper;
};

template<> struct PointTraits<quantra::TenorBasisSwapHelper> {
  static const Point enum_value = Point_TenorBasisSwapHelper;
};

template<> struct PointTraits<quantra::FxSwapHelper> {
  static const Point enum_value = Point_FxSwapHelper;
};

template<> struct PointTraits<quantra::CrossCcyBasisHelper> {
  static const Point enum_value = Point_CrossCcyBasisHelper;
};

template<typename T> struct PointUnionTraits {
  static const Point enum_value = Point_NONE;
};

template<> struct PointUnionTraits<quantra::DepositHelperT> {
  static const Point enum_value = Point_DepositHelper;
};

template<> struct PointUnionTraits<quantra::FRAHelperT> {
  static const Point enum_value = Point_FRAHelper;
};

template<> struct PointUnionTraits<quantra::FutureHelperT> {
  static const Point enum_value = Point_FutureHelper;
};

template<> struct PointUnionTraits<quantra::SwapHelperT> {
  static const Point enum_value = Point_SwapHelper;
};

template<> struct PointUnionTraits<quantra::BondHelperT> {
  static const Point enum_value = Point_BondHelper;
};

template<> struct PointUnionTraits<quantra::OISHelperT> {
  static const Point enum_value = Point_OISHelper;
};

template<> struct PointUnionTraits<quantra::DatedOISHelperT> {
  static const Point enum_value = Point_DatedOISHelper;
};

template<> struct PointUnionTraits<quantra::TenorBasisSwapHelperT> {
  static const Point enum_value = Point_TenorBasisSwapHelper;
};

template<> struct PointUnionTraits<quantra::FxSwapHelperT> {
  static const Point enum_value = Point_FxSwapHelper;
};

template<> struct PointUnionTraits<quantra::CrossCcyBasisHelperT> {
  static const Point enum_value = Point_CrossCcyBasisHelper;
};

struct PointUnion {
  Point type;
  void *value;

  PointUnion() : type(Point_NONE), value(nullptr) {}
  PointUnion(PointUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Point_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PointUnion(const PointUnion &);
  PointUnion &operator=(const PointUnion &u)
    { PointUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PointUnion &operator=(PointUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PointUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = PointUnionTraits<RT>::enum_value;
    if (type != Point_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Point type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::DepositHelperT *AsDepositHelper() {
    return type == Point_DepositHelper ?
      reinterpret_cast<quantra::DepositHelperT *>(value) : nullptr;
  }
  const quantra::DepositHelperT *AsDepositHelper() const {
    return type == Point_DepositHelper ?
      reinterpret_cast<const quantra::DepositHelperT *>(value) : nullptr;
  }
  quantra::FRAHelperT *AsFRAHelper() {
    return type == Point_FRAHelper ?
      reinterpret_cast<quantra::FRAHelperT *>(value) : nullptr;
  }
  const quantra::FRAHelperT *AsFRAHelper() const {
    return type == Point_FRAHelper ?
      reinterpret_cast<const quantra::FRAHelperT *>(value) : nullptr;
  }
  quantra::FutureHelperT *AsFutureHelper() {
    return type == Point_FutureHelper ?
      reinterpret_cast<quantra::FutureHelperT *>(value) : nullptr;
  }
  const quantra::FutureHelperT *AsFutureHelper() const {
    return type == Point_FutureHelper ?
      reinterpret_cast<const quantra::FutureHelperT *>(value) : nullptr;
  }
  quantra::SwapHelperT *AsSwapHelper() {
    return type == Point_SwapHelper ?
      reinterpret_cast<quantra::SwapHelperT *>(value) : nullptr;
  }
  const quantra::SwapHelperT *AsSwapHelper() const {
    return type == Point_SwapHelper ?
      reinterpret_cast<const quantra::SwapHelperT *>(value) : nullptr;
  }
  quantra::BondHelperT *AsBondHelper() {
    return type == Point_BondHelper ?
      reinterpret_cast<quantra::BondHelperT *>(value) : nullptr;
  }
  const quantra::BondHelperT *AsBondHelper() const {
    return type == Point_BondHelper ?
      reinterpret_cast<const quantra::BondHelperT *>(value) : nullptr;
  }
  quantra::OISHelperT *AsOISHelper() {
    return type == Point_OISHelper ?
      reinterpret_cast<quantra::OISHelperT *>(value) : nullptr;
  }
  const quantra::OISHelperT *AsOISHelper() const {
    return type == Point_OISHelper ?
      reinterpret_cast<const quantra::OISHelperT *>(value) : nullptr;
  }
  quantra::DatedOISHelperT *AsDatedOISHelper() {
    return type == Point_DatedOISHelper ?
      reinterpret_cast<quantra::DatedOISHelperT *>(value) : nullptr;
  }
  const quantra::DatedOISHelperT *AsDatedOISHelper() const {
    return type == Point_DatedOISHelper ?
      reinterpret_cast<const quantra::DatedOISHelperT *>(value) : nullptr;
  }
  quantra::TenorBasisSwapHelperT *AsTenorBasisSwapHelper() {
    return type == Point_TenorBasisSwapHelper ?
      reinterpret_cast<quantra::TenorBasisSwapHelperT *>(value) : nullptr;
  }
  const quantra::TenorBasisSwapHelperT *AsTenorBasisSwapHelper() const {
    return type == Point_TenorBasisSwapHelper ?
      reinterpret_cast<const quantra::TenorBasisSwapHelperT *>(value) : nullptr;
  }
  quantra::FxSwapHelperT *AsFxSwapHelper() {
    return type == Point_FxSwapHelper ?
      reinterpret_cast<quantra::FxSwapHelperT *>(value) : nullptr;
  }
  const quantra::FxSwapHelperT *AsFxSwapHelper() const {
    return type == Point_FxSwapHelper ?
      reinterpret_cast<const quantra::FxSwapHelperT *>(value) : nullptr;
  }
  quantra::CrossCcyBasisHelperT *AsCrossCcyBasisHelper() {
    return type == Point_CrossCcyBasisHelper ?
      reinterpret_cast<quantra::CrossCcyBasisHelperT *>(value) : nullptr;
  }
  const quantra::CrossCcyBasisHelperT *AsCrossCcyBasisHelper() const {
    return type == Point_CrossCcyBasisHelper ?
      reinterpret_cast<const quantra::CrossCcyBasisHelperT *>(value) : nullptr;
  }
};

bool VerifyPoint(::flatbuffers::Verifier &verifier, const void *obj, Point type);
bool VerifyPointVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct IborIndexSpecT : public ::flatbuffers::NativeTable {
  typedef IborIndexSpec TableType;
  quantra::enums::IborFamily family = quantra::enums::IborFamily_Euribor;
  int32_t tenor_number = 3;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Months;
  int32_t fixing_days = 2;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  bool end_of_month = true;
};

/// IBOR index fully described by conventions
struct IborIndexSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IborIndexSpecT NativeTableType;
  typedef IborIndexSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FAMILY = 4,
    VT_TENOR_NUMBER = 6,
    VT_TENOR_TIME_UNIT = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16,
    VT_END_OF_MONTH = 18
  };
  quantra::enums::IborFamily family() const {
    return static_cast<quantra::enums::IborFamily>(GetField<int8_t>(VT_FAMILY, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 3);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 5));
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 2);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 32));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 2));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool end_of_month() const {
    return GetField<uint8_t>(VT_END_OF_MONTH, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FAMILY, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<uint8_t>(verifier, VT_END_OF_MONTH, 1) &&
           verifier.EndTable();
  }
  IborIndexSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IborIndexSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IborIndexSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IborIndexSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IborIndexSpecBuilder {
  typedef IborIndexSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_family(quantra::enums::IborFamily family) {
    fbb_.AddElement<int8_t>(IborIndexSpec::VT_FAMILY, static_cast<int8_t>(family), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(IborIndexSpec::VT_TENOR_NUMBER, tenor_number, 3);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(IborIndexSpec::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 5);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(IborIndexSpec::VT_FIXING_DAYS, fixing_days, 2);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(IborIndexSpec::VT_CALENDAR, static_cast<int8_t>(calendar), 32);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(IborIndexSpec::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 2);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(IborIndexSpec::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_end_of_month(bool end_of_month) {
    fbb_.AddElement<uint8_t>(IborIndexSpec::VT_END_OF_MONTH, static_cast<uint8_t>(end_of_month), 1);
  }
  explicit IborIndexSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IborIndexSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IborIndexSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IborIndexSpec> CreateIborIndexSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::IborFamily family = quantra::enums::IborFamily_Euribor,
    int32_t tenor_number = 3,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Months,
    int32_t fixing_days = 2,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    bool end_of_month = true) {
  IborIndexSpecBuilder builder_(_fbb);
  builder_.add_fixing_days(fixing_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_end_of_month(end_of_month);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  builder_.add_family(family);
  return builder_.Finish();
}

::flatbuffers::Offset<IborIndexSpec> CreateIborIndexSpec(::flatbuffers::FlatBufferBuilder &_fbb, const IborIndexSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OvernightIndexSpecT : public ::flatbuffers::NativeTable {
  typedef OvernightIndexSpec TableType;
  quantra::enums::OvernightIndex name = quantra::enums::OvernightIndex_SOFR;
  int32_t fixing_days = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_UnitedStatesGovernmentBond;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
};

/// Overnight index fully described by conventions
struct OvernightIndexSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OvernightIndexSpecT NativeTableType;
  typedef OvernightIndexSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FIXING_DAYS = 6,
    VT_CALENDAR = 8,
    VT_DAY_COUNTER = 10
  };
  quantra::enums::OvernightIndex name() const {
    return static_cast<quantra::enums::OvernightIndex>(GetField<int8_t>(VT_NAME, 0));
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 38));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_NAME, 1) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
  OvernightIndexSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OvernightIndexSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OvernightIndexSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OvernightIndexSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OvernightIndexSpecBuilder {
  typedef OvernightIndexSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(quantra::enums::OvernightIndex name) {
    fbb_.AddElement<int8_t>(OvernightIndexSpec::VT_NAME, static_cast<int8_t>(name), 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(OvernightIndexSpec::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(OvernightIndexSpec::VT_CALENDAR, static_cast<int8_t>(calendar), 38);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(OvernightIndexSpec::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit OvernightIndexSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OvernightIndexSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OvernightIndexSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OvernightIndexSpec> CreateOvernightIndexSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::OvernightIndex name = quantra::enums::OvernightIndex_SOFR,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_UnitedStatesGovernmentBond,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  OvernightIndexSpecBuilder builder_(_fbb);
  builder_.add_fixing_days(fixing_days);
  builder_.add_day_counter(day_counter);
  builder_.add_calendar(calendar);
  builder_.add_name(name);
  return builder_.Finish();
}

::flatbuffers::Offset<OvernightIndexSpec> CreateOvernightIndexSpec(::flatbuffers::FlatBufferBuilder &_fbb, const OvernightIndexSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CurveRefT : public ::flatbuffers::NativeTable {
  typedef CurveRef TableType;
  std::string id{};
};

struct CurveRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurveRefT NativeTableType;
  typedef CurveRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  CurveRefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CurveRefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CurveRef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CurveRefBuilder {
  typedef CurveRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CurveRef::VT_ID, id);
  }
  explicit CurveRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CurveRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CurveRef>(end);
    fbb_.Required(o, CurveRef::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<CurveRef> CreateCurveRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  CurveRefBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CurveRef> CreateCurveRefDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return quantra::CreateCurveRef(
      _fbb,
      id__);
}

::flatbuffers::Offset<CurveRef> CreateCurveRef(::flatbuffers::FlatBufferBuilder &_fbb, const CurveRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HelperDependenciesT : public ::flatbuffers::NativeTable {
  typedef HelperDependencies TableType;
  std::unique_ptr<quantra::CurveRefT> discount_curve{};
  std::unique_ptr<quantra::CurveRefT> projection_curve{};
  std::unique_ptr<quantra::CurveRefT> projection_curve_2{};
  std::string fx_spot_quote_id{};
  HelperDependenciesT() = default;
  HelperDependenciesT(const HelperDependenciesT &o);
  HelperDependenciesT(HelperDependenciesT&&) FLATBUFFERS_NOEXCEPT = default;
  HelperDependenciesT &operator=(HelperDependenciesT o) FLATBUFFERS_NOEXCEPT;
};

struct HelperDependencies FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HelperDependenciesT NativeTableType;
  typedef HelperDependenciesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISCOUNT_CURVE = 4,
    VT_PROJECTION_CURVE = 6,
    VT_PROJECTION_CURVE_2 = 8,
    VT_FX_SPOT_QUOTE_ID = 10
  };
  const quantra::CurveRef *discount_curve() const {
    return GetPointer<const quantra::CurveRef *>(VT_DISCOUNT_CURVE);
  }
  const quantra::CurveRef *projection_curve() const {
    return GetPointer<const quantra::CurveRef *>(VT_PROJECTION_CURVE);
  }
  const quantra::CurveRef *projection_curve_2() const {
    return GetPointer<const quantra::CurveRef *>(VT_PROJECTION_CURVE_2);
  }
  const ::flatbuffers::String *fx_spot_quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FX_SPOT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISCOUNT_CURVE) &&
           verifier.VerifyTable(discount_curve()) &&
           VerifyOffset(verifier, VT_PROJECTION_CURVE) &&
           verifier.VerifyTable(projection_curve()) &&
           VerifyOffset(verifier, VT_PROJECTION_CURVE_2) &&
           verifier.VerifyTable(projection_curve_2()) &&
           VerifyOffset(verifier, VT_FX_SPOT_QUOTE_ID) &&
           verifier.VerifyString(fx_spot_quote_id()) &&
           verifier.EndTable();
  }
  HelperDependenciesT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HelperDependenciesT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HelperDependencies> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HelperDependenciesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HelperDependenciesBuilder {
  typedef HelperDependencies Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_discount_curve(::flatbuffers::Offset<quantra::CurveRef> discount_curve) {
    fbb_.AddOffset(HelperDependencies::VT_DISCOUNT_CURVE, discount_curve);
  }
  void add_projection_curve(::flatbuffers::Offset<quantra::CurveRef> projection_curve) {
    fbb_.AddOffset(HelperDependencies::VT_PROJECTION_CURVE, projection_curve);
  }
  void add_projection_curve_2(::flatbuffers::Offset<quantra::CurveRef> projection_curve_2) {
    fbb_.AddOffset(HelperDependencies::VT_PROJECTION_CURVE_2, projection_curve_2);
  }
  void add_fx_spot_quote_id(::flatbuffers::Offset<::flatbuffers::String> fx_spot_quote_id) {
    fbb_.AddOffset(HelperDependencies::VT_FX_SPOT_QUOTE_ID, fx_spot_quote_id);
  }
  explicit HelperDependenciesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HelperDependencies> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HelperDependencies>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HelperDependencies> CreateHelperDependencies(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::CurveRef> discount_curve = 0,
    ::flatbuffers::Offset<quantra::CurveRef> projection_curve = 0,
    ::flatbuffers::Offset<quantra::CurveRef> projection_curve_2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fx_spot_quote_id = 0) {
  HelperDependenciesBuilder builder_(_fbb);
  builder_.add_fx_spot_quote_id(fx_spot_quote_id);
  builder_.add_projection_curve_2(projection_curve_2);
  builder_.add_projection_curve(projection_curve);
  builder_.add_discount_curve(discount_curve);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HelperDependencies> CreateHelperDependenciesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::CurveRef> discount_curve = 0,
    ::flatbuffers::Offset<quantra::CurveRef> projection_curve = 0,
    ::flatbuffers::Offset<quantra::CurveRef> projection_curve_2 = 0,
    const char *fx_spot_quote_id = nullptr) {
  auto fx_spot_quote_id__ = fx_spot_quote_id ? _fbb.CreateString(fx_spot_quote_id) : 0;
  return quantra::CreateHelperDependencies(
      _fbb,
      discount_curve,
      projection_curve,
      projection_curve_2,
      fx_spot_quote_id__);
}

::flatbuffers::Offset<HelperDependencies> CreateHelperDependencies(::flatbuffers::FlatBufferBuilder &_fbb, const HelperDependenciesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FixingT : public ::flatbuffers::NativeTable {
  typedef Fixing TableType;
  std::string date{};
  double value = 0.0;
};

struct Fixing FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FixingT NativeTableType;
  typedef FixingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
  FixingT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FixingT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Fixing> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FixingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FixingBuilder {
  typedef Fixing Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_date(::flatbuffers::Offset<::flatbuffers::String> date) {
    fbb_.AddOffset(Fixing::VT_DATE, date);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Fixing::VT_VALUE, value, 0.0);
  }
  explicit FixingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Fixing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Fixing>(end);
    fbb_.Required(o, Fixing::VT_DATE);
    return o;
  }
};

inline ::flatbuffers::Offset<Fixing> CreateFixing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> date = 0,
    double value = 0.0) {
  FixingBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_date(date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Fixing> CreateFixingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *date = nullptr,
    double value = 0.0) {
  auto date__ = date ? _fbb.CreateString(date) : 0;
  return quantra::CreateFixing(
      _fbb,
      date__,
      value);
}

::flatbuffers::Offset<Fixing> CreateFixing(::flatbuffers::FlatBufferBuilder &_fbb, const FixingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IndexFixingsT : public ::flatbuffers::NativeTable {
  typedef IndexFixings TableType;
  std::string index_id{};
  std::vector<std::unique_ptr<quantra::FixingT>> fixings{};
  IndexFixingsT() = default;
  IndexFixingsT(const IndexFixingsT &o);
  IndexFixingsT(IndexFixingsT&&) FLATBUFFERS_NOEXCEPT = default;
  IndexFixingsT &operator=(IndexFixingsT o) FLATBUFFERS_NOEXCEPT;
};

struct IndexFixings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IndexFixingsT NativeTableType;
  typedef IndexFixingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX_ID = 4,
    VT_FIXINGS = 6
  };
  const ::flatbuffers::String *index_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INDEX_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>> *fixings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>> *>(VT_FIXINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INDEX_ID) &&
           verifier.VerifyString(index_id()) &&
           VerifyOffsetRequired(verifier, VT_FIXINGS) &&
           verifier.VerifyVector(fixings()) &&
           verifier.VerifyVectorOfTables(fixings()) &&
           verifier.EndTable();
  }
  IndexFixingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IndexFixingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IndexFixings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IndexFixingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IndexFixingsBuilder {
  typedef IndexFixings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index_id(::flatbuffers::Offset<::flatbuffers::String> index_id) {
    fbb_.AddOffset(IndexFixings::VT_INDEX_ID, index_id);
  }
  void add_fixings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>>> fixings) {
    fbb_.AddOffset(IndexFixings::VT_FIXINGS, fixings);
  }
  explicit IndexFixingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IndexFixings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IndexFixings>(end);
    fbb_.Required(o, IndexFixings::VT_INDEX_ID);
    fbb_.Required(o, IndexFixings::VT_FIXINGS);
    return o;
  }
};

inline ::flatbuffers::Offset<IndexFixings> CreateIndexFixings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> index_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>>> fixings = 0) {
  IndexFixingsBuilder builder_(_fbb);
  builder_.add_fixings(fixings);
  builder_.add_index_id(index_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IndexFixings> CreateIndexFixingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *index_id = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::Fixing>> *fixings = nullptr) {
  auto index_id__ = index_id ? _fbb.CreateString(index_id) : 0;
  auto fixings__ = fixings ? _fbb.CreateVector<::flatbuffers::Offset<quantra::Fixing>>(*fixings) : 0;
  return quantra::CreateIndexFixings(
      _fbb,
      index_id__,
      fixings__);
}

::flatbuffers::Offset<IndexFixings> CreateIndexFixings(::flatbuffers::FlatBufferBuilder &_fbb, const IndexFixingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DepositHelperT : public ::flatbuffers::NativeTable {
  typedef DepositHelper TableType;
  double rate = 0.0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  int32_t tenor_number = 0;
  int32_t fixing_days = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  std::string quote_id{};
};

struct DepositHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepositHelperT NativeTableType;
  typedef DepositHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16,
    VT_QUOTE_ID = 18
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  /// Optional: reference a shared quote by id instead of inline rate
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  DepositHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DepositHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DepositHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DepositHelperBuilder {
  typedef DepositHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(DepositHelper::VT_RATE, rate, 0.0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(DepositHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(DepositHelper::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(DepositHelper::VT_QUOTE_ID, quote_id);
  }
  explicit DepositHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepositHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepositHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepositHelper> CreateDepositHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  DepositHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_quote_id(quote_id);
  builder_.add_fixing_days(fixing_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DepositHelper> CreateDepositHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    const char *quote_id = nullptr) {
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateDepositHelper(
      _fbb,
      rate,
      tenor_time_unit,
      tenor_number,
      fixing_days,
      calendar,
      business_day_convention,
      day_counter,
      quote_id__);
}

::flatbuffers::Offset<DepositHelper> CreateDepositHelper(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FRAHelperT : public ::flatbuffers::NativeTable {
  typedef FRAHelper TableType;
  double rate = 0.0;
  int32_t months_to_start = 0;
  int32_t months_to_end = 0;
  int32_t fixing_days = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  std::string quote_id{};
};

struct FRAHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FRAHelperT NativeTableType;
  typedef FRAHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_MONTHS_TO_START = 6,
    VT_MONTHS_TO_END = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16,
    VT_QUOTE_ID = 18
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  int32_t months_to_start() const {
    return GetField<int32_t>(VT_MONTHS_TO_START, 0);
  }
  int32_t months_to_end() const {
    return GetField<int32_t>(VT_MONTHS_TO_END, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_START, 4) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_END, 4) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  FRAHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FRAHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FRAHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FRAHelperBuilder {
  typedef FRAHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(FRAHelper::VT_RATE, rate, 0.0);
  }
  void add_months_to_start(int32_t months_to_start) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_MONTHS_TO_START, months_to_start, 0);
  }
  void add_months_to_end(int32_t months_to_end) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_MONTHS_TO_END, months_to_end, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(FRAHelper::VT_QUOTE_ID, quote_id);
  }
  explicit FRAHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FRAHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FRAHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FRAHelper> CreateFRAHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t months_to_start = 0,
    int32_t months_to_end = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  FRAHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_quote_id(quote_id);
  builder_.add_fixing_days(fixing_days);
  builder_.add_months_to_end(months_to_end);
  builder_.add_months_to_start(months_to_start);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FRAHelper> CreateFRAHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t months_to_start = 0,
    int32_t months_to_end = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    const char *quote_id = nullptr) {
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateFRAHelper(
      _fbb,
      rate,
      months_to_start,
      months_to_end,
      fixing_days,
      calendar,
      business_day_convention,
      day_counter,
      quote_id__);
}

::flatbuffers::Offset<FRAHelper> CreateFRAHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FutureHelperT : public ::flatbuffers::NativeTable {
  typedef FutureHelper TableType;
  double rate = 0.0;
  std::string future_start_date{};
  int32_t future_months = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  double futures_price = 0.0;
  double convexity_adjustment = 0.0;
  std::string quote_id{};
};

struct FutureHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FutureHelperT NativeTableType;
  typedef FutureHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_FUTURE_START_DATE = 6,
    VT_FUTURE_MONTHS = 8,
    VT_CALENDAR = 10,
    VT_BUSINESS_DAY_CONVENTION = 12,
    VT_DAY_COUNTER = 14,
    VT_FUTURES_PRICE = 16,
    VT_CONVEXITY_ADJUSTMENT = 18,
    VT_QUOTE_ID = 20
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  const ::flatbuffers::String *future_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUTURE_START_DATE);
  }
  int32_t future_months() const {
    return GetField<int32_t>(VT_FUTURE_MONTHS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  /// Futures price (e.g. 95.25); if set, rate is ignored
  double futures_price() const {
    return GetField<double>(VT_FUTURES_PRICE, 0.0);
  }
  /// Convexity adjustment added to implied rate
  double convexity_adjustment() const {
    return GetField<double>(VT_CONVEXITY_ADJUSTMENT, 0.0);
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyOffset(verifier, VT_FUTURE_START_DATE) &&
           verifier.VerifyString(future_start_date()) &&
           VerifyField<int32_t>(verifier, VT_FUTURE_MONTHS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<double>(verifier, VT_FUTURES_PRICE, 8) &&
           VerifyField<double>(verifier, VT_CONVEXITY_ADJUSTMENT, 8) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  FutureHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FutureHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FutureHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FutureHelperBuilder {
  typedef FutureHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(FutureHelper::VT_RATE, rate, 0.0);
  }
  void add_future_start_date(::flatbuffers::Offset<::flatbuffers::String> future_start_date) {
    fbb_.AddOffset(FutureHelper::VT_FUTURE_START_DATE, future_start_date);
  }
  void add_future_months(int32_t future_months) {
    fbb_.AddElement<int32_t>(FutureHelper::VT_FUTURE_MONTHS, future_months, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_futures_price(double futures_price) {
    fbb_.AddElement<double>(FutureHelper::VT_FUTURES_PRICE, futures_price, 0.0);
  }
  void add_convexity_adjustment(double convexity_adjustment) {
    fbb_.AddElement<double>(FutureHelper::VT_CONVEXITY_ADJUSTMENT, convexity_adjustment, 0.0);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(FutureHelper::VT_QUOTE_ID, quote_id);
  }
  explicit FutureHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FutureHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FutureHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> future_start_date = 0,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    double futures_price = 0.0,
    double convexity_adjustment = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  FutureHelperBuilder builder_(_fbb);
  builder_.add_convexity_adjustment(convexity_adjustment);
  builder_.add_futures_price(futures_price);
  builder_.add_rate(rate);
  builder_.add_quote_id(quote_id);
  builder_.add_future_months(future_months);
  builder_.add_future_start_date(future_start_date);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    const char *future_start_date = nullptr,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    double futures_price = 0.0,
    double convexity_adjustment = 0.0,
    const char *quote_id = nullptr) {
  auto future_start_date__ = future_start_date ? _fbb.CreateString(future_start_date) : 0;
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateFutureHelper(
      _fbb,
      rate,
      future_start_date__,
      future_months,
      calendar,
      business_day_convention,
      day_counter,
      futures_price,
      convexity_adjustment,
      quote_id__);
}

::flatbuffers::Offset<FutureHelper> CreateFutureHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwapHelperT : public ::flatbuffers::NativeTable {
  typedef SwapHelper TableType;
  double rate = 0.0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  int32_t tenor_number = 0;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  quantra::enums::Frequency sw_fixed_leg_frequency = quantra::enums::Frequency_Annual;
  quantra::enums::BusinessDayConvention sw_fixed_leg_convention = quantra::enums::BusinessDayConvention_Following;
  quantra::enums::DayCounter sw_fixed_leg_day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::Ibor sw_floating_leg_index = quantra::enums::Ibor_Euribor10M;
  quantra::IndexSpecUnion float_index{};
  double spread = 0.0;
  int32_t fwd_start_days = 0;
  std::unique_ptr<quantra::HelperDependenciesT> deps{};
  std::string quote_id{};
  SwapHelperT() = default;
  SwapHelperT(const SwapHelperT &o);
  SwapHelperT(SwapHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  SwapHelperT &operator=(SwapHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct SwapHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapHelperT NativeTableType;
  typedef SwapHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_CALENDAR = 10,
    VT_SW_FIXED_LEG_FREQUENCY = 12,
    VT_SW_FIXED_LEG_CONVENTION = 14,
    VT_SW_FIXED_LEG_DAY_COUNTER = 16,
    VT_SW_FLOATING_LEG_INDEX = 18,
    VT_FLOAT_INDEX_TYPE = 20,
    VT_FLOAT_INDEX = 22,
    VT_SPREAD = 24,
    VT_FWD_START_DAYS = 26,
    VT_DEPS = 28,
    VT_QUOTE_ID = 30
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::Frequency sw_fixed_leg_frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_SW_FIXED_LEG_FREQUENCY, 0));
  }
  quantra::enums::BusinessDayConvention sw_fixed_leg_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_SW_FIXED_LEG_CONVENTION, 0));
  }
  quantra::enums::DayCounter sw_fixed_leg_day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_SW_FIXED_LEG_DAY_COUNTER, 0));
  }
  /// Legacy enum-based index (backward compatible)
  quantra::enums::Ibor sw_floating_leg_index() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_SW_FLOATING_LEG_INDEX, 0));
  }
  quantra::IndexSpec float_index_type() const {
    return static_cast<quantra::IndexSpec>(GetField<uint8_t>(VT_FLOAT_INDEX_TYPE, 0));
  }
  /// NEW: data-driven index spec (takes precedence over sw_floating_leg_index if set)
  const void *float_index() const {
    return GetPointer<const void *>(VT_FLOAT_INDEX);
  }
  template<typename T> const T *float_index_as() const;
  const quantra::IborIndexSpec *float_index_as_IborIndexSpec() const {
    return float_index_type() == quantra::IndexSpec_IborIndexSpec ? static_cast<const quantra::IborIndexSpec *>(float_index()) : nullptr;
  }
  const quantra::OvernightIndexSpec *float_index_as_OvernightIndexSpec() const {
    return float_index_type() == quantra::IndexSpec_OvernightIndexSpec ? static_cast<const quantra::OvernightIndexSpec *>(float_index()) : nullptr;
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  int32_t fwd_start_days() const {
    return GetField<int32_t>(VT_FWD_START_DAYS, 0);
  }
  /// NEW: exogenous discount curve for multi-curve bootstrapping
  const quantra::HelperDependencies *deps() const {
    return GetPointer<const quantra::HelperDependencies *>(VT_DEPS);
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FLOATING_LEG_INDEX, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOAT_INDEX_TYPE, 1) &&
           VerifyOffset(verifier, VT_FLOAT_INDEX) &&
           VerifyIndexSpec(verifier, float_index(), float_index_type()) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<int32_t>(verifier, VT_FWD_START_DAYS, 4) &&
           VerifyOffset(verifier, VT_DEPS) &&
           verifier.VerifyTable(deps()) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  SwapHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::IborIndexSpec *SwapHelper::float_index_as<quantra::IborIndexSpec>() const {
  return float_index_as_IborIndexSpec();
}

template<> inline const quantra::OvernightIndexSpec *SwapHelper::float_index_as<quantra::OvernightIndexSpec>() const {
  return float_index_as_OvernightIndexSpec();
}

struct SwapHelperBuilder {
  typedef SwapHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(SwapHelper::VT_RATE, rate, 0.0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(SwapHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_sw_fixed_leg_frequency(quantra::enums::Frequency sw_fixed_leg_frequency) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_FREQUENCY, static_cast<int8_t>(sw_fixed_leg_frequency), 0);
  }
  void add_sw_fixed_leg_convention(quantra::enums::BusinessDayConvention sw_fixed_leg_convention) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_CONVENTION, static_cast<int8_t>(sw_fixed_leg_convention), 0);
  }
  void add_sw_fixed_leg_day_counter(quantra::enums::DayCounter sw_fixed_leg_day_counter) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_DAY_COUNTER, static_cast<int8_t>(sw_fixed_leg_day_counter), 0);
  }
  void add_sw_floating_leg_index(quantra::enums::Ibor sw_floating_leg_index) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FLOATING_LEG_INDEX, static_cast<int8_t>(sw_floating_leg_index), 0);
  }
  void add_float_index_type(quantra::IndexSpec float_index_type) {
    fbb_.AddElement<uint8_t>(SwapHelper::VT_FLOAT_INDEX_TYPE, static_cast<uint8_t>(float_index_type), 0);
  }
  void add_float_index(::flatbuffers::Offset<void> float_index) {
    fbb_.AddOffset(SwapHelper::VT_FLOAT_INDEX, float_index);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(SwapHelper::VT_SPREAD, spread, 0.0);
  }
  void add_fwd_start_days(int32_t fwd_start_days) {
    fbb_.AddElement<int32_t>(SwapHelper::VT_FWD_START_DAYS, fwd_start_days, 0);
  }
  void add_deps(::flatbuffers::Offset<quantra::HelperDependencies> deps) {
    fbb_.AddOffset(SwapHelper::VT_DEPS, deps);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(SwapHelper::VT_QUOTE_ID, quote_id);
  }
  explicit SwapHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapHelper> CreateSwapHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::Frequency sw_fixed_leg_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention sw_fixed_leg_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter sw_fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Ibor sw_floating_leg_index = quantra::enums::Ibor_Euribor10M,
    quantra::IndexSpec float_index_type = quantra::IndexSpec_NONE,
    ::flatbuffers::Offset<void> float_index = 0,
    double spread = 0.0,
    int32_t fwd_start_days = 0,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  SwapHelperBuilder builder_(_fbb);
  builder_.add_spread(spread);
  builder_.add_rate(rate);
  builder_.add_quote_id(quote_id);
  builder_.add_deps(deps);
  builder_.add_fwd_start_days(fwd_start_days);
  builder_.add_float_index(float_index);
  builder_.add_tenor_number(tenor_number);
  builder_.add_float_index_type(float_index_type);
  builder_.add_sw_floating_leg_index(sw_floating_leg_index);
  builder_.add_sw_fixed_leg_day_counter(sw_fixed_leg_day_counter);
  builder_.add_sw_fixed_leg_convention(sw_fixed_leg_convention);
  builder_.add_sw_fixed_leg_frequency(sw_fixed_leg_frequency);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapHelper> CreateSwapHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::Frequency sw_fixed_leg_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention sw_fixed_leg_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter sw_fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Ibor sw_floating_leg_index = quantra::enums::Ibor_Euribor10M,
    quantra::IndexSpec float_index_type = quantra::IndexSpec_NONE,
    ::flatbuffers::Offset<void> float_index = 0,
    double spread = 0.0,
    int32_t fwd_start_days = 0,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    const char *quote_id = nullptr) {
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateSwapHelper(
      _fbb,
      rate,
      tenor_time_unit,
      tenor_number,
      calendar,
      sw_fixed_leg_frequency,
      sw_fixed_leg_convention,
      sw_fixed_leg_day_counter,
      sw_floating_leg_index,
      float_index_type,
      float_index,
      spread,
      fwd_start_days,
      deps,
      quote_id__);
}

::flatbuffers::Offset<SwapHelper> CreateSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BondHelperT : public ::flatbuffers::NativeTable {
  typedef BondHelper TableType;
  double rate = 0.0;
  int32_t settlement_days = 0;
  double face_amount = 0.0;
  std::unique_ptr<quantra::ScheduleT> schedule{};
  double coupon_rate = 0.0;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  double redemption = 0.0;
  std::string issue_date{};
  double price = 0.0;
  std::string quote_id{};
  BondHelperT() = default;
  BondHelperT(const BondHelperT &o);
  BondHelperT(BondHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  BondHelperT &operator=(BondHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct BondHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BondHelperT NativeTableType;
  typedef BondHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_SETTLEMENT_DAYS = 6,
    VT_FACE_AMOUNT = 8,
    VT_SCHEDULE = 10,
    VT_COUPON_RATE = 12,
    VT_DAY_COUNTER = 14,
    VT_BUSINESS_DAY_CONVENTION = 16,
    VT_REDEMPTION = 18,
    VT_ISSUE_DATE = 20,
    VT_PRICE = 22,
    VT_QUOTE_ID = 24
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 0);
  }
  double face_amount() const {
    return GetField<double>(VT_FACE_AMOUNT, 0.0);
  }
  const quantra::Schedule *schedule() const {
    return GetPointer<const quantra::Schedule *>(VT_SCHEDULE);
  }
  double coupon_rate() const {
    return GetField<double>(VT_COUPON_RATE, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  double redemption() const {
    return GetField<double>(VT_REDEMPTION, 0.0);
  }
  const ::flatbuffers::String *issue_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ISSUE_DATE);
  }
  /// Bond price (preferred over rate for clarity)
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<double>(verifier, VT_FACE_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.VerifyTable(schedule()) &&
           VerifyField<double>(verifier, VT_COUPON_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<double>(verifier, VT_REDEMPTION, 8) &&
           VerifyOffset(verifier, VT_ISSUE_DATE) &&
           verifier.VerifyString(issue_date()) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  BondHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BondHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BondHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BondHelperBuilder {
  typedef BondHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(BondHelper::VT_RATE, rate, 0.0);
  }
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(BondHelper::VT_SETTLEMENT_DAYS, settlement_days, 0);
  }
  void add_face_amount(double face_amount) {
    fbb_.AddElement<double>(BondHelper::VT_FACE_AMOUNT, face_amount, 0.0);
  }
  void add_schedule(::flatbuffers::Offset<quantra::Schedule> schedule) {
    fbb_.AddOffset(BondHelper::VT_SCHEDULE, schedule);
  }
  void add_coupon_rate(double coupon_rate) {
    fbb_.AddElement<double>(BondHelper::VT_COUPON_RATE, coupon_rate, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(BondHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(BondHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_redemption(double redemption) {
    fbb_.AddElement<double>(BondHelper::VT_REDEMPTION, redemption, 0.0);
  }
  void add_issue_date(::flatbuffers::Offset<::flatbuffers::String> issue_date) {
    fbb_.AddOffset(BondHelper::VT_ISSUE_DATE, issue_date);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(BondHelper::VT_PRICE, price, 0.0);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(BondHelper::VT_QUOTE_ID, quote_id);
  }
  explicit BondHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BondHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BondHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BondHelper> CreateBondHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t settlement_days = 0,
    double face_amount = 0.0,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double coupon_rate = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double redemption = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> issue_date = 0,
    double price = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  BondHelperBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_redemption(redemption);
  builder_.add_coupon_rate(coupon_rate);
  builder_.add_face_amount(face_amount);
  builder_.add_rate(rate);
  builder_.add_quote_id(quote_id);
  builder_.add_issue_date(issue_date);
  builder_.add_schedule(schedule);
  builder_.add_settlement_days(settlement_days);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BondHelper> CreateBondHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t settlement_days = 0,
    double face_amount = 0.0,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double coupon_rate = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double redemption = 0.0,
    const char *issue_date = nullptr,
    double price = 0.0,
    const char *quote_id = nullptr) {
  auto issue_date__ = issue_date ? _fbb.CreateString(issue_date) : 0;
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateBondHelper(
      _fbb,
      rate,
      settlement_days,
      face_amount,
      schedule,
      coupon_rate,
      day_counter,
      business_day_convention,
      redemption,
      issue_date__,
      price,
      quote_id__);
}

::flatbuffers::Offset<BondHelper> CreateBondHelper(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OISHelperT : public ::flatbuffers::NativeTable {
  typedef OISHelper TableType;
  double rate = 0.0;
  int32_t tenor_number = 0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  quantra::enums::OvernightIndex overnight_index = quantra::enums::OvernightIndex_SOFR;
  std::unique_ptr<quantra::OvernightIndexSpecT> overnight_index_spec{};
  int32_t settlement_days = 2;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET;
  quantra::enums::Frequency fixed_leg_frequency = quantra::enums::Frequency_Annual;
  quantra::enums::BusinessDayConvention fixed_leg_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  quantra::enums::DayCounter fixed_leg_day_counter = quantra::enums::DayCounter_Actual360;
  std::string quote_id{};
  OISHelperT() = default;
  OISHelperT(const OISHelperT &o);
  OISHelperT(OISHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  OISHelperT &operator=(OISHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct OISHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OISHelperT NativeTableType;
  typedef OISHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_NUMBER = 6,
    VT_TENOR_TIME_UNIT = 8,
    VT_OVERNIGHT_INDEX = 10,
    VT_OVERNIGHT_INDEX_SPEC = 12,
    VT_SETTLEMENT_DAYS = 14,
    VT_CALENDAR = 16,
    VT_FIXED_LEG_FREQUENCY = 18,
    VT_FIXED_LEG_CONVENTION = 20,
    VT_FIXED_LEG_DAY_COUNTER = 22,
    VT_QUOTE_ID = 24
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  /// Overnight index (enum-based for simplicity)
  quantra::enums::OvernightIndex overnight_index() const {
    return static_cast<quantra::enums::OvernightIndex>(GetField<int8_t>(VT_OVERNIGHT_INDEX, 0));
  }
  /// Or use full spec (takes precedence if set)
  const quantra::OvernightIndexSpec *overnight_index_spec() const {
    return GetPointer<const quantra::OvernightIndexSpec *>(VT_OVERNIGHT_INDEX_SPEC);
  }
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 2);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 32));
  }
  quantra::enums::Frequency fixed_leg_frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FIXED_LEG_FREQUENCY, 0));
  }
  quantra::enums::BusinessDayConvention fixed_leg_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_FIXED_LEG_CONVENTION, 2));
  }
  quantra::enums::DayCounter fixed_leg_day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_FIXED_LEG_DAY_COUNTER, 0));
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int8_t>(verifier, VT_OVERNIGHT_INDEX, 1) &&
           VerifyOffset(verifier, VT_OVERNIGHT_INDEX_SPEC) &&
           verifier.VerifyTable(overnight_index_spec()) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_LEG_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_LEG_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_LEG_DAY_COUNTER, 1) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  OISHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OISHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OISHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OISHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OISHelperBuilder {
  typedef OISHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(OISHelper::VT_RATE, rate, 0.0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(OISHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(OISHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_overnight_index(quantra::enums::OvernightIndex overnight_index) {
    fbb_.AddElement<int8_t>(OISHelper::VT_OVERNIGHT_INDEX, static_cast<int8_t>(overnight_index), 0);
  }
  void add_overnight_index_spec(::flatbuffers::Offset<quantra::OvernightIndexSpec> overnight_index_spec) {
    fbb_.AddOffset(OISHelper::VT_OVERNIGHT_INDEX_SPEC, overnight_index_spec);
  }
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(OISHelper::VT_SETTLEMENT_DAYS, settlement_days, 2);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(OISHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 32);
  }
  void add_fixed_leg_frequency(quantra::enums::Frequency fixed_leg_frequency) {
    fbb_.AddElement<int8_t>(OISHelper::VT_FIXED_LEG_FREQUENCY, static_cast<int8_t>(fixed_leg_frequency), 0);
  }
  void add_fixed_leg_convention(quantra::enums::BusinessDayConvention fixed_leg_convention) {
    fbb_.AddElement<int8_t>(OISHelper::VT_FIXED_LEG_CONVENTION, static_cast<int8_t>(fixed_leg_convention), 2);
  }
  void add_fixed_leg_day_counter(quantra::enums::DayCounter fixed_leg_day_counter) {
    fbb_.AddElement<int8_t>(OISHelper::VT_FIXED_LEG_DAY_COUNTER, static_cast<int8_t>(fixed_leg_day_counter), 0);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(OISHelper::VT_QUOTE_ID, quote_id);
  }
  explicit OISHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OISHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OISHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OISHelper> CreateOISHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    quantra::enums::OvernightIndex overnight_index = quantra::enums::OvernightIndex_SOFR,
    ::flatbuffers::Offset<quantra::OvernightIndexSpec> overnight_index_spec = 0,
    int32_t settlement_days = 2,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::Frequency fixed_leg_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention fixed_leg_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::DayCounter fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  OISHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_quote_id(quote_id);
  builder_.add_settlement_days(settlement_days);
  builder_.add_overnight_index_spec(overnight_index_spec);
  builder_.add_tenor_number(tenor_number);
  builder_.add_fixed_leg_day_counter(fixed_leg_day_counter);
  builder_.add_fixed_leg_convention(fixed_leg_convention);
  builder_.add_fixed_leg_frequency(fixed_leg_frequency);
  builder_.add_calendar(calendar);
  builder_.add_overnight_index(overnight_index);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OISHelper> CreateOISHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    quantra::enums::OvernightIndex overnight_index = quantra::enums::OvernightIndex_SOFR,
    ::flatbuffers::Offset<quantra::OvernightIndexSpec> overnight_index_spec = 0,
    int32_t settlement_days = 2,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::Frequency fixed_leg_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention fixed_leg_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::DayCounter fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    const char *quote_id = nullptr) {
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateOISHelper(
      _fbb,
      rate,
      tenor_number,
      tenor_time_unit,
      overnight_index,
      overnight_index_spec,
      settlement_days,
      calendar,
      fixed_leg_frequency,
      fixed_leg_convention,
      fixed_leg_day_counter,
      quote_id__);
}

::flatbuffers::Offset<OISHelper> CreateOISHelper(::flatbuffers::FlatBufferBuilder &_fbb, const OISHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DatedOISHelperT : public ::flatbuffers::NativeTable {
  typedef DatedOISHelper TableType;
  double rate = 0.0;
  std::string start_date{};
  std::string end_date{};
  quantra::enums::OvernightIndex overnight_index = quantra::enums::OvernightIndex_SOFR;
  std::unique_ptr<quantra::OvernightIndexSpecT> overnight_index_spec{};
  int32_t settlement_days = 2;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET;
  quantra::enums::BusinessDayConvention fixed_leg_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  quantra::enums::DayCounter fixed_leg_day_counter = quantra::enums::DayCounter_Actual360;
  std::string quote_id{};
  DatedOISHelperT() = default;
  DatedOISHelperT(const DatedOISHelperT &o);
  DatedOISHelperT(DatedOISHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  DatedOISHelperT &operator=(DatedOISHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct DatedOISHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DatedOISHelperT NativeTableType;
  typedef DatedOISHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_START_DATE = 6,
    VT_END_DATE = 8,
    VT_OVERNIGHT_INDEX = 10,
    VT_OVERNIGHT_INDEX_SPEC = 12,
    VT_SETTLEMENT_DAYS = 14,
    VT_CALENDAR = 16,
    VT_FIXED_LEG_CONVENTION = 18,
    VT_FIXED_LEG_DAY_COUNTER = 20,
    VT_QUOTE_ID = 22
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  const ::flatbuffers::String *start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_DATE);
  }
  const ::flatbuffers::String *end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END_DATE);
  }
  quantra::enums::OvernightIndex overnight_index() const {
    return static_cast<quantra::enums::OvernightIndex>(GetField<int8_t>(VT_OVERNIGHT_INDEX, 0));
  }
  const quantra::OvernightIndexSpec *overnight_index_spec() const {
    return GetPointer<const quantra::OvernightIndexSpec *>(VT_OVERNIGHT_INDEX_SPEC);
  }
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 2);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 32));
  }
  quantra::enums::BusinessDayConvention fixed_leg_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_FIXED_LEG_CONVENTION, 2));
  }
  quantra::enums::DayCounter fixed_leg_day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_FIXED_LEG_DAY_COUNTER, 0));
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyOffsetRequired(verifier, VT_START_DATE) &&
           verifier.VerifyString(start_date()) &&
           VerifyOffsetRequired(verifier, VT_END_DATE) &&
           verifier.VerifyString(end_date()) &&
           VerifyField<int8_t>(verifier, VT_OVERNIGHT_INDEX, 1) &&
           VerifyOffset(verifier, VT_OVERNIGHT_INDEX_SPEC) &&
           verifier.VerifyTable(overnight_index_spec()) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_LEG_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_LEG_DAY_COUNTER, 1) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  DatedOISHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DatedOISHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DatedOISHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DatedOISHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DatedOISHelperBuilder {
  typedef DatedOISHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(DatedOISHelper::VT_RATE, rate, 0.0);
  }
  void add_start_date(::flatbuffers::Offset<::flatbuffers::String> start_date) {
    fbb_.AddOffset(DatedOISHelper::VT_START_DATE, start_date);
  }
  void add_end_date(::flatbuffers::Offset<::flatbuffers::String> end_date) {
    fbb_.AddOffset(DatedOISHelper::VT_END_DATE, end_date);
  }
  void add_overnight_index(quantra::enums::OvernightIndex overnight_index) {
    fbb_.AddElement<int8_t>(DatedOISHelper::VT_OVERNIGHT_INDEX, static_cast<int8_t>(overnight_index), 0);
  }
  void add_overnight_index_spec(::flatbuffers::Offset<quantra::OvernightIndexSpec> overnight_index_spec) {
    fbb_.AddOffset(DatedOISHelper::VT_OVERNIGHT_INDEX_SPEC, overnight_index_spec);
  }
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(DatedOISHelper::VT_SETTLEMENT_DAYS, settlement_days, 2);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(DatedOISHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 32);
  }
  void add_fixed_leg_convention(quantra::enums::BusinessDayConvention fixed_leg_convention) {
    fbb_.AddElement<int8_t>(DatedOISHelper::VT_FIXED_LEG_CONVENTION, static_cast<int8_t>(fixed_leg_convention), 2);
  }
  void add_fixed_leg_day_counter(quantra::enums::DayCounter fixed_leg_day_counter) {
    fbb_.AddElement<int8_t>(DatedOISHelper::VT_FIXED_LEG_DAY_COUNTER, static_cast<int8_t>(fixed_leg_day_counter), 0);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(DatedOISHelper::VT_QUOTE_ID, quote_id);
  }
  explicit DatedOISHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DatedOISHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DatedOISHelper>(end);
    fbb_.Required(o, DatedOISHelper::VT_START_DATE);
    fbb_.Required(o, DatedOISHelper::VT_END_DATE);
    return o;
  }
};

inline ::flatbuffers::Offset<DatedOISHelper> CreateDatedOISHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> end_date = 0,
    quantra::enums::OvernightIndex overnight_index = quantra::enums::OvernightIndex_SOFR,
    ::flatbuffers::Offset<quantra::OvernightIndexSpec> overnight_index_spec = 0,
    int32_t settlement_days = 2,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::BusinessDayConvention fixed_leg_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::DayCounter fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  DatedOISHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_quote_id(quote_id);
  builder_.add_settlement_days(settlement_days);
  builder_.add_overnight_index_spec(overnight_index_spec);
  builder_.add_end_date(end_date);
  builder_.add_start_date(start_date);
  builder_.add_fixed_leg_day_counter(fixed_leg_day_counter);
  builder_.add_fixed_leg_convention(fixed_leg_convention);
  builder_.add_calendar(calendar);
  builder_.add_overnight_index(overnight_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DatedOISHelper> CreateDatedOISHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    const char *start_date = nullptr,
    const char *end_date = nullptr,
    quantra::enums::OvernightIndex overnight_index = quantra::enums::OvernightIndex_SOFR,
    ::flatbuffers::Offset<quantra::OvernightIndexSpec> overnight_index_spec = 0,
    int32_t settlement_days = 2,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::BusinessDayConvention fixed_leg_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::DayCounter fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    const char *quote_id = nullptr) {
  auto start_date__ = start_date ? _fbb.CreateString(start_date) : 0;
  auto end_date__ = end_date ? _fbb.CreateString(end_date) : 0;
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateDatedOISHelper(
      _fbb,
      rate,
      start_date__,
      end_date__,
      overnight_index,
      overnight_index_spec,
      settlement_days,
      calendar,
      fixed_leg_convention,
      fixed_leg_day_counter,
      quote_id__);
}

::flatbuffers::Offset<DatedOISHelper> CreateDatedOISHelper(::flatbuffers::FlatBufferBuilder &_fbb, const DatedOISHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TenorBasisSwapHelperT : public ::flatbuffers::NativeTable {
  typedef TenorBasisSwapHelper TableType;
  double spread = 0.0;
  int32_t tenor_number = 0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  quantra::enums::Ibor index_short = quantra::enums::Ibor_Euribor10M;
  quantra::enums::Ibor index_long = quantra::enums::Ibor_Euribor10M;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina;
  std::unique_ptr<quantra::HelperDependenciesT> deps{};
  std::string quote_id{};
  TenorBasisSwapHelperT() = default;
  TenorBasisSwapHelperT(const TenorBasisSwapHelperT &o);
  TenorBasisSwapHelperT(TenorBasisSwapHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  TenorBasisSwapHelperT &operator=(TenorBasisSwapHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct TenorBasisSwapHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TenorBasisSwapHelperT NativeTableType;
  typedef TenorBasisSwapHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPREAD = 4,
    VT_TENOR_NUMBER = 6,
    VT_TENOR_TIME_UNIT = 8,
    VT_INDEX_SHORT = 10,
    VT_INDEX_LONG = 12,
    VT_CALENDAR = 14,
    VT_DEPS = 16,
    VT_QUOTE_ID = 18
  };
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  quantra::enums::Ibor index_short() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_INDEX_SHORT, 0));
  }
  quantra::enums::Ibor index_long() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_INDEX_LONG, 0));
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  const quantra::HelperDependencies *deps() const {
    return GetPointer<const quantra::HelperDependencies *>(VT_DEPS);
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int8_t>(verifier, VT_INDEX_SHORT, 1) &&
           VerifyField<int8_t>(verifier, VT_INDEX_LONG, 1) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyOffset(verifier, VT_DEPS) &&
           verifier.VerifyTable(deps()) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  TenorBasisSwapHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TenorBasisSwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TenorBasisSwapHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorBasisSwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TenorBasisSwapHelperBuilder {
  typedef TenorBasisSwapHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_spread(double spread) {
    fbb_.AddElement<double>(TenorBasisSwapHelper::VT_SPREAD, spread, 0.0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(TenorBasisSwapHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(TenorBasisSwapHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_index_short(quantra::enums::Ibor index_short) {
    fbb_.AddElement<int8_t>(TenorBasisSwapHelper::VT_INDEX_SHORT, static_cast<int8_t>(index_short), 0);
  }
  void add_index_long(quantra::enums::Ibor index_long) {
    fbb_.AddElement<int8_t>(TenorBasisSwapHelper::VT_INDEX_LONG, static_cast<int8_t>(index_long), 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(TenorBasisSwapHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_deps(::flatbuffers::Offset<quantra::HelperDependencies> deps) {
    fbb_.AddOffset(TenorBasisSwapHelper::VT_DEPS, deps);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(TenorBasisSwapHelper::VT_QUOTE_ID, quote_id);
  }
  explicit TenorBasisSwapHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TenorBasisSwapHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TenorBasisSwapHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TenorBasisSwapHelper> CreateTenorBasisSwapHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double spread = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    quantra::enums::Ibor index_short = quantra::enums::Ibor_Euribor10M,
    quantra::enums::Ibor index_long = quantra::enums::Ibor_Euribor10M,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  TenorBasisSwapHelperBuilder builder_(_fbb);
  builder_.add_spread(spread);
  builder_.add_quote_id(quote_id);
  builder_.add_deps(deps);
  builder_.add_tenor_number(tenor_number);
  builder_.add_calendar(calendar);
  builder_.add_index_long(index_long);
  builder_.add_index_short(index_short);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TenorBasisSwapHelper> CreateTenorBasisSwapHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double spread = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    quantra::enums::Ibor index_short = quantra::enums::Ibor_Euribor10M,
    quantra::enums::Ibor index_long = quantra::enums::Ibor_Euribor10M,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    const char *quote_id = nullptr) {
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateTenorBasisSwapHelper(
      _fbb,
      spread,
      tenor_number,
      tenor_time_unit,
      index_short,
      index_long,
      calendar,
      deps,
      quote_id__);
}

::flatbuffers::Offset<TenorBasisSwapHelper> CreateTenorBasisSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const TenorBasisSwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FxSwapHelperT : public ::flatbuffers::NativeTable {
  typedef FxSwapHelper TableType;
  double fx_points = 0.0;
  int32_t tenor_number = 0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  int32_t spot_days = 2;
  quantra::enums::Calendar calendar_domestic = quantra::enums::Calendar_TARGET;
  quantra::enums::Calendar calendar_foreign = quantra::enums::Calendar_TARGET;
  std::unique_ptr<quantra::HelperDependenciesT> deps{};
  std::string quote_id{};
  FxSwapHelperT() = default;
  FxSwapHelperT(const FxSwapHelperT &o);
  FxSwapHelperT(FxSwapHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  FxSwapHelperT &operator=(FxSwapHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct FxSwapHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FxSwapHelperT NativeTableType;
  typedef FxSwapHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FX_POINTS = 4,
    VT_TENOR_NUMBER = 6,
    VT_TENOR_TIME_UNIT = 8,
    VT_SPOT_DAYS = 10,
    VT_CALENDAR_DOMESTIC = 12,
    VT_CALENDAR_FOREIGN = 14,
    VT_DEPS = 16,
    VT_QUOTE_ID = 18
  };
  double fx_points() const {
    return GetField<double>(VT_FX_POINTS, 0.0);
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t spot_days() const {
    return GetField<int32_t>(VT_SPOT_DAYS, 2);
  }
  quantra::enums::Calendar calendar_domestic() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR_DOMESTIC, 32));
  }
  quantra::enums::Calendar calendar_foreign() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR_FOREIGN, 32));
  }
  const quantra::HelperDependencies *deps() const {
    return GetPointer<const quantra::HelperDependencies *>(VT_DEPS);
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_FX_POINTS, 8) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_SPOT_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR_DOMESTIC, 1) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR_FOREIGN, 1) &&
           VerifyOffset(verifier, VT_DEPS) &&
           verifier.VerifyTable(deps()) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  FxSwapHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FxSwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FxSwapHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FxSwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FxSwapHelperBuilder {
  typedef FxSwapHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fx_points(double fx_points) {
    fbb_.AddElement<double>(FxSwapHelper::VT_FX_POINTS, fx_points, 0.0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(FxSwapHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(FxSwapHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_spot_days(int32_t spot_days) {
    fbb_.AddElement<int32_t>(FxSwapHelper::VT_SPOT_DAYS, spot_days, 2);
  }
  void add_calendar_domestic(quantra::enums::Calendar calendar_domestic) {
    fbb_.AddElement<int8_t>(FxSwapHelper::VT_CALENDAR_DOMESTIC, static_cast<int8_t>(calendar_domestic), 32);
  }
  void add_calendar_foreign(quantra::enums::Calendar calendar_foreign) {
    fbb_.AddElement<int8_t>(FxSwapHelper::VT_CALENDAR_FOREIGN, static_cast<int8_t>(calendar_foreign), 32);
  }
  void add_deps(::flatbuffers::Offset<quantra::HelperDependencies> deps) {
    fbb_.AddOffset(FxSwapHelper::VT_DEPS, deps);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(FxSwapHelper::VT_QUOTE_ID, quote_id);
  }
  explicit FxSwapHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FxSwapHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FxSwapHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FxSwapHelper> CreateFxSwapHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double fx_points = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t spot_days = 2,
    quantra::enums::Calendar calendar_domestic = quantra::enums::Calendar_TARGET,
    quantra::enums::Calendar calendar_foreign = quantra::enums::Calendar_TARGET,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  FxSwapHelperBuilder builder_(_fbb);
  builder_.add_fx_points(fx_points);
  builder_.add_quote_id(quote_id);
  builder_.add_deps(deps);
  builder_.add_spot_days(spot_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_calendar_foreign(calendar_foreign);
  builder_.add_calendar_domestic(calendar_domestic);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FxSwapHelper> CreateFxSwapHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double fx_points = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t spot_days = 2,
    quantra::enums::Calendar calendar_domestic = quantra::enums::Calendar_TARGET,
    quantra::enums::Calendar calendar_foreign = quantra::enums::Calendar_TARGET,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    const char *quote_id = nullptr) {
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateFxSwapHelper(
      _fbb,
      fx_points,
      tenor_number,
      tenor_time_unit,
      spot_days,
      calendar_domestic,
      calendar_foreign,
      deps,
      quote_id__);
}

::flatbuffers::Offset<FxSwapHelper> CreateFxSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FxSwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CrossCcyBasisHelperT : public ::flatbuffers::NativeTable {
  typedef CrossCcyBasisHelper TableType;
  double spread = 0.0;
  int32_t tenor_number = 0;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days;
  quantra::enums::Ibor index_domestic = quantra::enums::Ibor_Euribor10M;
  quantra::enums::Ibor index_foreign = quantra::enums::Ibor_Euribor10M;
  std::unique_ptr<quantra::HelperDependenciesT> deps{};
  std::string quote_id{};
  CrossCcyBasisHelperT() = default;
  CrossCcyBasisHelperT(const CrossCcyBasisHelperT &o);
  CrossCcyBasisHelperT(CrossCcyBasisHelperT&&) FLATBUFFERS_NOEXCEPT = default;
  CrossCcyBasisHelperT &operator=(CrossCcyBasisHelperT o) FLATBUFFERS_NOEXCEPT;
};

struct CrossCcyBasisHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrossCcyBasisHelperT NativeTableType;
  typedef CrossCcyBasisHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPREAD = 4,
    VT_TENOR_NUMBER = 6,
    VT_TENOR_TIME_UNIT = 8,
    VT_INDEX_DOMESTIC = 10,
    VT_INDEX_FOREIGN = 12,
    VT_DEPS = 14,
    VT_QUOTE_ID = 16
  };
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  quantra::enums::Ibor index_domestic() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_INDEX_DOMESTIC, 0));
  }
  quantra::enums::Ibor index_foreign() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_INDEX_FOREIGN, 0));
  }
  const quantra::HelperDependencies *deps() const {
    return GetPointer<const quantra::HelperDependencies *>(VT_DEPS);
  }
  const ::flatbuffers::String *quote_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int8_t>(verifier, VT_INDEX_DOMESTIC, 1) &&
           VerifyField<int8_t>(verifier, VT_INDEX_FOREIGN, 1) &&
           VerifyOffset(verifier, VT_DEPS) &&
           verifier.VerifyTable(deps()) &&
           VerifyOffset(verifier, VT_QUOTE_ID) &&
           verifier.VerifyString(quote_id()) &&
           verifier.EndTable();
  }
  CrossCcyBasisHelperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CrossCcyBasisHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CrossCcyBasisHelper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrossCcyBasisHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CrossCcyBasisHelperBuilder {
  typedef CrossCcyBasisHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_spread(double spread) {
    fbb_.AddElement<double>(CrossCcyBasisHelper::VT_SPREAD, spread, 0.0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(CrossCcyBasisHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(CrossCcyBasisHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_index_domestic(quantra::enums::Ibor index_domestic) {
    fbb_.AddElement<int8_t>(CrossCcyBasisHelper::VT_INDEX_DOMESTIC, static_cast<int8_t>(index_domestic), 0);
  }
  void add_index_foreign(quantra::enums::Ibor index_foreign) {
    fbb_.AddElement<int8_t>(CrossCcyBasisHelper::VT_INDEX_FOREIGN, static_cast<int8_t>(index_foreign), 0);
  }
  void add_deps(::flatbuffers::Offset<quantra::HelperDependencies> deps) {
    fbb_.AddOffset(CrossCcyBasisHelper::VT_DEPS, deps);
  }
  void add_quote_id(::flatbuffers::Offset<::flatbuffers::String> quote_id) {
    fbb_.AddOffset(CrossCcyBasisHelper::VT_QUOTE_ID, quote_id);
  }
  explicit CrossCcyBasisHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CrossCcyBasisHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CrossCcyBasisHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CrossCcyBasisHelper> CreateCrossCcyBasisHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double spread = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    quantra::enums::Ibor index_domestic = quantra::enums::Ibor_Euribor10M,
    quantra::enums::Ibor index_foreign = quantra::enums::Ibor_Euribor10M,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    ::flatbuffers::Offset<::flatbuffers::String> quote_id = 0) {
  CrossCcyBasisHelperBuilder builder_(_fbb);
  builder_.add_spread(spread);
  builder_.add_quote_id(quote_id);
  builder_.add_deps(deps);
  builder_.add_tenor_number(tenor_number);
  builder_.add_index_foreign(index_foreign);
  builder_.add_index_domestic(index_domestic);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CrossCcyBasisHelper> CreateCrossCcyBasisHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double spread = 0.0,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    quantra::enums::Ibor index_domestic = quantra::enums::Ibor_Euribor10M,
    quantra::enums::Ibor index_foreign = quantra::enums::Ibor_Euribor10M,
    ::flatbuffers::Offset<quantra::HelperDependencies> deps = 0,
    const char *quote_id = nullptr) {
  auto quote_id__ = quote_id ? _fbb.CreateString(quote_id) : 0;
  return quantra::CreateCrossCcyBasisHelper(
      _fbb,
      spread,
      tenor_number,
      tenor_time_unit,
      index_domestic,
      index_foreign,
      deps,
      quote_id__);
}

::flatbuffers::Offset<CrossCcyBasisHelper> CreateCrossCcyBasisHelper(::flatbuffers::FlatBufferBuilder &_fbb, const CrossCcyBasisHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointsWrapperT : public ::flatbuffers::NativeTable {
  typedef PointsWrapper TableType;
  quantra::PointUnion point{};
};

struct PointsWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointsWrapperT NativeTableType;
  typedef PointsWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINT_TYPE = 4,
    VT_POINT = 6
  };
  quantra::Point point_type() const {
    return static_cast<quantra::Point>(GetField<uint8_t>(VT_POINT_TYPE, 0));
  }
  const void *point() const {
    return GetPointer<const void *>(VT_POINT);
  }
  template<typename T> const T *point_as() const;
  const quantra::DepositHelper *point_as_DepositHelper() const {
    return point_type() == quantra::Point_DepositHelper ? static_cast<const quantra::DepositHelper *>(point()) : nullptr;
  }
  const quantra::FRAHelper *point_as_FRAHelper() const {
    return point_type() == quantra::Point_FRAHelper ? static_cast<const quantra::FRAHelper *>(point()) : nullptr;
  }
  const quantra::FutureHelper *point_as_FutureHelper() const {
    return point_type() == quantra::Point_FutureHelper ? static_cast<const quantra::FutureHelper *>(point()) : nullptr;
  }
  const quantra::SwapHelper *point_as_SwapHelper() const {
    return point_type() == quantra::Point_SwapHelper ? static_cast<const quantra::SwapHelper *>(point()) : nullptr;
  }
  const quantra::BondHelper *point_as_BondHelper() const {
    return point_type() == quantra::Point_BondHelper ? static_cast<const quantra::BondHelper *>(point()) : nullptr;
  }
  const quantra::OISHelper *point_as_OISHelper() const {
    return point_type() == quantra::Point_OISHelper ? static_cast<const quantra::OISHelper *>(point()) : nullptr;
  }
  const quantra::DatedOISHelper *point_as_DatedOISHelper() const {
    return point_type() == quantra::Point_DatedOISHelper ? static_cast<const quantra::DatedOISHelper *>(point()) : nullptr;
  }
  const quantra::TenorBasisSwapHelper *point_as_TenorBasisSwapHelper() const {
    return point_type() == quantra::Point_TenorBasisSwapHelper ? static_cast<const quantra::TenorBasisSwapHelper *>(point()) : nullptr;
  }
  const quantra::FxSwapHelper *point_as_FxSwapHelper() const {
    return point_type() == quantra::Point_FxSwapHelper ? static_cast<const quantra::FxSwapHelper *>(point()) : nullptr;
  }
  const quantra::CrossCcyBasisHelper *point_as_CrossCcyBasisHelper() const {
    return point_type() == quantra::Point_CrossCcyBasisHelper ? static_cast<const quantra::CrossCcyBasisHelper *>(point()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POINT_TYPE, 1) &&
           VerifyOffset(verifier, VT_POINT) &&
           VerifyPoint(verifier, point(), point_type()) &&
           verifier.EndTable();
  }
  PointsWrapperT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PointsWrapper> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::DepositHelper *PointsWrapper::point_as<quantra::DepositHelper>() const {
  return point_as_DepositHelper();
}

template<> inline const quantra::FRAHelper *PointsWrapper::point_as<quantra::FRAHelper>() const {
  return point_as_FRAHelper();
}

template<> inline const quantra::FutureHelper *PointsWrapper::point_as<quantra::FutureHelper>() const {
  return point_as_FutureHelper();
}

template<> inline const quantra::SwapHelper *PointsWrapper::point_as<quantra::SwapHelper>() const {
  return point_as_SwapHelper();
}

template<> inline const quantra::BondHelper *PointsWrapper::point_as<quantra::BondHelper>() const {
  return point_as_BondHelper();
}

template<> inline const quantra::OISHelper *PointsWrapper::point_as<quantra::OISHelper>() const {
  return point_as_OISHelper();
}

template<> inline const quantra::DatedOISHelper *PointsWrapper::point_as<quantra::DatedOISHelper>() const {
  return point_as_DatedOISHelper();
}

template<> inline const quantra::TenorBasisSwapHelper *PointsWrapper::point_as<quantra::TenorBasisSwapHelper>() const {
  return point_as_TenorBasisSwapHelper();
}

template<> inline const quantra::FxSwapHelper *PointsWrapper::point_as<quantra::FxSwapHelper>() const {
  return point_as_FxSwapHelper();
}

template<> inline const quantra::CrossCcyBasisHelper *PointsWrapper::point_as<quantra::CrossCcyBasisHelper>() const {
  return point_as_CrossCcyBasisHelper();
}

struct PointsWrapperBuilder {
  typedef PointsWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_point_type(quantra::Point point_type) {
    fbb_.AddElement<uint8_t>(PointsWrapper::VT_POINT_TYPE, static_cast<uint8_t>(point_type), 0);
  }
  void add_point(::flatbuffers::Offset<void> point) {
    fbb_.AddOffset(PointsWrapper::VT_POINT, point);
  }
  explicit PointsWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointsWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointsWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointsWrapper> CreatePointsWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::Point point_type = quantra::Point_NONE,
    ::flatbuffers::Offset<void> point = 0) {
  PointsWrapperBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_point_type(point_type);
  return builder_.Finish();
}

::flatbuffers::Offset<PointsWrapper> CreatePointsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TermStructureT : public ::flatbuffers::NativeTable {
  typedef TermStructure TableType;
  std::string id{};
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360;
  quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat;
  quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount;
  std::vector<std::unique_ptr<quantra::PointsWrapperT>> points{};
  std::string reference_date{};
  TermStructureT() = default;
  TermStructureT(const TermStructureT &o);
  TermStructureT(TermStructureT&&) FLATBUFFERS_NOEXCEPT = default;
  TermStructureT &operator=(TermStructureT o) FLATBUFFERS_NOEXCEPT;
};

struct TermStructure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TermStructureT NativeTableType;
  typedef TermStructureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DAY_COUNTER = 6,
    VT_INTERPOLATOR = 8,
    VT_BOOTSTRAP_TRAIT = 10,
    VT_POINTS = 12,
    VT_REFERENCE_DATE = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Interpolator interpolator() const {
    return static_cast<quantra::enums::Interpolator>(GetField<int8_t>(VT_INTERPOLATOR, 0));
  }
  quantra::enums::BootstrapTrait bootstrap_trait() const {
    return static_cast<quantra::enums::BootstrapTrait>(GetField<int8_t>(VT_BOOTSTRAP_TRAIT, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>> *>(VT_POINTS);
  }
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_INTERPOLATOR, 1) &&
           VerifyField<int8_t>(verifier, VT_BOOTSTRAP_TRAIT, 1) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           verifier.EndTable();
  }
  TermStructureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TermStructureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TermStructure> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TermStructureBuilder {
  typedef TermStructure Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TermStructure::VT_ID, id);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(TermStructure::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_interpolator(quantra::enums::Interpolator interpolator) {
    fbb_.AddElement<int8_t>(TermStructure::VT_INTERPOLATOR, static_cast<int8_t>(interpolator), 0);
  }
  void add_bootstrap_trait(quantra::enums::BootstrapTrait bootstrap_trait) {
    fbb_.AddElement<int8_t>(TermStructure::VT_BOOTSTRAP_TRAIT, static_cast<int8_t>(bootstrap_trait), 0);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>>> points) {
    fbb_.AddOffset(TermStructure::VT_POINTS, points);
  }
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(TermStructure::VT_REFERENCE_DATE, reference_date);
  }
  explicit TermStructureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TermStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TermStructure>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TermStructure> CreateTermStructure(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0) {
  TermStructureBuilder builder_(_fbb);
  builder_.add_reference_date(reference_date);
  builder_.add_points(points);
  builder_.add_id(id);
  builder_.add_bootstrap_trait(bootstrap_trait);
  builder_.add_interpolator(interpolator);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TermStructure> CreateTermStructureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    const std::vector<::flatbuffers::Offset<quantra::PointsWrapper>> *points = nullptr,
    const char *reference_date = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<quantra::PointsWrapper>>(*points) : 0;
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  return quantra::CreateTermStructure(
      _fbb,
      id__,
      day_counter,
      interpolator,
      bootstrap_trait,
      points__,
      reference_date__);
}

::flatbuffers::Offset<TermStructure> CreateTermStructure(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline IborIndexSpecT *IborIndexSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IborIndexSpecT>(new IborIndexSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IborIndexSpec::UnPackTo(IborIndexSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = family(); _o->family = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = fixing_days(); _o->fixing_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = end_of_month(); _o->end_of_month = _e; }
}

inline ::flatbuffers::Offset<IborIndexSpec> IborIndexSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IborIndexSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIborIndexSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IborIndexSpec> CreateIborIndexSpec(::flatbuffers::FlatBufferBuilder &_fbb, const IborIndexSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IborIndexSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _family = _o->family;
  auto _tenor_number = _o->tenor_number;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _fixing_days = _o->fixing_days;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  auto _end_of_month = _o->end_of_month;
  return quantra::CreateIborIndexSpec(
      _fbb,
      _family,
      _tenor_number,
      _tenor_time_unit,
      _fixing_days,
      _calendar,
      _business_day_convention,
      _day_counter,
      _end_of_month);
}

inline OvernightIndexSpecT *OvernightIndexSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OvernightIndexSpecT>(new OvernightIndexSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OvernightIndexSpec::UnPackTo(OvernightIndexSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); _o->name = _e; }
  { auto _e = fixing_days(); _o->fixing_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
}

inline ::flatbuffers::Offset<OvernightIndexSpec> OvernightIndexSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OvernightIndexSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOvernightIndexSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OvernightIndexSpec> CreateOvernightIndexSpec(::flatbuffers::FlatBufferBuilder &_fbb, const OvernightIndexSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OvernightIndexSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name;
  auto _fixing_days = _o->fixing_days;
  auto _calendar = _o->calendar;
  auto _day_counter = _o->day_counter;
  return quantra::CreateOvernightIndexSpec(
      _fbb,
      _name,
      _fixing_days,
      _calendar,
      _day_counter);
}

inline CurveRefT *CurveRef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CurveRefT>(new CurveRefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CurveRef::UnPackTo(CurveRefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<CurveRef> CurveRef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCurveRef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CurveRef> CreateCurveRef(::flatbuffers::FlatBufferBuilder &_fbb, const CurveRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CurveRefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return quantra::CreateCurveRef(
      _fbb,
      _id);
}

inline HelperDependenciesT::HelperDependenciesT(const HelperDependenciesT &o)
      : discount_curve((o.discount_curve) ? new quantra::CurveRefT(*o.discount_curve) : nullptr),
        projection_curve((o.projection_curve) ? new quantra::CurveRefT(*o.projection_curve) : nullptr),
        projection_curve_2((o.projection_curve_2) ? new quantra::CurveRefT(*o.projection_curve_2) : nullptr),
        fx_spot_quote_id(o.fx_spot_quote_id) {
}

inline HelperDependenciesT &HelperDependenciesT::operator=(HelperDependenciesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(discount_curve, o.discount_curve);
  std::swap(projection_curve, o.projection_curve);
  std::swap(projection_curve_2, o.projection_curve_2);
  std::swap(fx_spot_quote_id, o.fx_spot_quote_id);
  return *this;
}

inline HelperDependenciesT *HelperDependencies::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HelperDependenciesT>(new HelperDependenciesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HelperDependencies::UnPackTo(HelperDependenciesT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = discount_curve(); if (_e) { if(_o->discount_curve) { _e->UnPackTo(_o->discount_curve.get(), _resolver); } else { _o->discount_curve = std::unique_ptr<quantra::CurveRefT>(_e->UnPack(_resolver)); } } else if (_o->discount_curve) { _o->discount_curve.reset(); } }
  { auto _e = projection_curve(); if (_e) { if(_o->projection_curve) { _e->UnPackTo(_o->projection_curve.get(), _resolver); } else { _o->projection_curve = std::unique_ptr<quantra::CurveRefT>(_e->UnPack(_resolver)); } } else if (_o->projection_curve) { _o->projection_curve.reset(); } }
  { auto _e = projection_curve_2(); if (_e) { if(_o->projection_curve_2) { _e->UnPackTo(_o->projection_curve_2.get(), _resolver); } else { _o->projection_curve_2 = std::unique_ptr<quantra::CurveRefT>(_e->UnPack(_resolver)); } } else if (_o->projection_curve_2) { _o->projection_curve_2.reset(); } }
  { auto _e = fx_spot_quote_id(); if (_e) _o->fx_spot_quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<HelperDependencies> HelperDependencies::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HelperDependenciesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHelperDependencies(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HelperDependencies> CreateHelperDependencies(::flatbuffers::FlatBufferBuilder &_fbb, const HelperDependenciesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HelperDependenciesT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _discount_curve = _o->discount_curve ? CreateCurveRef(_fbb, _o->discount_curve.get(), _rehasher) : 0;
  auto _projection_curve = _o->projection_curve ? CreateCurveRef(_fbb, _o->projection_curve.get(), _rehasher) : 0;
  auto _projection_curve_2 = _o->projection_curve_2 ? CreateCurveRef(_fbb, _o->projection_curve_2.get(), _rehasher) : 0;
  auto _fx_spot_quote_id = _o->fx_spot_quote_id.empty() ? 0 : _fbb.CreateString(_o->fx_spot_quote_id);
  return quantra::CreateHelperDependencies(
      _fbb,
      _discount_curve,
      _projection_curve,
      _projection_curve_2,
      _fx_spot_quote_id);
}

inline FixingT *Fixing::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FixingT>(new FixingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Fixing::UnPackTo(FixingT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = date(); if (_e) _o->date = _e->str(); }
  { auto _e = value(); _o->value = _e; }
}

inline ::flatbuffers::Offset<Fixing> Fixing::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FixingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFixing(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Fixing> CreateFixing(::flatbuffers::FlatBufferBuilder &_fbb, const FixingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FixingT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _date = _fbb.CreateString(_o->date);
  auto _value = _o->value;
  return quantra::CreateFixing(
      _fbb,
      _date,
      _value);
}

inline IndexFixingsT::IndexFixingsT(const IndexFixingsT &o)
      : index_id(o.index_id) {
  fixings.reserve(o.fixings.size());
  for (const auto &fixings_ : o.fixings) { fixings.emplace_back((fixings_) ? new quantra::FixingT(*fixings_) : nullptr); }
}

inline IndexFixingsT &IndexFixingsT::operator=(IndexFixingsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(index_id, o.index_id);
  std::swap(fixings, o.fixings);
  return *this;
}

inline IndexFixingsT *IndexFixings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IndexFixingsT>(new IndexFixingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IndexFixings::UnPackTo(IndexFixingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index_id(); if (_e) _o->index_id = _e->str(); }
  { auto _e = fixings(); if (_e) { _o->fixings.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->fixings[_i]) { _e->Get(_i)->UnPackTo(_o->fixings[_i].get(), _resolver); } else { _o->fixings[_i] = std::unique_ptr<quantra::FixingT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->fixings.resize(0); } }
}

inline ::flatbuffers::Offset<IndexFixings> IndexFixings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IndexFixingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIndexFixings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IndexFixings> CreateIndexFixings(::flatbuffers::FlatBufferBuilder &_fbb, const IndexFixingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IndexFixingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index_id = _fbb.CreateString(_o->index_id);
  auto _fixings = _fbb.CreateVector<::flatbuffers::Offset<quantra::Fixing>> (_o->fixings.size(), [](size_t i, _VectorArgs *__va) { return CreateFixing(*__va->__fbb, __va->__o->fixings[i].get(), __va->__rehasher); }, &_va );
  return quantra::CreateIndexFixings(
      _fbb,
      _index_id,
      _fixings);
}

inline DepositHelperT *DepositHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DepositHelperT>(new DepositHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DepositHelper::UnPackTo(DepositHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = fixing_days(); _o->fixing_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<DepositHelper> DepositHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDepositHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DepositHelper> CreateDepositHelper(::flatbuffers::FlatBufferBuilder &_fbb, const DepositHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DepositHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _tenor_number = _o->tenor_number;
  auto _fixing_days = _o->fixing_days;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateDepositHelper(
      _fbb,
      _rate,
      _tenor_time_unit,
      _tenor_number,
      _fixing_days,
      _calendar,
      _business_day_convention,
      _day_counter,
      _quote_id);
}

inline FRAHelperT *FRAHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FRAHelperT>(new FRAHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FRAHelper::UnPackTo(FRAHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = months_to_start(); _o->months_to_start = _e; }
  { auto _e = months_to_end(); _o->months_to_end = _e; }
  { auto _e = fixing_days(); _o->fixing_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<FRAHelper> FRAHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFRAHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FRAHelper> CreateFRAHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FRAHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FRAHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _months_to_start = _o->months_to_start;
  auto _months_to_end = _o->months_to_end;
  auto _fixing_days = _o->fixing_days;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateFRAHelper(
      _fbb,
      _rate,
      _months_to_start,
      _months_to_end,
      _fixing_days,
      _calendar,
      _business_day_convention,
      _day_counter,
      _quote_id);
}

inline FutureHelperT *FutureHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FutureHelperT>(new FutureHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FutureHelper::UnPackTo(FutureHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = future_start_date(); if (_e) _o->future_start_date = _e->str(); }
  { auto _e = future_months(); _o->future_months = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = futures_price(); _o->futures_price = _e; }
  { auto _e = convexity_adjustment(); _o->convexity_adjustment = _e; }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<FutureHelper> FutureHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFutureHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FutureHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FutureHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _future_start_date = _o->future_start_date.empty() ? 0 : _fbb.CreateString(_o->future_start_date);
  auto _future_months = _o->future_months;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _day_counter = _o->day_counter;
  auto _futures_price = _o->futures_price;
  auto _convexity_adjustment = _o->convexity_adjustment;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateFutureHelper(
      _fbb,
      _rate,
      _future_start_date,
      _future_months,
      _calendar,
      _business_day_convention,
      _day_counter,
      _futures_price,
      _convexity_adjustment,
      _quote_id);
}

inline SwapHelperT::SwapHelperT(const SwapHelperT &o)
      : rate(o.rate),
        tenor_time_unit(o.tenor_time_unit),
        tenor_number(o.tenor_number),
        calendar(o.calendar),
        sw_fixed_leg_frequency(o.sw_fixed_leg_frequency),
        sw_fixed_leg_convention(o.sw_fixed_leg_convention),
        sw_fixed_leg_day_counter(o.sw_fixed_leg_day_counter),
        sw_floating_leg_index(o.sw_floating_leg_index),
        float_index(o.float_index),
        spread(o.spread),
        fwd_start_days(o.fwd_start_days),
        deps((o.deps) ? new quantra::HelperDependenciesT(*o.deps) : nullptr),
        quote_id(o.quote_id) {
}

inline SwapHelperT &SwapHelperT::operator=(SwapHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(rate, o.rate);
  std::swap(tenor_time_unit, o.tenor_time_unit);
  std::swap(tenor_number, o.tenor_number);
  std::swap(calendar, o.calendar);
  std::swap(sw_fixed_leg_frequency, o.sw_fixed_leg_frequency);
  std::swap(sw_fixed_leg_convention, o.sw_fixed_leg_convention);
  std::swap(sw_fixed_leg_day_counter, o.sw_fixed_leg_day_counter);
  std::swap(sw_floating_leg_index, o.sw_floating_leg_index);
  std::swap(float_index, o.float_index);
  std::swap(spread, o.spread);
  std::swap(fwd_start_days, o.fwd_start_days);
  std::swap(deps, o.deps);
  std::swap(quote_id, o.quote_id);
  return *this;
}

inline SwapHelperT *SwapHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapHelperT>(new SwapHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapHelper::UnPackTo(SwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = sw_fixed_leg_frequency(); _o->sw_fixed_leg_frequency = _e; }
  { auto _e = sw_fixed_leg_convention(); _o->sw_fixed_leg_convention = _e; }
  { auto _e = sw_fixed_leg_day_counter(); _o->sw_fixed_leg_day_counter = _e; }
  { auto _e = sw_floating_leg_index(); _o->sw_floating_leg_index = _e; }
  { auto _e = float_index_type(); _o->float_index.type = _e; }
  { auto _e = float_index(); if (_e) _o->float_index.value = quantra::IndexSpecUnion::UnPack(_e, float_index_type(), _resolver); }
  { auto _e = spread(); _o->spread = _e; }
  { auto _e = fwd_start_days(); _o->fwd_start_days = _e; }
  { auto _e = deps(); if (_e) { if(_o->deps) { _e->UnPackTo(_o->deps.get(), _resolver); } else { _o->deps = std::unique_ptr<quantra::HelperDependenciesT>(_e->UnPack(_resolver)); } } else if (_o->deps) { _o->deps.reset(); } }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<SwapHelper> SwapHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapHelper> CreateSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const SwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _tenor_number = _o->tenor_number;
  auto _calendar = _o->calendar;
  auto _sw_fixed_leg_frequency = _o->sw_fixed_leg_frequency;
  auto _sw_fixed_leg_convention = _o->sw_fixed_leg_convention;
  auto _sw_fixed_leg_day_counter = _o->sw_fixed_leg_day_counter;
  auto _sw_floating_leg_index = _o->sw_floating_leg_index;
  auto _float_index_type = _o->float_index.type;
  auto _float_index = _o->float_index.Pack(_fbb);
  auto _spread = _o->spread;
  auto _fwd_start_days = _o->fwd_start_days;
  auto _deps = _o->deps ? CreateHelperDependencies(_fbb, _o->deps.get(), _rehasher) : 0;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateSwapHelper(
      _fbb,
      _rate,
      _tenor_time_unit,
      _tenor_number,
      _calendar,
      _sw_fixed_leg_frequency,
      _sw_fixed_leg_convention,
      _sw_fixed_leg_day_counter,
      _sw_floating_leg_index,
      _float_index_type,
      _float_index,
      _spread,
      _fwd_start_days,
      _deps,
      _quote_id);
}

inline BondHelperT::BondHelperT(const BondHelperT &o)
      : rate(o.rate),
        settlement_days(o.settlement_days),
        face_amount(o.face_amount),
        schedule((o.schedule) ? new quantra::ScheduleT(*o.schedule) : nullptr),
        coupon_rate(o.coupon_rate),
        day_counter(o.day_counter),
        business_day_convention(o.business_day_convention),
        redemption(o.redemption),
        issue_date(o.issue_date),
        price(o.price),
        quote_id(o.quote_id) {
}

inline BondHelperT &BondHelperT::operator=(BondHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(rate, o.rate);
  std::swap(settlement_days, o.settlement_days);
  std::swap(face_amount, o.face_amount);
  std::swap(schedule, o.schedule);
  std::swap(coupon_rate, o.coupon_rate);
  std::swap(day_counter, o.day_counter);
  std::swap(business_day_convention, o.business_day_convention);
  std::swap(redemption, o.redemption);
  std::swap(issue_date, o.issue_date);
  std::swap(price, o.price);
  std::swap(quote_id, o.quote_id);
  return *this;
}

inline BondHelperT *BondHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BondHelperT>(new BondHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BondHelper::UnPackTo(BondHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = settlement_days(); _o->settlement_days = _e; }
  { auto _e = face_amount(); _o->face_amount = _e; }
  { auto _e = schedule(); if (_e) { if(_o->schedule) { _e->UnPackTo(_o->schedule.get(), _resolver); } else { _o->schedule = std::unique_ptr<quantra::ScheduleT>(_e->UnPack(_resolver)); } } else if (_o->schedule) { _o->schedule.reset(); } }
  { auto _e = coupon_rate(); _o->coupon_rate = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = redemption(); _o->redemption = _e; }
  { auto _e = issue_date(); if (_e) _o->issue_date = _e->str(); }
  { auto _e = price(); _o->price = _e; }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<BondHelper> BondHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBondHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BondHelper> CreateBondHelper(::flatbuffers::FlatBufferBuilder &_fbb, const BondHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BondHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _settlement_days = _o->settlement_days;
  auto _face_amount = _o->face_amount;
  auto _schedule = _o->schedule ? CreateSchedule(_fbb, _o->schedule.get(), _rehasher) : 0;
  auto _coupon_rate = _o->coupon_rate;
  auto _day_counter = _o->day_counter;
  auto _business_day_convention = _o->business_day_convention;
  auto _redemption = _o->redemption;
  auto _issue_date = _o->issue_date.empty() ? 0 : _fbb.CreateString(_o->issue_date);
  auto _price = _o->price;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateBondHelper(
      _fbb,
      _rate,
      _settlement_days,
      _face_amount,
      _schedule,
      _coupon_rate,
      _day_counter,
      _business_day_convention,
      _redemption,
      _issue_date,
      _price,
      _quote_id);
}

inline OISHelperT::OISHelperT(const OISHelperT &o)
      : rate(o.rate),
        tenor_number(o.tenor_number),
        tenor_time_unit(o.tenor_time_unit),
        overnight_index(o.overnight_index),
        overnight_index_spec((o.overnight_index_spec) ? new quantra::OvernightIndexSpecT(*o.overnight_index_spec) : nullptr),
        settlement_days(o.settlement_days),
        calendar(o.calendar),
        fixed_leg_frequency(o.fixed_leg_frequency),
        fixed_leg_convention(o.fixed_leg_convention),
        fixed_leg_day_counter(o.fixed_leg_day_counter),
        quote_id(o.quote_id) {
}

inline OISHelperT &OISHelperT::operator=(OISHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(rate, o.rate);
  std::swap(tenor_number, o.tenor_number);
  std::swap(tenor_time_unit, o.tenor_time_unit);
  std::swap(overnight_index, o.overnight_index);
  std::swap(overnight_index_spec, o.overnight_index_spec);
  std::swap(settlement_days, o.settlement_days);
  std::swap(calendar, o.calendar);
  std::swap(fixed_leg_frequency, o.fixed_leg_frequency);
  std::swap(fixed_leg_convention, o.fixed_leg_convention);
  std::swap(fixed_leg_day_counter, o.fixed_leg_day_counter);
  std::swap(quote_id, o.quote_id);
  return *this;
}

inline OISHelperT *OISHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OISHelperT>(new OISHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OISHelper::UnPackTo(OISHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = overnight_index(); _o->overnight_index = _e; }
  { auto _e = overnight_index_spec(); if (_e) { if(_o->overnight_index_spec) { _e->UnPackTo(_o->overnight_index_spec.get(), _resolver); } else { _o->overnight_index_spec = std::unique_ptr<quantra::OvernightIndexSpecT>(_e->UnPack(_resolver)); } } else if (_o->overnight_index_spec) { _o->overnight_index_spec.reset(); } }
  { auto _e = settlement_days(); _o->settlement_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = fixed_leg_frequency(); _o->fixed_leg_frequency = _e; }
  { auto _e = fixed_leg_convention(); _o->fixed_leg_convention = _e; }
  { auto _e = fixed_leg_day_counter(); _o->fixed_leg_day_counter = _e; }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<OISHelper> OISHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OISHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOISHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OISHelper> CreateOISHelper(::flatbuffers::FlatBufferBuilder &_fbb, const OISHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OISHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _tenor_number = _o->tenor_number;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _overnight_index = _o->overnight_index;
  auto _overnight_index_spec = _o->overnight_index_spec ? CreateOvernightIndexSpec(_fbb, _o->overnight_index_spec.get(), _rehasher) : 0;
  auto _settlement_days = _o->settlement_days;
  auto _calendar = _o->calendar;
  auto _fixed_leg_frequency = _o->fixed_leg_frequency;
  auto _fixed_leg_convention = _o->fixed_leg_convention;
  auto _fixed_leg_day_counter = _o->fixed_leg_day_counter;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateOISHelper(
      _fbb,
      _rate,
      _tenor_number,
      _tenor_time_unit,
      _overnight_index,
      _overnight_index_spec,
      _settlement_days,
      _calendar,
      _fixed_leg_frequency,
      _fixed_leg_convention,
      _fixed_leg_day_counter,
      _quote_id);
}

inline DatedOISHelperT::DatedOISHelperT(const DatedOISHelperT &o)
      : rate(o.rate),
        start_date(o.start_date),
        end_date(o.end_date),
        overnight_index(o.overnight_index),
        overnight_index_spec((o.overnight_index_spec) ? new quantra::OvernightIndexSpecT(*o.overnight_index_spec) : nullptr),
        settlement_days(o.settlement_days),
        calendar(o.calendar),
        fixed_leg_convention(o.fixed_leg_convention),
        fixed_leg_day_counter(o.fixed_leg_day_counter),
        quote_id(o.quote_id) {
}

inline DatedOISHelperT &DatedOISHelperT::operator=(DatedOISHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(rate, o.rate);
  std::swap(start_date, o.start_date);
  std::swap(end_date, o.end_date);
  std::swap(overnight_index, o.overnight_index);
  std::swap(overnight_index_spec, o.overnight_index_spec);
  std::swap(settlement_days, o.settlement_days);
  std::swap(calendar, o.calendar);
  std::swap(fixed_leg_convention, o.fixed_leg_convention);
  std::swap(fixed_leg_day_counter, o.fixed_leg_day_counter);
  std::swap(quote_id, o.quote_id);
  return *this;
}

inline DatedOISHelperT *DatedOISHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DatedOISHelperT>(new DatedOISHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DatedOISHelper::UnPackTo(DatedOISHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = start_date(); if (_e) _o->start_date = _e->str(); }
  { auto _e = end_date(); if (_e) _o->end_date = _e->str(); }
  { auto _e = overnight_index(); _o->overnight_index = _e; }
  { auto _e = overnight_index_spec(); if (_e) { if(_o->overnight_index_spec) { _e->UnPackTo(_o->overnight_index_spec.get(), _resolver); } else { _o->overnight_index_spec = std::unique_ptr<quantra::OvernightIndexSpecT>(_e->UnPack(_resolver)); } } else if (_o->overnight_index_spec) { _o->overnight_index_spec.reset(); } }
  { auto _e = settlement_days(); _o->settlement_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = fixed_leg_convention(); _o->fixed_leg_convention = _e; }
  { auto _e = fixed_leg_day_counter(); _o->fixed_leg_day_counter = _e; }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<DatedOISHelper> DatedOISHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DatedOISHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDatedOISHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DatedOISHelper> CreateDatedOISHelper(::flatbuffers::FlatBufferBuilder &_fbb, const DatedOISHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DatedOISHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rate = _o->rate;
  auto _start_date = _fbb.CreateString(_o->start_date);
  auto _end_date = _fbb.CreateString(_o->end_date);
  auto _overnight_index = _o->overnight_index;
  auto _overnight_index_spec = _o->overnight_index_spec ? CreateOvernightIndexSpec(_fbb, _o->overnight_index_spec.get(), _rehasher) : 0;
  auto _settlement_days = _o->settlement_days;
  auto _calendar = _o->calendar;
  auto _fixed_leg_convention = _o->fixed_leg_convention;
  auto _fixed_leg_day_counter = _o->fixed_leg_day_counter;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateDatedOISHelper(
      _fbb,
      _rate,
      _start_date,
      _end_date,
      _overnight_index,
      _overnight_index_spec,
      _settlement_days,
      _calendar,
      _fixed_leg_convention,
      _fixed_leg_day_counter,
      _quote_id);
}

inline TenorBasisSwapHelperT::TenorBasisSwapHelperT(const TenorBasisSwapHelperT &o)
      : spread(o.spread),
        tenor_number(o.tenor_number),
        tenor_time_unit(o.tenor_time_unit),
        index_short(o.index_short),
        index_long(o.index_long),
        calendar(o.calendar),
        deps((o.deps) ? new quantra::HelperDependenciesT(*o.deps) : nullptr),
        quote_id(o.quote_id) {
}

inline TenorBasisSwapHelperT &TenorBasisSwapHelperT::operator=(TenorBasisSwapHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(spread, o.spread);
  std::swap(tenor_number, o.tenor_number);
  std::swap(tenor_time_unit, o.tenor_time_unit);
  std::swap(index_short, o.index_short);
  std::swap(index_long, o.index_long);
  std::swap(calendar, o.calendar);
  std::swap(deps, o.deps);
  std::swap(quote_id, o.quote_id);
  return *this;
}

inline TenorBasisSwapHelperT *TenorBasisSwapHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TenorBasisSwapHelperT>(new TenorBasisSwapHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TenorBasisSwapHelper::UnPackTo(TenorBasisSwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = spread(); _o->spread = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = index_short(); _o->index_short = _e; }
  { auto _e = index_long(); _o->index_long = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = deps(); if (_e) { if(_o->deps) { _e->UnPackTo(_o->deps.get(), _resolver); } else { _o->deps = std::unique_ptr<quantra::HelperDependenciesT>(_e->UnPack(_resolver)); } } else if (_o->deps) { _o->deps.reset(); } }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<TenorBasisSwapHelper> TenorBasisSwapHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorBasisSwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTenorBasisSwapHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TenorBasisSwapHelper> CreateTenorBasisSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const TenorBasisSwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TenorBasisSwapHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _spread = _o->spread;
  auto _tenor_number = _o->tenor_number;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _index_short = _o->index_short;
  auto _index_long = _o->index_long;
  auto _calendar = _o->calendar;
  auto _deps = _o->deps ? CreateHelperDependencies(_fbb, _o->deps.get(), _rehasher) : 0;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateTenorBasisSwapHelper(
      _fbb,
      _spread,
      _tenor_number,
      _tenor_time_unit,
      _index_short,
      _index_long,
      _calendar,
      _deps,
      _quote_id);
}

inline FxSwapHelperT::FxSwapHelperT(const FxSwapHelperT &o)
      : fx_points(o.fx_points),
        tenor_number(o.tenor_number),
        tenor_time_unit(o.tenor_time_unit),
        spot_days(o.spot_days),
        calendar_domestic(o.calendar_domestic),
        calendar_foreign(o.calendar_foreign),
        deps((o.deps) ? new quantra::HelperDependenciesT(*o.deps) : nullptr),
        quote_id(o.quote_id) {
}

inline FxSwapHelperT &FxSwapHelperT::operator=(FxSwapHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(fx_points, o.fx_points);
  std::swap(tenor_number, o.tenor_number);
  std::swap(tenor_time_unit, o.tenor_time_unit);
  std::swap(spot_days, o.spot_days);
  std::swap(calendar_domestic, o.calendar_domestic);
  std::swap(calendar_foreign, o.calendar_foreign);
  std::swap(deps, o.deps);
  std::swap(quote_id, o.quote_id);
  return *this;
}

inline FxSwapHelperT *FxSwapHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FxSwapHelperT>(new FxSwapHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FxSwapHelper::UnPackTo(FxSwapHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fx_points(); _o->fx_points = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = spot_days(); _o->spot_days = _e; }
  { auto _e = calendar_domestic(); _o->calendar_domestic = _e; }
  { auto _e = calendar_foreign(); _o->calendar_foreign = _e; }
  { auto _e = deps(); if (_e) { if(_o->deps) { _e->UnPackTo(_o->deps.get(), _resolver); } else { _o->deps = std::unique_ptr<quantra::HelperDependenciesT>(_e->UnPack(_resolver)); } } else if (_o->deps) { _o->deps.reset(); } }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<FxSwapHelper> FxSwapHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FxSwapHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFxSwapHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FxSwapHelper> CreateFxSwapHelper(::flatbuffers::FlatBufferBuilder &_fbb, const FxSwapHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FxSwapHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fx_points = _o->fx_points;
  auto _tenor_number = _o->tenor_number;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _spot_days = _o->spot_days;
  auto _calendar_domestic = _o->calendar_domestic;
  auto _calendar_foreign = _o->calendar_foreign;
  auto _deps = _o->deps ? CreateHelperDependencies(_fbb, _o->deps.get(), _rehasher) : 0;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateFxSwapHelper(
      _fbb,
      _fx_points,
      _tenor_number,
      _tenor_time_unit,
      _spot_days,
      _calendar_domestic,
      _calendar_foreign,
      _deps,
      _quote_id);
}

inline CrossCcyBasisHelperT::CrossCcyBasisHelperT(const CrossCcyBasisHelperT &o)
      : spread(o.spread),
        tenor_number(o.tenor_number),
        tenor_time_unit(o.tenor_time_unit),
        index_domestic(o.index_domestic),
        index_foreign(o.index_foreign),
        deps((o.deps) ? new quantra::HelperDependenciesT(*o.deps) : nullptr),
        quote_id(o.quote_id) {
}

inline CrossCcyBasisHelperT &CrossCcyBasisHelperT::operator=(CrossCcyBasisHelperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(spread, o.spread);
  std::swap(tenor_number, o.tenor_number);
  std::swap(tenor_time_unit, o.tenor_time_unit);
  std::swap(index_domestic, o.index_domestic);
  std::swap(index_foreign, o.index_foreign);
  std::swap(deps, o.deps);
  std::swap(quote_id, o.quote_id);
  return *this;
}

inline CrossCcyBasisHelperT *CrossCcyBasisHelper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CrossCcyBasisHelperT>(new CrossCcyBasisHelperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CrossCcyBasisHelper::UnPackTo(CrossCcyBasisHelperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = spread(); _o->spread = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = index_domestic(); _o->index_domestic = _e; }
  { auto _e = index_foreign(); _o->index_foreign = _e; }
  { auto _e = deps(); if (_e) { if(_o->deps) { _e->UnPackTo(_o->deps.get(), _resolver); } else { _o->deps = std::unique_ptr<quantra::HelperDependenciesT>(_e->UnPack(_resolver)); } } else if (_o->deps) { _o->deps.reset(); } }
  { auto _e = quote_id(); if (_e) _o->quote_id = _e->str(); }
}

inline ::flatbuffers::Offset<CrossCcyBasisHelper> CrossCcyBasisHelper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrossCcyBasisHelperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrossCcyBasisHelper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CrossCcyBasisHelper> CreateCrossCcyBasisHelper(::flatbuffers::FlatBufferBuilder &_fbb, const CrossCcyBasisHelperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CrossCcyBasisHelperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _spread = _o->spread;
  auto _tenor_number = _o->tenor_number;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _index_domestic = _o->index_domestic;
  auto _index_foreign = _o->index_foreign;
  auto _deps = _o->deps ? CreateHelperDependencies(_fbb, _o->deps.get(), _rehasher) : 0;
  auto _quote_id = _o->quote_id.empty() ? 0 : _fbb.CreateString(_o->quote_id);
  return quantra::CreateCrossCcyBasisHelper(
      _fbb,
      _spread,
      _tenor_number,
      _tenor_time_unit,
      _index_domestic,
      _index_foreign,
      _deps,
      _quote_id);
}

inline PointsWrapperT *PointsWrapper::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PointsWrapperT>(new PointsWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointsWrapper::UnPackTo(PointsWrapperT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = point_type(); _o->point.type = _e; }
  { auto _e = point(); if (_e) _o->point.value = quantra::PointUnion::UnPack(_e, point_type(), _resolver); }
}

inline ::flatbuffers::Offset<PointsWrapper> PointsWrapper::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointsWrapper(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PointsWrapper> CreatePointsWrapper(::flatbuffers::FlatBufferBuilder &_fbb, const PointsWrapperT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PointsWrapperT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _point_type = _o->point.type;
  auto _point = _o->point.Pack(_fbb);
  return quantra::CreatePointsWrapper(
      _fbb,
      _point_type,
      _point);
}

inline TermStructureT::TermStructureT(const TermStructureT &o)
      : id(o.id),
        day_counter(o.day_counter),
        interpolator(o.interpolator),
        bootstrap_trait(o.bootstrap_trait),
        reference_date(o.reference_date) {
  points.reserve(o.points.size());
  for (const auto &points_ : o.points) { points.emplace_back((points_) ? new quantra::PointsWrapperT(*points_) : nullptr); }
}

inline TermStructureT &TermStructureT::operator=(TermStructureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(day_counter, o.day_counter);
  std::swap(interpolator, o.interpolator);
  std::swap(bootstrap_trait, o.bootstrap_trait);
  std::swap(points, o.points);
  std::swap(reference_date, o.reference_date);
  return *this;
}

inline TermStructureT *TermStructure::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TermStructureT>(new TermStructureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TermStructure::UnPackTo(TermStructureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = interpolator(); _o->interpolator = _e; }
  { auto _e = bootstrap_trait(); _o->bootstrap_trait = _e; }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->points[_i]) { _e->Get(_i)->UnPackTo(_o->points[_i].get(), _resolver); } else { _o->points[_i] = std::unique_ptr<quantra::PointsWrapperT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->points.resize(0); } }
  { auto _e = reference_date(); if (_e) _o->reference_date = _e->str(); }
}

inline ::flatbuffers::Offset<TermStructure> TermStructure::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTermStructure(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TermStructure> CreateTermStructure(::flatbuffers::FlatBufferBuilder &_fbb, const TermStructureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TermStructureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _day_counter = _o->day_counter;
  auto _interpolator = _o->interpolator;
  auto _bootstrap_trait = _o->bootstrap_trait;
  auto _points = _o->points.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::PointsWrapper>> (_o->points.size(), [](size_t i, _VectorArgs *__va) { return CreatePointsWrapper(*__va->__fbb, __va->__o->points[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _reference_date = _o->reference_date.empty() ? 0 : _fbb.CreateString(_o->reference_date);
  return quantra::CreateTermStructure(
      _fbb,
      _id,
      _day_counter,
      _interpolator,
      _bootstrap_trait,
      _points,
      _reference_date);
}

inline bool VerifyIndexSpec(::flatbuffers::Verifier &verifier, const void *obj, IndexSpec type) {
  switch (type) {
    case IndexSpec_NONE: {
      return true;
    }
    case IndexSpec_IborIndexSpec: {
      auto ptr = reinterpret_cast<const quantra::IborIndexSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IndexSpec_OvernightIndexSpec: {
      auto ptr = reinterpret_cast<const quantra::OvernightIndexSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyIndexSpecVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyIndexSpec(
        verifier,  values->Get(i), types->GetEnum<IndexSpec>(i))) {
      return false;
    }
  }
  return true;
}

inline void *IndexSpecUnion::UnPack(const void *obj, IndexSpec type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case IndexSpec_IborIndexSpec: {
      auto ptr = reinterpret_cast<const quantra::IborIndexSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case IndexSpec_OvernightIndexSpec: {
      auto ptr = reinterpret_cast<const quantra::OvernightIndexSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> IndexSpecUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case IndexSpec_IborIndexSpec: {
      auto ptr = reinterpret_cast<const quantra::IborIndexSpecT *>(value);
      return CreateIborIndexSpec(_fbb, ptr, _rehasher).Union();
    }
    case IndexSpec_OvernightIndexSpec: {
      auto ptr = reinterpret_cast<const quantra::OvernightIndexSpecT *>(value);
      return CreateOvernightIndexSpec(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline IndexSpecUnion::IndexSpecUnion(const IndexSpecUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case IndexSpec_IborIndexSpec: {
      value = new quantra::IborIndexSpecT(*reinterpret_cast<quantra::IborIndexSpecT *>(u.value));
      break;
    }
    case IndexSpec_OvernightIndexSpec: {
      value = new quantra::OvernightIndexSpecT(*reinterpret_cast<quantra::OvernightIndexSpecT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void IndexSpecUnion::Reset() {
  switch (type) {
    case IndexSpec_IborIndexSpec: {
      auto ptr = reinterpret_cast<quantra::IborIndexSpecT *>(value);
      delete ptr;
      break;
    }
    case IndexSpec_OvernightIndexSpec: {
      auto ptr = reinterpret_cast<quantra::OvernightIndexSpecT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = IndexSpec_NONE;
}

inline bool VerifyPoint(::flatbuffers::Verifier &verifier, const void *obj, Point type) {
  switch (type) {
    case Point_NONE: {
      return true;
    }
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<const quantra::DepositHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<const quantra::FRAHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<const quantra::FutureHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<const quantra::SwapHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<const quantra::BondHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_OISHelper: {
      auto ptr = reinterpret_cast<const quantra::OISHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_DatedOISHelper: {
      auto ptr = reinterpret_cast<const quantra::DatedOISHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_TenorBasisSwapHelper: {
      auto ptr = reinterpret_cast<const quantra::TenorBasisSwapHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FxSwapHelper: {
      auto ptr = reinterpret_cast<const quantra::FxSwapHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_CrossCcyBasisHelper: {
      auto ptr = reinterpret_cast<const quantra::CrossCcyBasisHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPointVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPoint(
        verifier,  values->Get(i), types->GetEnum<Point>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PointUnion::UnPack(const void *obj, Point type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<const quantra::DepositHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<const quantra::FRAHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<const quantra::FutureHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<const quantra::SwapHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<const quantra::BondHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_OISHelper: {
      auto ptr = reinterpret_cast<const quantra::OISHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_DatedOISHelper: {
      auto ptr = reinterpret_cast<const quantra::DatedOISHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_TenorBasisSwapHelper: {
      auto ptr = reinterpret_cast<const quantra::TenorBasisSwapHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_FxSwapHelper: {
      auto ptr = reinterpret_cast<const quantra::FxSwapHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    case Point_CrossCcyBasisHelper: {
      auto ptr = reinterpret_cast<const quantra::CrossCcyBasisHelper *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> PointUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<const quantra::DepositHelperT *>(value);
      return CreateDepositHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<const quantra::FRAHelperT *>(value);
      return CreateFRAHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<const quantra::FutureHelperT *>(value);
      return CreateFutureHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<const quantra::SwapHelperT *>(value);
      return CreateSwapHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<const quantra::BondHelperT *>(value);
      return CreateBondHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_OISHelper: {
      auto ptr = reinterpret_cast<const quantra::OISHelperT *>(value);
      return CreateOISHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_DatedOISHelper: {
      auto ptr = reinterpret_cast<const quantra::DatedOISHelperT *>(value);
      return CreateDatedOISHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_TenorBasisSwapHelper: {
      auto ptr = reinterpret_cast<const quantra::TenorBasisSwapHelperT *>(value);
      return CreateTenorBasisSwapHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_FxSwapHelper: {
      auto ptr = reinterpret_cast<const quantra::FxSwapHelperT *>(value);
      return CreateFxSwapHelper(_fbb, ptr, _rehasher).Union();
    }
    case Point_CrossCcyBasisHelper: {
      auto ptr = reinterpret_cast<const quantra::CrossCcyBasisHelperT *>(value);
      return CreateCrossCcyBasisHelper(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PointUnion::PointUnion(const PointUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Point_DepositHelper: {
      value = new quantra::DepositHelperT(*reinterpret_cast<quantra::DepositHelperT *>(u.value));
      break;
    }
    case Point_FRAHelper: {
      value = new quantra::FRAHelperT(*reinterpret_cast<quantra::FRAHelperT *>(u.value));
      break;
    }
    case Point_FutureHelper: {
      value = new quantra::FutureHelperT(*reinterpret_cast<quantra::FutureHelperT *>(u.value));
      break;
    }
    case Point_SwapHelper: {
      value = new quantra::SwapHelperT(*reinterpret_cast<quantra::SwapHelperT *>(u.value));
      break;
    }
    case Point_BondHelper: {
      value = new quantra::BondHelperT(*reinterpret_cast<quantra::BondHelperT *>(u.value));
      break;
    }
    case Point_OISHelper: {
      value = new quantra::OISHelperT(*reinterpret_cast<quantra::OISHelperT *>(u.value));
      break;
    }
    case Point_DatedOISHelper: {
      value = new quantra::DatedOISHelperT(*reinterpret_cast<quantra::DatedOISHelperT *>(u.value));
      break;
    }
    case Point_TenorBasisSwapHelper: {
      value = new quantra::TenorBasisSwapHelperT(*reinterpret_cast<quantra::TenorBasisSwapHelperT *>(u.value));
      break;
    }
    case Point_FxSwapHelper: {
      value = new quantra::FxSwapHelperT(*reinterpret_cast<quantra::FxSwapHelperT *>(u.value));
      break;
    }
    case Point_CrossCcyBasisHelper: {
      value = new quantra::CrossCcyBasisHelperT(*reinterpret_cast<quantra::CrossCcyBasisHelperT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PointUnion::Reset() {
  switch (type) {
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<quantra::DepositHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<quantra::FRAHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<quantra::FutureHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<quantra::SwapHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<quantra::BondHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_OISHelper: {
      auto ptr = reinterpret_cast<quantra::OISHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_DatedOISHelper: {
      auto ptr = reinterpret_cast<quantra::DatedOISHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_TenorBasisSwapHelper: {
      auto ptr = reinterpret_cast<quantra::TenorBasisSwapHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_FxSwapHelper: {
      auto ptr = reinterpret_cast<quantra::FxSwapHelperT *>(value);
      delete ptr;
      break;
    }
    case Point_CrossCcyBasisHelper: {
      auto ptr = reinterpret_cast<quantra::CrossCcyBasisHelperT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Point_NONE;
}

inline const quantra::TermStructure *GetTermStructure(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::TermStructure>(buf);
}

inline const quantra::TermStructure *GetSizePrefixedTermStructure(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::TermStructure>(buf);
}

inline bool VerifyTermStructureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::TermStructure>(nullptr);
}

inline bool VerifySizePrefixedTermStructureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::TermStructure>(nullptr);
}

inline void FinishTermStructureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::TermStructure> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTermStructureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::TermStructure> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<quantra::TermStructureT> UnPackTermStructure(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::TermStructureT>(GetTermStructure(buf)->UnPack(res));
}

inline std::unique_ptr<quantra::TermStructureT> UnPackSizePrefixedTermStructure(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::TermStructureT>(GetSizePrefixedTermStructure(buf)->UnPack(res));
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_TERMSTRUCTURE_QUANTRA_H_
