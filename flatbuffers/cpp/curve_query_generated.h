// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CURVEQUERY_QUANTRA_H_
#define FLATBUFFERS_GENERATED_CURVEQUERY_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"
#include "enums_generated.h"

namespace quantra {

struct TenorGrid;
struct TenorGridBuilder;
struct TenorGridT;

struct RangeGrid;
struct RangeGridBuilder;
struct RangeGridT;

struct DateGridSpec;
struct DateGridSpecBuilder;
struct DateGridSpecT;

struct QueryOptions;
struct QueryOptionsBuilder;
struct QueryOptionsT;

struct ZeroRateQuery;
struct ZeroRateQueryBuilder;
struct ZeroRateQueryT;

struct ForwardRateQuery;
struct ForwardRateQueryBuilder;
struct ForwardRateQueryT;

struct CurveQuerySpec;
struct CurveQuerySpecBuilder;
struct CurveQuerySpecT;

/// What output you want sampled from a curve.
enum CurveMeasure : int8_t {
  /// Discount factor P(t)
  CurveMeasure_DF = 0,
  /// Zero rate z(t)
  CurveMeasure_ZERO = 1,
  /// Forward rate f(t) or F(d1,d2)
  CurveMeasure_FWD = 2,
  CurveMeasure_MIN = CurveMeasure_DF,
  CurveMeasure_MAX = CurveMeasure_FWD
};

inline const CurveMeasure (&EnumValuesCurveMeasure())[3] {
  static const CurveMeasure values[] = {
    CurveMeasure_DF,
    CurveMeasure_ZERO,
    CurveMeasure_FWD
  };
  return values;
}

inline const char * const *EnumNamesCurveMeasure() {
  static const char * const names[4] = {
    "DF",
    "ZERO",
    "FWD",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurveMeasure(CurveMeasure e) {
  if (::flatbuffers::IsOutRange(e, CurveMeasure_DF, CurveMeasure_FWD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurveMeasure()[index];
}

/// Forward rate definition.
enum ForwardType : int8_t {
  /// Approximated instantaneous forward around d
  ForwardType_Instantaneous = 0,
  /// Forward over [d, d + tenor]
  ForwardType_Period = 1,
  ForwardType_MIN = ForwardType_Instantaneous,
  ForwardType_MAX = ForwardType_Period
};

inline const ForwardType (&EnumValuesForwardType())[2] {
  static const ForwardType values[] = {
    ForwardType_Instantaneous,
    ForwardType_Period
  };
  return values;
}

inline const char * const *EnumNamesForwardType() {
  static const char * const names[3] = {
    "Instantaneous",
    "Period",
    nullptr
  };
  return names;
}

inline const char *EnumNameForwardType(ForwardType e) {
  if (::flatbuffers::IsOutRange(e, ForwardType_Instantaneous, ForwardType_Period)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesForwardType()[index];
}

enum DateGrid : uint8_t {
  DateGrid_NONE = 0,
  DateGrid_TenorGrid = 1,
  DateGrid_RangeGrid = 2,
  DateGrid_MIN = DateGrid_NONE,
  DateGrid_MAX = DateGrid_RangeGrid
};

inline const DateGrid (&EnumValuesDateGrid())[3] {
  static const DateGrid values[] = {
    DateGrid_NONE,
    DateGrid_TenorGrid,
    DateGrid_RangeGrid
  };
  return values;
}

inline const char * const *EnumNamesDateGrid() {
  static const char * const names[4] = {
    "NONE",
    "TenorGrid",
    "RangeGrid",
    nullptr
  };
  return names;
}

inline const char *EnumNameDateGrid(DateGrid e) {
  if (::flatbuffers::IsOutRange(e, DateGrid_NONE, DateGrid_RangeGrid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDateGrid()[index];
}

template<typename T> struct DateGridTraits {
  static const DateGrid enum_value = DateGrid_NONE;
};

template<> struct DateGridTraits<quantra::TenorGrid> {
  static const DateGrid enum_value = DateGrid_TenorGrid;
};

template<> struct DateGridTraits<quantra::RangeGrid> {
  static const DateGrid enum_value = DateGrid_RangeGrid;
};

template<typename T> struct DateGridUnionTraits {
  static const DateGrid enum_value = DateGrid_NONE;
};

template<> struct DateGridUnionTraits<quantra::TenorGridT> {
  static const DateGrid enum_value = DateGrid_TenorGrid;
};

template<> struct DateGridUnionTraits<quantra::RangeGridT> {
  static const DateGrid enum_value = DateGrid_RangeGrid;
};

struct DateGridUnion {
  DateGrid type;
  void *value;

  DateGridUnion() : type(DateGrid_NONE), value(nullptr) {}
  DateGridUnion(DateGridUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(DateGrid_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  DateGridUnion(const DateGridUnion &);
  DateGridUnion &operator=(const DateGridUnion &u)
    { DateGridUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  DateGridUnion &operator=(DateGridUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~DateGridUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = DateGridUnionTraits<RT>::enum_value;
    if (type != DateGrid_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, DateGrid type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::TenorGridT *AsTenorGrid() {
    return type == DateGrid_TenorGrid ?
      reinterpret_cast<quantra::TenorGridT *>(value) : nullptr;
  }
  const quantra::TenorGridT *AsTenorGrid() const {
    return type == DateGrid_TenorGrid ?
      reinterpret_cast<const quantra::TenorGridT *>(value) : nullptr;
  }
  quantra::RangeGridT *AsRangeGrid() {
    return type == DateGrid_RangeGrid ?
      reinterpret_cast<quantra::RangeGridT *>(value) : nullptr;
  }
  const quantra::RangeGridT *AsRangeGrid() const {
    return type == DateGrid_RangeGrid ?
      reinterpret_cast<const quantra::RangeGridT *>(value) : nullptr;
  }
};

bool VerifyDateGrid(::flatbuffers::Verifier &verifier, const void *obj, DateGrid type);
bool VerifyDateGridVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct TenorGridT : public ::flatbuffers::NativeTable {
  typedef TenorGrid TableType;
  std::vector<std::unique_ptr<quantra::PeriodT>> tenors{};
  quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  TenorGridT() = default;
  TenorGridT(const TenorGridT &o);
  TenorGridT(TenorGridT&&) FLATBUFFERS_NOEXCEPT = default;
  TenorGridT &operator=(TenorGridT o) FLATBUFFERS_NOEXCEPT;
};

/// Tenors relative to a curve reference date.
struct TenorGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TenorGridT NativeTableType;
  typedef TenorGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENORS = 4,
    VT_CALENDAR = 6,
    VT_BUSINESS_DAY_CONVENTION = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>> *tenors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>> *>(VT_TENORS);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 21));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENORS) &&
           verifier.VerifyVector(tenors()) &&
           verifier.VerifyVectorOfTables(tenors()) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           verifier.EndTable();
  }
  TenorGridT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TenorGridT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TenorGrid> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TenorGridBuilder {
  typedef TenorGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tenors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>>> tenors) {
    fbb_.AddOffset(TenorGrid::VT_TENORS, tenors);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(TenorGrid::VT_CALENDAR, static_cast<int8_t>(calendar), 21);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(TenorGrid::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  explicit TenorGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TenorGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TenorGrid>(end);
    fbb_.Required(o, TenorGrid::VT_TENORS);
    return o;
  }
};

inline ::flatbuffers::Offset<TenorGrid> CreateTenorGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>>> tenors = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  TenorGridBuilder builder_(_fbb);
  builder_.add_tenors(tenors);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TenorGrid> CreateTenorGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::Period>> *tenors = nullptr,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  auto tenors__ = tenors ? _fbb.CreateVector<::flatbuffers::Offset<quantra::Period>>(*tenors) : 0;
  return quantra::CreateTenorGrid(
      _fbb,
      tenors__,
      calendar,
      business_day_convention);
}

::flatbuffers::Offset<TenorGrid> CreateTenorGrid(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeGridT : public ::flatbuffers::NativeTable {
  typedef RangeGrid TableType;
  std::string start_date{};
  std::string end_date{};
  int32_t step_number = 1;
  quantra::enums::TimeUnit step_time_unit = quantra::enums::TimeUnit_Days;
  bool business_days_only = false;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
};

/// Sample a curve between start/end with a step.
struct RangeGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeGridT NativeTableType;
  typedef RangeGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_DATE = 4,
    VT_END_DATE = 6,
    VT_STEP_NUMBER = 8,
    VT_STEP_TIME_UNIT = 10,
    VT_BUSINESS_DAYS_ONLY = 12,
    VT_CALENDAR = 14,
    VT_BUSINESS_DAY_CONVENTION = 16
  };
  const ::flatbuffers::String *start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_DATE);
  }
  const ::flatbuffers::String *end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END_DATE);
  }
  int32_t step_number() const {
    return GetField<int32_t>(VT_STEP_NUMBER, 1);
  }
  quantra::enums::TimeUnit step_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_STEP_TIME_UNIT, 0));
  }
  bool business_days_only() const {
    return GetField<uint8_t>(VT_BUSINESS_DAYS_ONLY, 0) != 0;
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 21));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_START_DATE) &&
           verifier.VerifyString(start_date()) &&
           VerifyOffsetRequired(verifier, VT_END_DATE) &&
           verifier.VerifyString(end_date()) &&
           VerifyField<int32_t>(verifier, VT_STEP_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_STEP_TIME_UNIT, 1) &&
           VerifyField<uint8_t>(verifier, VT_BUSINESS_DAYS_ONLY, 1) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           verifier.EndTable();
  }
  RangeGridT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeGridT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RangeGrid> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeGridBuilder {
  typedef RangeGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_date(::flatbuffers::Offset<::flatbuffers::String> start_date) {
    fbb_.AddOffset(RangeGrid::VT_START_DATE, start_date);
  }
  void add_end_date(::flatbuffers::Offset<::flatbuffers::String> end_date) {
    fbb_.AddOffset(RangeGrid::VT_END_DATE, end_date);
  }
  void add_step_number(int32_t step_number) {
    fbb_.AddElement<int32_t>(RangeGrid::VT_STEP_NUMBER, step_number, 1);
  }
  void add_step_time_unit(quantra::enums::TimeUnit step_time_unit) {
    fbb_.AddElement<int8_t>(RangeGrid::VT_STEP_TIME_UNIT, static_cast<int8_t>(step_time_unit), 0);
  }
  void add_business_days_only(bool business_days_only) {
    fbb_.AddElement<uint8_t>(RangeGrid::VT_BUSINESS_DAYS_ONLY, static_cast<uint8_t>(business_days_only), 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(RangeGrid::VT_CALENDAR, static_cast<int8_t>(calendar), 21);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(RangeGrid::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  explicit RangeGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RangeGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RangeGrid>(end);
    fbb_.Required(o, RangeGrid::VT_END_DATE);
    return o;
  }
};

inline ::flatbuffers::Offset<RangeGrid> CreateRangeGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> end_date = 0,
    int32_t step_number = 1,
    quantra::enums::TimeUnit step_time_unit = quantra::enums::TimeUnit_Days,
    bool business_days_only = false,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  RangeGridBuilder builder_(_fbb);
  builder_.add_step_number(step_number);
  builder_.add_end_date(end_date);
  builder_.add_start_date(start_date);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_business_days_only(business_days_only);
  builder_.add_step_time_unit(step_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RangeGrid> CreateRangeGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *start_date = nullptr,
    const char *end_date = nullptr,
    int32_t step_number = 1,
    quantra::enums::TimeUnit step_time_unit = quantra::enums::TimeUnit_Days,
    bool business_days_only = false,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  auto start_date__ = start_date ? _fbb.CreateString(start_date) : 0;
  auto end_date__ = end_date ? _fbb.CreateString(end_date) : 0;
  return quantra::CreateRangeGrid(
      _fbb,
      start_date__,
      end_date__,
      step_number,
      step_time_unit,
      business_days_only,
      calendar,
      business_day_convention);
}

::flatbuffers::Offset<RangeGrid> CreateRangeGrid(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DateGridSpecT : public ::flatbuffers::NativeTable {
  typedef DateGridSpec TableType;
  quantra::DateGridUnion grid{};
};

struct DateGridSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DateGridSpecT NativeTableType;
  typedef DateGridSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRID_TYPE = 4,
    VT_GRID = 6
  };
  quantra::DateGrid grid_type() const {
    return static_cast<quantra::DateGrid>(GetField<uint8_t>(VT_GRID_TYPE, 0));
  }
  const void *grid() const {
    return GetPointer<const void *>(VT_GRID);
  }
  template<typename T> const T *grid_as() const;
  const quantra::TenorGrid *grid_as_TenorGrid() const {
    return grid_type() == quantra::DateGrid_TenorGrid ? static_cast<const quantra::TenorGrid *>(grid()) : nullptr;
  }
  const quantra::RangeGrid *grid_as_RangeGrid() const {
    return grid_type() == quantra::DateGrid_RangeGrid ? static_cast<const quantra::RangeGrid *>(grid()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GRID_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_GRID) &&
           VerifyDateGrid(verifier, grid(), grid_type()) &&
           verifier.EndTable();
  }
  DateGridSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DateGridSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DateGridSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DateGridSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::TenorGrid *DateGridSpec::grid_as<quantra::TenorGrid>() const {
  return grid_as_TenorGrid();
}

template<> inline const quantra::RangeGrid *DateGridSpec::grid_as<quantra::RangeGrid>() const {
  return grid_as_RangeGrid();
}

struct DateGridSpecBuilder {
  typedef DateGridSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_grid_type(quantra::DateGrid grid_type) {
    fbb_.AddElement<uint8_t>(DateGridSpec::VT_GRID_TYPE, static_cast<uint8_t>(grid_type), 0);
  }
  void add_grid(::flatbuffers::Offset<void> grid) {
    fbb_.AddOffset(DateGridSpec::VT_GRID, grid);
  }
  explicit DateGridSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DateGridSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DateGridSpec>(end);
    fbb_.Required(o, DateGridSpec::VT_GRID);
    return o;
  }
};

inline ::flatbuffers::Offset<DateGridSpec> CreateDateGridSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::DateGrid grid_type = quantra::DateGrid_NONE,
    ::flatbuffers::Offset<void> grid = 0) {
  DateGridSpecBuilder builder_(_fbb);
  builder_.add_grid(grid);
  builder_.add_grid_type(grid_type);
  return builder_.Finish();
}

::flatbuffers::Offset<DateGridSpec> CreateDateGridSpec(::flatbuffers::FlatBufferBuilder &_fbb, const DateGridSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QueryOptionsT : public ::flatbuffers::NativeTable {
  typedef QueryOptions TableType;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  int32_t max_points = 50000;
  bool allow_extrapolation = true;
  bool strict = true;
};

/// Generic query options for reusable sampling endpoints.
struct QueryOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QueryOptionsT NativeTableType;
  typedef QueryOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALENDAR = 4,
    VT_BUSINESS_DAY_CONVENTION = 6,
    VT_MAX_POINTS = 8,
    VT_ALLOW_EXTRAPOLATION = 10,
    VT_STRICT = 12
  };
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 21));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  int32_t max_points() const {
    return GetField<int32_t>(VT_MAX_POINTS, 50000);
  }
  bool allow_extrapolation() const {
    return GetField<uint8_t>(VT_ALLOW_EXTRAPOLATION, 1) != 0;
  }
  bool strict() const {
    return GetField<uint8_t>(VT_STRICT, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int32_t>(verifier, VT_MAX_POINTS, 4) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_EXTRAPOLATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_STRICT, 1) &&
           verifier.EndTable();
  }
  QueryOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QueryOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<QueryOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QueryOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QueryOptionsBuilder {
  typedef QueryOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(QueryOptions::VT_CALENDAR, static_cast<int8_t>(calendar), 21);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(QueryOptions::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_max_points(int32_t max_points) {
    fbb_.AddElement<int32_t>(QueryOptions::VT_MAX_POINTS, max_points, 50000);
  }
  void add_allow_extrapolation(bool allow_extrapolation) {
    fbb_.AddElement<uint8_t>(QueryOptions::VT_ALLOW_EXTRAPOLATION, static_cast<uint8_t>(allow_extrapolation), 1);
  }
  void add_strict(bool strict) {
    fbb_.AddElement<uint8_t>(QueryOptions::VT_STRICT, static_cast<uint8_t>(strict), 1);
  }
  explicit QueryOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QueryOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QueryOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QueryOptions> CreateQueryOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    int32_t max_points = 50000,
    bool allow_extrapolation = true,
    bool strict = true) {
  QueryOptionsBuilder builder_(_fbb);
  builder_.add_max_points(max_points);
  builder_.add_strict(strict);
  builder_.add_allow_extrapolation(allow_extrapolation);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

::flatbuffers::Offset<QueryOptions> CreateQueryOptions(::flatbuffers::FlatBufferBuilder &_fbb, const QueryOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZeroRateQueryT : public ::flatbuffers::NativeTable {
  typedef ZeroRateQuery TableType;
  bool use_curve_day_counter = true;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed;
  quantra::enums::Compounding compounding = quantra::enums::Compounding_Continuous;
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
};

struct ZeroRateQuery FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZeroRateQueryT NativeTableType;
  typedef ZeroRateQueryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_CURVE_DAY_COUNTER = 4,
    VT_DAY_COUNTER = 6,
    VT_COMPOUNDING = 8,
    VT_FREQUENCY = 10
  };
  bool use_curve_day_counter() const {
    return GetField<uint8_t>(VT_USE_CURVE_DAY_COUNTER, 1) != 0;
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 1));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 1));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_CURVE_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING, 1) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           verifier.EndTable();
  }
  ZeroRateQueryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZeroRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ZeroRateQuery> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZeroRateQueryBuilder {
  typedef ZeroRateQuery Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_use_curve_day_counter(bool use_curve_day_counter) {
    fbb_.AddElement<uint8_t>(ZeroRateQuery::VT_USE_CURVE_DAY_COUNTER, static_cast<uint8_t>(use_curve_day_counter), 1);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(ZeroRateQuery::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 1);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(ZeroRateQuery::VT_COMPOUNDING, static_cast<int8_t>(compounding), 1);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(ZeroRateQuery::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  explicit ZeroRateQueryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZeroRateQuery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZeroRateQuery>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZeroRateQuery> CreateZeroRateQuery(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool use_curve_day_counter = true,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Continuous,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual) {
  ZeroRateQueryBuilder builder_(_fbb);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  builder_.add_use_curve_day_counter(use_curve_day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<ZeroRateQuery> CreateZeroRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ForwardRateQueryT : public ::flatbuffers::NativeTable {
  typedef ForwardRateQuery TableType;
  bool use_curve_day_counter = true;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed;
  quantra::enums::Compounding compounding = quantra::enums::Compounding_Simple;
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
  quantra::ForwardType forward_type = quantra::ForwardType_Instantaneous;
  int32_t instantaneous_eps_number = 1;
  quantra::enums::TimeUnit instantaneous_eps_time_unit = quantra::enums::TimeUnit_Days;
  std::unique_ptr<quantra::PeriodT> tenor{};
  bool use_grid_calendar_for_advance = true;
  ForwardRateQueryT() = default;
  ForwardRateQueryT(const ForwardRateQueryT &o);
  ForwardRateQueryT(ForwardRateQueryT&&) FLATBUFFERS_NOEXCEPT = default;
  ForwardRateQueryT &operator=(ForwardRateQueryT o) FLATBUFFERS_NOEXCEPT;
};

struct ForwardRateQuery FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ForwardRateQueryT NativeTableType;
  typedef ForwardRateQueryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_CURVE_DAY_COUNTER = 4,
    VT_DAY_COUNTER = 6,
    VT_COMPOUNDING = 8,
    VT_FREQUENCY = 10,
    VT_FORWARD_TYPE = 12,
    VT_INSTANTANEOUS_EPS_NUMBER = 14,
    VT_INSTANTANEOUS_EPS_TIME_UNIT = 16,
    VT_TENOR = 18,
    VT_USE_GRID_CALENDAR_FOR_ADVANCE = 20
  };
  bool use_curve_day_counter() const {
    return GetField<uint8_t>(VT_USE_CURVE_DAY_COUNTER, 1) != 0;
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 1));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 2));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  quantra::ForwardType forward_type() const {
    return static_cast<quantra::ForwardType>(GetField<int8_t>(VT_FORWARD_TYPE, 0));
  }
  int32_t instantaneous_eps_number() const {
    return GetField<int32_t>(VT_INSTANTANEOUS_EPS_NUMBER, 1);
  }
  quantra::enums::TimeUnit instantaneous_eps_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_INSTANTANEOUS_EPS_TIME_UNIT, 0));
  }
  const quantra::Period *tenor() const {
    return GetPointer<const quantra::Period *>(VT_TENOR);
  }
  bool use_grid_calendar_for_advance() const {
    return GetField<uint8_t>(VT_USE_GRID_CALENDAR_FOR_ADVANCE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_CURVE_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING, 1) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_FORWARD_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_INSTANTANEOUS_EPS_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_INSTANTANEOUS_EPS_TIME_UNIT, 1) &&
           VerifyOffset(verifier, VT_TENOR) &&
           verifier.VerifyTable(tenor()) &&
           VerifyField<uint8_t>(verifier, VT_USE_GRID_CALENDAR_FOR_ADVANCE, 1) &&
           verifier.EndTable();
  }
  ForwardRateQueryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ForwardRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ForwardRateQuery> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ForwardRateQueryBuilder {
  typedef ForwardRateQuery Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_use_curve_day_counter(bool use_curve_day_counter) {
    fbb_.AddElement<uint8_t>(ForwardRateQuery::VT_USE_CURVE_DAY_COUNTER, static_cast<uint8_t>(use_curve_day_counter), 1);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 1);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_COMPOUNDING, static_cast<int8_t>(compounding), 2);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  void add_forward_type(quantra::ForwardType forward_type) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_FORWARD_TYPE, static_cast<int8_t>(forward_type), 0);
  }
  void add_instantaneous_eps_number(int32_t instantaneous_eps_number) {
    fbb_.AddElement<int32_t>(ForwardRateQuery::VT_INSTANTANEOUS_EPS_NUMBER, instantaneous_eps_number, 1);
  }
  void add_instantaneous_eps_time_unit(quantra::enums::TimeUnit instantaneous_eps_time_unit) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_INSTANTANEOUS_EPS_TIME_UNIT, static_cast<int8_t>(instantaneous_eps_time_unit), 0);
  }
  void add_tenor(::flatbuffers::Offset<quantra::Period> tenor) {
    fbb_.AddOffset(ForwardRateQuery::VT_TENOR, tenor);
  }
  void add_use_grid_calendar_for_advance(bool use_grid_calendar_for_advance) {
    fbb_.AddElement<uint8_t>(ForwardRateQuery::VT_USE_GRID_CALENDAR_FOR_ADVANCE, static_cast<uint8_t>(use_grid_calendar_for_advance), 1);
  }
  explicit ForwardRateQueryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ForwardRateQuery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ForwardRateQuery>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ForwardRateQuery> CreateForwardRateQuery(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool use_curve_day_counter = true,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Simple,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual,
    quantra::ForwardType forward_type = quantra::ForwardType_Instantaneous,
    int32_t instantaneous_eps_number = 1,
    quantra::enums::TimeUnit instantaneous_eps_time_unit = quantra::enums::TimeUnit_Days,
    ::flatbuffers::Offset<quantra::Period> tenor = 0,
    bool use_grid_calendar_for_advance = true) {
  ForwardRateQueryBuilder builder_(_fbb);
  builder_.add_tenor(tenor);
  builder_.add_instantaneous_eps_number(instantaneous_eps_number);
  builder_.add_use_grid_calendar_for_advance(use_grid_calendar_for_advance);
  builder_.add_instantaneous_eps_time_unit(instantaneous_eps_time_unit);
  builder_.add_forward_type(forward_type);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  builder_.add_use_curve_day_counter(use_curve_day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<ForwardRateQuery> CreateForwardRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CurveQuerySpecT : public ::flatbuffers::NativeTable {
  typedef CurveQuerySpec TableType;
  std::string curve_id{};
  std::vector<quantra::CurveMeasure> measures{};
  std::unique_ptr<quantra::DateGridSpecT> grid{};
  std::unique_ptr<quantra::ZeroRateQueryT> zero{};
  std::unique_ptr<quantra::ForwardRateQueryT> fwd{};
  std::unique_ptr<quantra::QueryOptionsT> options{};
  CurveQuerySpecT() = default;
  CurveQuerySpecT(const CurveQuerySpecT &o);
  CurveQuerySpecT(CurveQuerySpecT&&) FLATBUFFERS_NOEXCEPT = default;
  CurveQuerySpecT &operator=(CurveQuerySpecT o) FLATBUFFERS_NOEXCEPT;
};

/// Query spec for one curve id within Pricing.curves[].
struct CurveQuerySpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurveQuerySpecT NativeTableType;
  typedef CurveQuerySpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURVE_ID = 4,
    VT_MEASURES = 6,
    VT_GRID = 8,
    VT_ZERO = 10,
    VT_FWD = 12,
    VT_OPTIONS = 14
  };
  const ::flatbuffers::String *curve_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURVE_ID);
  }
  const ::flatbuffers::Vector<int8_t> *measures() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_MEASURES);
  }
  const quantra::DateGridSpec *grid() const {
    return GetPointer<const quantra::DateGridSpec *>(VT_GRID);
  }
  const quantra::ZeroRateQuery *zero() const {
    return GetPointer<const quantra::ZeroRateQuery *>(VT_ZERO);
  }
  const quantra::ForwardRateQuery *fwd() const {
    return GetPointer<const quantra::ForwardRateQuery *>(VT_FWD);
  }
  const quantra::QueryOptions *options() const {
    return GetPointer<const quantra::QueryOptions *>(VT_OPTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CURVE_ID) &&
           verifier.VerifyString(curve_id()) &&
           VerifyOffsetRequired(verifier, VT_MEASURES) &&
           verifier.VerifyVector(measures()) &&
           VerifyOffsetRequired(verifier, VT_GRID) &&
           verifier.VerifyTable(grid()) &&
           VerifyOffset(verifier, VT_ZERO) &&
           verifier.VerifyTable(zero()) &&
           VerifyOffset(verifier, VT_FWD) &&
           verifier.VerifyTable(fwd()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           verifier.EndTable();
  }
  CurveQuerySpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CurveQuerySpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CurveQuerySpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQuerySpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CurveQuerySpecBuilder {
  typedef CurveQuerySpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_curve_id(::flatbuffers::Offset<::flatbuffers::String> curve_id) {
    fbb_.AddOffset(CurveQuerySpec::VT_CURVE_ID, curve_id);
  }
  void add_measures(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> measures) {
    fbb_.AddOffset(CurveQuerySpec::VT_MEASURES, measures);
  }
  void add_grid(::flatbuffers::Offset<quantra::DateGridSpec> grid) {
    fbb_.AddOffset(CurveQuerySpec::VT_GRID, grid);
  }
  void add_zero(::flatbuffers::Offset<quantra::ZeroRateQuery> zero) {
    fbb_.AddOffset(CurveQuerySpec::VT_ZERO, zero);
  }
  void add_fwd(::flatbuffers::Offset<quantra::ForwardRateQuery> fwd) {
    fbb_.AddOffset(CurveQuerySpec::VT_FWD, fwd);
  }
  void add_options(::flatbuffers::Offset<quantra::QueryOptions> options) {
    fbb_.AddOffset(CurveQuerySpec::VT_OPTIONS, options);
  }
  explicit CurveQuerySpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CurveQuerySpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CurveQuerySpec>(end);
    fbb_.Required(o, CurveQuerySpec::VT_CURVE_ID);
    fbb_.Required(o, CurveQuerySpec::VT_MEASURES);
    fbb_.Required(o, CurveQuerySpec::VT_GRID);
    return o;
  }
};

inline ::flatbuffers::Offset<CurveQuerySpec> CreateCurveQuerySpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> curve_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> measures = 0,
    ::flatbuffers::Offset<quantra::DateGridSpec> grid = 0,
    ::flatbuffers::Offset<quantra::ZeroRateQuery> zero = 0,
    ::flatbuffers::Offset<quantra::ForwardRateQuery> fwd = 0,
    ::flatbuffers::Offset<quantra::QueryOptions> options = 0) {
  CurveQuerySpecBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_fwd(fwd);
  builder_.add_zero(zero);
  builder_.add_grid(grid);
  builder_.add_measures(measures);
  builder_.add_curve_id(curve_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CurveQuerySpec> CreateCurveQuerySpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *curve_id = nullptr,
    const std::vector<int8_t> *measures = nullptr,
    ::flatbuffers::Offset<quantra::DateGridSpec> grid = 0,
    ::flatbuffers::Offset<quantra::ZeroRateQuery> zero = 0,
    ::flatbuffers::Offset<quantra::ForwardRateQuery> fwd = 0,
    ::flatbuffers::Offset<quantra::QueryOptions> options = 0) {
  auto curve_id__ = curve_id ? _fbb.CreateString(curve_id) : 0;
  auto measures__ = measures ? _fbb.CreateVector<int8_t>(*measures) : 0;
  return quantra::CreateCurveQuerySpec(
      _fbb,
      curve_id__,
      measures__,
      grid,
      zero,
      fwd,
      options);
}

::flatbuffers::Offset<CurveQuerySpec> CreateCurveQuerySpec(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQuerySpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TenorGridT::TenorGridT(const TenorGridT &o)
      : calendar(o.calendar),
        business_day_convention(o.business_day_convention) {
  tenors.reserve(o.tenors.size());
  for (const auto &tenors_ : o.tenors) { tenors.emplace_back((tenors_) ? new quantra::PeriodT(*tenors_) : nullptr); }
}

inline TenorGridT &TenorGridT::operator=(TenorGridT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tenors, o.tenors);
  std::swap(calendar, o.calendar);
  std::swap(business_day_convention, o.business_day_convention);
  return *this;
}

inline TenorGridT *TenorGrid::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TenorGridT>(new TenorGridT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TenorGrid::UnPackTo(TenorGridT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tenors(); if (_e) { _o->tenors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tenors[_i]) { _e->Get(_i)->UnPackTo(_o->tenors[_i].get(), _resolver); } else { _o->tenors[_i] = std::unique_ptr<quantra::PeriodT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tenors.resize(0); } }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
}

inline ::flatbuffers::Offset<TenorGrid> TenorGrid::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTenorGrid(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TenorGrid> CreateTenorGrid(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TenorGridT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tenors = _fbb.CreateVector<::flatbuffers::Offset<quantra::Period>> (_o->tenors.size(), [](size_t i, _VectorArgs *__va) { return CreatePeriod(*__va->__fbb, __va->__o->tenors[i].get(), __va->__rehasher); }, &_va );
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  return quantra::CreateTenorGrid(
      _fbb,
      _tenors,
      _calendar,
      _business_day_convention);
}

inline RangeGridT *RangeGrid::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RangeGridT>(new RangeGridT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RangeGrid::UnPackTo(RangeGridT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_date(); if (_e) _o->start_date = _e->str(); }
  { auto _e = end_date(); if (_e) _o->end_date = _e->str(); }
  { auto _e = step_number(); _o->step_number = _e; }
  { auto _e = step_time_unit(); _o->step_time_unit = _e; }
  { auto _e = business_days_only(); _o->business_days_only = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
}

inline ::flatbuffers::Offset<RangeGrid> RangeGrid::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRangeGrid(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RangeGrid> CreateRangeGrid(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RangeGridT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_date = _o->start_date.empty() ? 0 : _fbb.CreateString(_o->start_date);
  auto _end_date = _fbb.CreateString(_o->end_date);
  auto _step_number = _o->step_number;
  auto _step_time_unit = _o->step_time_unit;
  auto _business_days_only = _o->business_days_only;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  return quantra::CreateRangeGrid(
      _fbb,
      _start_date,
      _end_date,
      _step_number,
      _step_time_unit,
      _business_days_only,
      _calendar,
      _business_day_convention);
}

inline DateGridSpecT *DateGridSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DateGridSpecT>(new DateGridSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DateGridSpec::UnPackTo(DateGridSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = grid_type(); _o->grid.type = _e; }
  { auto _e = grid(); if (_e) _o->grid.value = quantra::DateGridUnion::UnPack(_e, grid_type(), _resolver); }
}

inline ::flatbuffers::Offset<DateGridSpec> DateGridSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DateGridSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDateGridSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DateGridSpec> CreateDateGridSpec(::flatbuffers::FlatBufferBuilder &_fbb, const DateGridSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DateGridSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _grid_type = _o->grid.type;
  auto _grid = _o->grid.Pack(_fbb);
  return quantra::CreateDateGridSpec(
      _fbb,
      _grid_type,
      _grid);
}

inline QueryOptionsT *QueryOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QueryOptionsT>(new QueryOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void QueryOptions::UnPackTo(QueryOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = max_points(); _o->max_points = _e; }
  { auto _e = allow_extrapolation(); _o->allow_extrapolation = _e; }
  { auto _e = strict(); _o->strict = _e; }
}

inline ::flatbuffers::Offset<QueryOptions> QueryOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const QueryOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQueryOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<QueryOptions> CreateQueryOptions(::flatbuffers::FlatBufferBuilder &_fbb, const QueryOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const QueryOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _max_points = _o->max_points;
  auto _allow_extrapolation = _o->allow_extrapolation;
  auto _strict = _o->strict;
  return quantra::CreateQueryOptions(
      _fbb,
      _calendar,
      _business_day_convention,
      _max_points,
      _allow_extrapolation,
      _strict);
}

inline ZeroRateQueryT *ZeroRateQuery::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ZeroRateQueryT>(new ZeroRateQueryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ZeroRateQuery::UnPackTo(ZeroRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = use_curve_day_counter(); _o->use_curve_day_counter = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = compounding(); _o->compounding = _e; }
  { auto _e = frequency(); _o->frequency = _e; }
}

inline ::flatbuffers::Offset<ZeroRateQuery> ZeroRateQuery::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZeroRateQuery(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ZeroRateQuery> CreateZeroRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ZeroRateQueryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _use_curve_day_counter = _o->use_curve_day_counter;
  auto _day_counter = _o->day_counter;
  auto _compounding = _o->compounding;
  auto _frequency = _o->frequency;
  return quantra::CreateZeroRateQuery(
      _fbb,
      _use_curve_day_counter,
      _day_counter,
      _compounding,
      _frequency);
}

inline ForwardRateQueryT::ForwardRateQueryT(const ForwardRateQueryT &o)
      : use_curve_day_counter(o.use_curve_day_counter),
        day_counter(o.day_counter),
        compounding(o.compounding),
        frequency(o.frequency),
        forward_type(o.forward_type),
        instantaneous_eps_number(o.instantaneous_eps_number),
        instantaneous_eps_time_unit(o.instantaneous_eps_time_unit),
        tenor((o.tenor) ? new quantra::PeriodT(*o.tenor) : nullptr),
        use_grid_calendar_for_advance(o.use_grid_calendar_for_advance) {
}

inline ForwardRateQueryT &ForwardRateQueryT::operator=(ForwardRateQueryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(use_curve_day_counter, o.use_curve_day_counter);
  std::swap(day_counter, o.day_counter);
  std::swap(compounding, o.compounding);
  std::swap(frequency, o.frequency);
  std::swap(forward_type, o.forward_type);
  std::swap(instantaneous_eps_number, o.instantaneous_eps_number);
  std::swap(instantaneous_eps_time_unit, o.instantaneous_eps_time_unit);
  std::swap(tenor, o.tenor);
  std::swap(use_grid_calendar_for_advance, o.use_grid_calendar_for_advance);
  return *this;
}

inline ForwardRateQueryT *ForwardRateQuery::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ForwardRateQueryT>(new ForwardRateQueryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ForwardRateQuery::UnPackTo(ForwardRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = use_curve_day_counter(); _o->use_curve_day_counter = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = compounding(); _o->compounding = _e; }
  { auto _e = frequency(); _o->frequency = _e; }
  { auto _e = forward_type(); _o->forward_type = _e; }
  { auto _e = instantaneous_eps_number(); _o->instantaneous_eps_number = _e; }
  { auto _e = instantaneous_eps_time_unit(); _o->instantaneous_eps_time_unit = _e; }
  { auto _e = tenor(); if (_e) { if(_o->tenor) { _e->UnPackTo(_o->tenor.get(), _resolver); } else { _o->tenor = std::unique_ptr<quantra::PeriodT>(_e->UnPack(_resolver)); } } else if (_o->tenor) { _o->tenor.reset(); } }
  { auto _e = use_grid_calendar_for_advance(); _o->use_grid_calendar_for_advance = _e; }
}

inline ::flatbuffers::Offset<ForwardRateQuery> ForwardRateQuery::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateForwardRateQuery(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ForwardRateQuery> CreateForwardRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ForwardRateQueryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _use_curve_day_counter = _o->use_curve_day_counter;
  auto _day_counter = _o->day_counter;
  auto _compounding = _o->compounding;
  auto _frequency = _o->frequency;
  auto _forward_type = _o->forward_type;
  auto _instantaneous_eps_number = _o->instantaneous_eps_number;
  auto _instantaneous_eps_time_unit = _o->instantaneous_eps_time_unit;
  auto _tenor = _o->tenor ? CreatePeriod(_fbb, _o->tenor.get(), _rehasher) : 0;
  auto _use_grid_calendar_for_advance = _o->use_grid_calendar_for_advance;
  return quantra::CreateForwardRateQuery(
      _fbb,
      _use_curve_day_counter,
      _day_counter,
      _compounding,
      _frequency,
      _forward_type,
      _instantaneous_eps_number,
      _instantaneous_eps_time_unit,
      _tenor,
      _use_grid_calendar_for_advance);
}

inline CurveQuerySpecT::CurveQuerySpecT(const CurveQuerySpecT &o)
      : curve_id(o.curve_id),
        measures(o.measures),
        grid((o.grid) ? new quantra::DateGridSpecT(*o.grid) : nullptr),
        zero((o.zero) ? new quantra::ZeroRateQueryT(*o.zero) : nullptr),
        fwd((o.fwd) ? new quantra::ForwardRateQueryT(*o.fwd) : nullptr),
        options((o.options) ? new quantra::QueryOptionsT(*o.options) : nullptr) {
}

inline CurveQuerySpecT &CurveQuerySpecT::operator=(CurveQuerySpecT o) FLATBUFFERS_NOEXCEPT {
  std::swap(curve_id, o.curve_id);
  std::swap(measures, o.measures);
  std::swap(grid, o.grid);
  std::swap(zero, o.zero);
  std::swap(fwd, o.fwd);
  std::swap(options, o.options);
  return *this;
}

inline CurveQuerySpecT *CurveQuerySpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CurveQuerySpecT>(new CurveQuerySpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CurveQuerySpec::UnPackTo(CurveQuerySpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = curve_id(); if (_e) _o->curve_id = _e->str(); }
  { auto _e = measures(); if (_e) { _o->measures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->measures[_i] = static_cast<quantra::CurveMeasure>(_e->Get(_i)); } } else { _o->measures.resize(0); } }
  { auto _e = grid(); if (_e) { if(_o->grid) { _e->UnPackTo(_o->grid.get(), _resolver); } else { _o->grid = std::unique_ptr<quantra::DateGridSpecT>(_e->UnPack(_resolver)); } } else if (_o->grid) { _o->grid.reset(); } }
  { auto _e = zero(); if (_e) { if(_o->zero) { _e->UnPackTo(_o->zero.get(), _resolver); } else { _o->zero = std::unique_ptr<quantra::ZeroRateQueryT>(_e->UnPack(_resolver)); } } else if (_o->zero) { _o->zero.reset(); } }
  { auto _e = fwd(); if (_e) { if(_o->fwd) { _e->UnPackTo(_o->fwd.get(), _resolver); } else { _o->fwd = std::unique_ptr<quantra::ForwardRateQueryT>(_e->UnPack(_resolver)); } } else if (_o->fwd) { _o->fwd.reset(); } }
  { auto _e = options(); if (_e) { if(_o->options) { _e->UnPackTo(_o->options.get(), _resolver); } else { _o->options = std::unique_ptr<quantra::QueryOptionsT>(_e->UnPack(_resolver)); } } else if (_o->options) { _o->options.reset(); } }
}

inline ::flatbuffers::Offset<CurveQuerySpec> CurveQuerySpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQuerySpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCurveQuerySpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CurveQuerySpec> CreateCurveQuerySpec(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQuerySpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CurveQuerySpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _curve_id = _fbb.CreateString(_o->curve_id);
  auto _measures = _fbb.CreateVectorScalarCast<int8_t>(::flatbuffers::data(_o->measures), _o->measures.size());
  auto _grid = _o->grid ? CreateDateGridSpec(_fbb, _o->grid.get(), _rehasher) : 0;
  auto _zero = _o->zero ? CreateZeroRateQuery(_fbb, _o->zero.get(), _rehasher) : 0;
  auto _fwd = _o->fwd ? CreateForwardRateQuery(_fbb, _o->fwd.get(), _rehasher) : 0;
  auto _options = _o->options ? CreateQueryOptions(_fbb, _o->options.get(), _rehasher) : 0;
  return quantra::CreateCurveQuerySpec(
      _fbb,
      _curve_id,
      _measures,
      _grid,
      _zero,
      _fwd,
      _options);
}

inline bool VerifyDateGrid(::flatbuffers::Verifier &verifier, const void *obj, DateGrid type) {
  switch (type) {
    case DateGrid_NONE: {
      return true;
    }
    case DateGrid_TenorGrid: {
      auto ptr = reinterpret_cast<const quantra::TenorGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DateGrid_RangeGrid: {
      auto ptr = reinterpret_cast<const quantra::RangeGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDateGridVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDateGrid(
        verifier,  values->Get(i), types->GetEnum<DateGrid>(i))) {
      return false;
    }
  }
  return true;
}

inline void *DateGridUnion::UnPack(const void *obj, DateGrid type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case DateGrid_TenorGrid: {
      auto ptr = reinterpret_cast<const quantra::TenorGrid *>(obj);
      return ptr->UnPack(resolver);
    }
    case DateGrid_RangeGrid: {
      auto ptr = reinterpret_cast<const quantra::RangeGrid *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> DateGridUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case DateGrid_TenorGrid: {
      auto ptr = reinterpret_cast<const quantra::TenorGridT *>(value);
      return CreateTenorGrid(_fbb, ptr, _rehasher).Union();
    }
    case DateGrid_RangeGrid: {
      auto ptr = reinterpret_cast<const quantra::RangeGridT *>(value);
      return CreateRangeGrid(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline DateGridUnion::DateGridUnion(const DateGridUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case DateGrid_TenorGrid: {
      value = new quantra::TenorGridT(*reinterpret_cast<quantra::TenorGridT *>(u.value));
      break;
    }
    case DateGrid_RangeGrid: {
      value = new quantra::RangeGridT(*reinterpret_cast<quantra::RangeGridT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void DateGridUnion::Reset() {
  switch (type) {
    case DateGrid_TenorGrid: {
      auto ptr = reinterpret_cast<quantra::TenorGridT *>(value);
      delete ptr;
      break;
    }
    case DateGrid_RangeGrid: {
      auto ptr = reinterpret_cast<quantra::RangeGridT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = DateGrid_NONE;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_CURVEQUERY_QUANTRA_H_
