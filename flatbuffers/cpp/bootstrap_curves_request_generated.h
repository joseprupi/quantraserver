// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BOOTSTRAPCURVESREQUEST_QUANTRA_H_
#define FLATBUFFERS_GENERATED_BOOTSTRAPCURVESREQUEST_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"
#include "index_generated.h"
#include "term_structure_generated.h"

namespace quantra {

struct Tenor;
struct TenorBuilder;
struct TenorT;

struct TenorGrid;
struct TenorGridBuilder;
struct TenorGridT;

struct RangeGrid;
struct RangeGridBuilder;
struct RangeGridT;

struct CurveGridSpec;
struct CurveGridSpecBuilder;
struct CurveGridSpecT;

struct ZeroRateQuery;
struct ZeroRateQueryBuilder;
struct ZeroRateQueryT;

struct ForwardRateQuery;
struct ForwardRateQueryBuilder;
struct ForwardRateQueryT;

struct CurveQuery;
struct CurveQueryBuilder;
struct CurveQueryT;

struct BootstrapCurveSpec;
struct BootstrapCurveSpecBuilder;
struct BootstrapCurveSpecT;

struct BootstrapCurvesRequest;
struct BootstrapCurvesRequestBuilder;
struct BootstrapCurvesRequestT;

/// What output you want sampled from the bootstrapped curve.
enum CurveMeasure : int8_t {
  /// Discount factor P(t)
  CurveMeasure_DF = 0,
  /// Zero rate z(t)
  CurveMeasure_ZERO = 1,
  /// Forward rate f(t) or F(d1,d2)
  CurveMeasure_FWD = 2,
  CurveMeasure_MIN = CurveMeasure_DF,
  CurveMeasure_MAX = CurveMeasure_FWD
};

inline const CurveMeasure (&EnumValuesCurveMeasure())[3] {
  static const CurveMeasure values[] = {
    CurveMeasure_DF,
    CurveMeasure_ZERO,
    CurveMeasure_FWD
  };
  return values;
}

inline const char * const *EnumNamesCurveMeasure() {
  static const char * const names[4] = {
    "DF",
    "ZERO",
    "FWD",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurveMeasure(CurveMeasure e) {
  if (::flatbuffers::IsOutRange(e, CurveMeasure_DF, CurveMeasure_FWD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurveMeasure()[index];
}

/// Forward rate definition.
enum ForwardType : int8_t {
  /// Approximated instantaneous forward around d
  ForwardType_Instantaneous = 0,
  /// Forward over [d, d + tenor]
  ForwardType_Period = 1,
  ForwardType_MIN = ForwardType_Instantaneous,
  ForwardType_MAX = ForwardType_Period
};

inline const ForwardType (&EnumValuesForwardType())[2] {
  static const ForwardType values[] = {
    ForwardType_Instantaneous,
    ForwardType_Period
  };
  return values;
}

inline const char * const *EnumNamesForwardType() {
  static const char * const names[3] = {
    "Instantaneous",
    "Period",
    nullptr
  };
  return names;
}

inline const char *EnumNameForwardType(ForwardType e) {
  if (::flatbuffers::IsOutRange(e, ForwardType_Instantaneous, ForwardType_Period)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesForwardType()[index];
}

enum CurveGrid : uint8_t {
  CurveGrid_NONE = 0,
  CurveGrid_TenorGrid = 1,
  CurveGrid_RangeGrid = 2,
  CurveGrid_MIN = CurveGrid_NONE,
  CurveGrid_MAX = CurveGrid_RangeGrid
};

inline const CurveGrid (&EnumValuesCurveGrid())[3] {
  static const CurveGrid values[] = {
    CurveGrid_NONE,
    CurveGrid_TenorGrid,
    CurveGrid_RangeGrid
  };
  return values;
}

inline const char * const *EnumNamesCurveGrid() {
  static const char * const names[4] = {
    "NONE",
    "TenorGrid",
    "RangeGrid",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurveGrid(CurveGrid e) {
  if (::flatbuffers::IsOutRange(e, CurveGrid_NONE, CurveGrid_RangeGrid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurveGrid()[index];
}

template<typename T> struct CurveGridTraits {
  static const CurveGrid enum_value = CurveGrid_NONE;
};

template<> struct CurveGridTraits<quantra::TenorGrid> {
  static const CurveGrid enum_value = CurveGrid_TenorGrid;
};

template<> struct CurveGridTraits<quantra::RangeGrid> {
  static const CurveGrid enum_value = CurveGrid_RangeGrid;
};

template<typename T> struct CurveGridUnionTraits {
  static const CurveGrid enum_value = CurveGrid_NONE;
};

template<> struct CurveGridUnionTraits<quantra::TenorGridT> {
  static const CurveGrid enum_value = CurveGrid_TenorGrid;
};

template<> struct CurveGridUnionTraits<quantra::RangeGridT> {
  static const CurveGrid enum_value = CurveGrid_RangeGrid;
};

struct CurveGridUnion {
  CurveGrid type;
  void *value;

  CurveGridUnion() : type(CurveGrid_NONE), value(nullptr) {}
  CurveGridUnion(CurveGridUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(CurveGrid_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CurveGridUnion(const CurveGridUnion &);
  CurveGridUnion &operator=(const CurveGridUnion &u)
    { CurveGridUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CurveGridUnion &operator=(CurveGridUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CurveGridUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = CurveGridUnionTraits<RT>::enum_value;
    if (type != CurveGrid_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, CurveGrid type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::TenorGridT *AsTenorGrid() {
    return type == CurveGrid_TenorGrid ?
      reinterpret_cast<quantra::TenorGridT *>(value) : nullptr;
  }
  const quantra::TenorGridT *AsTenorGrid() const {
    return type == CurveGrid_TenorGrid ?
      reinterpret_cast<const quantra::TenorGridT *>(value) : nullptr;
  }
  quantra::RangeGridT *AsRangeGrid() {
    return type == CurveGrid_RangeGrid ?
      reinterpret_cast<quantra::RangeGridT *>(value) : nullptr;
  }
  const quantra::RangeGridT *AsRangeGrid() const {
    return type == CurveGrid_RangeGrid ?
      reinterpret_cast<const quantra::RangeGridT *>(value) : nullptr;
  }
};

bool VerifyCurveGrid(::flatbuffers::Verifier &verifier, const void *obj, CurveGrid type);
bool VerifyCurveGridVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct TenorT : public ::flatbuffers::NativeTable {
  typedef Tenor TableType;
  int32_t n = 0;
  quantra::enums::TimeUnit unit = quantra::enums::TimeUnit_Days;
};

/// A tenor as a structured {n, unit} pair that maps directly to QuantLib::Period.
struct Tenor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TenorT NativeTableType;
  typedef TenorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N = 4,
    VT_UNIT = 6
  };
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  quantra::enums::TimeUnit unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_UNIT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N, 4) &&
           VerifyField<int8_t>(verifier, VT_UNIT, 1) &&
           verifier.EndTable();
  }
  TenorT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TenorT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Tenor> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TenorBuilder {
  typedef Tenor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Tenor::VT_N, n, 0);
  }
  void add_unit(quantra::enums::TimeUnit unit) {
    fbb_.AddElement<int8_t>(Tenor::VT_UNIT, static_cast<int8_t>(unit), 0);
  }
  explicit TenorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tenor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tenor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tenor> CreateTenor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t n = 0,
    quantra::enums::TimeUnit unit = quantra::enums::TimeUnit_Days) {
  TenorBuilder builder_(_fbb);
  builder_.add_n(n);
  builder_.add_unit(unit);
  return builder_.Finish();
}

::flatbuffers::Offset<Tenor> CreateTenor(::flatbuffers::FlatBufferBuilder &_fbb, const TenorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TenorGridT : public ::flatbuffers::NativeTable {
  typedef TenorGrid TableType;
  std::vector<std::unique_ptr<quantra::TenorT>> tenors{};
  quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
  TenorGridT() = default;
  TenorGridT(const TenorGridT &o);
  TenorGridT(TenorGridT&&) FLATBUFFERS_NOEXCEPT = default;
  TenorGridT &operator=(TenorGridT o) FLATBUFFERS_NOEXCEPT;
};

/// Tenors relative to the curve reference date (or as_of_date if no reference date).
struct TenorGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TenorGridT NativeTableType;
  typedef TenorGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENORS = 4,
    VT_CALENDAR = 6,
    VT_BUSINESS_DAY_CONVENTION = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Tenor>> *tenors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Tenor>> *>(VT_TENORS);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 21));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TENORS) &&
           verifier.VerifyVector(tenors()) &&
           verifier.VerifyVectorOfTables(tenors()) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           verifier.EndTable();
  }
  TenorGridT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TenorGridT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TenorGrid> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TenorGridBuilder {
  typedef TenorGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tenors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Tenor>>> tenors) {
    fbb_.AddOffset(TenorGrid::VT_TENORS, tenors);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(TenorGrid::VT_CALENDAR, static_cast<int8_t>(calendar), 21);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(TenorGrid::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  explicit TenorGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TenorGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TenorGrid>(end);
    fbb_.Required(o, TenorGrid::VT_TENORS);
    return o;
  }
};

inline ::flatbuffers::Offset<TenorGrid> CreateTenorGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Tenor>>> tenors = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  TenorGridBuilder builder_(_fbb);
  builder_.add_tenors(tenors);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TenorGrid> CreateTenorGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::Tenor>> *tenors = nullptr,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  auto tenors__ = tenors ? _fbb.CreateVector<::flatbuffers::Offset<quantra::Tenor>>(*tenors) : 0;
  return quantra::CreateTenorGrid(
      _fbb,
      tenors__,
      calendar,
      business_day_convention);
}

::flatbuffers::Offset<TenorGrid> CreateTenorGrid(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RangeGridT : public ::flatbuffers::NativeTable {
  typedef RangeGrid TableType;
  std::string start_date{};
  std::string end_date{};
  int32_t step_number = 1;
  quantra::enums::TimeUnit step_time_unit = quantra::enums::TimeUnit_Days;
  bool business_days_only = false;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following;
};

/// Sample the curve between start/end with a step.
struct RangeGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeGridT NativeTableType;
  typedef RangeGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_DATE = 4,
    VT_END_DATE = 6,
    VT_STEP_NUMBER = 8,
    VT_STEP_TIME_UNIT = 10,
    VT_BUSINESS_DAYS_ONLY = 12,
    VT_CALENDAR = 14,
    VT_BUSINESS_DAY_CONVENTION = 16
  };
  const ::flatbuffers::String *start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_DATE);
  }
  const ::flatbuffers::String *end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END_DATE);
  }
  int32_t step_number() const {
    return GetField<int32_t>(VT_STEP_NUMBER, 1);
  }
  quantra::enums::TimeUnit step_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_STEP_TIME_UNIT, 0));
  }
  bool business_days_only() const {
    return GetField<uint8_t>(VT_BUSINESS_DAYS_ONLY, 0) != 0;
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 21));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_START_DATE) &&
           verifier.VerifyString(start_date()) &&
           VerifyOffsetRequired(verifier, VT_END_DATE) &&
           verifier.VerifyString(end_date()) &&
           VerifyField<int32_t>(verifier, VT_STEP_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_STEP_TIME_UNIT, 1) &&
           VerifyField<uint8_t>(verifier, VT_BUSINESS_DAYS_ONLY, 1) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           verifier.EndTable();
  }
  RangeGridT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RangeGridT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RangeGrid> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RangeGridBuilder {
  typedef RangeGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_date(::flatbuffers::Offset<::flatbuffers::String> start_date) {
    fbb_.AddOffset(RangeGrid::VT_START_DATE, start_date);
  }
  void add_end_date(::flatbuffers::Offset<::flatbuffers::String> end_date) {
    fbb_.AddOffset(RangeGrid::VT_END_DATE, end_date);
  }
  void add_step_number(int32_t step_number) {
    fbb_.AddElement<int32_t>(RangeGrid::VT_STEP_NUMBER, step_number, 1);
  }
  void add_step_time_unit(quantra::enums::TimeUnit step_time_unit) {
    fbb_.AddElement<int8_t>(RangeGrid::VT_STEP_TIME_UNIT, static_cast<int8_t>(step_time_unit), 0);
  }
  void add_business_days_only(bool business_days_only) {
    fbb_.AddElement<uint8_t>(RangeGrid::VT_BUSINESS_DAYS_ONLY, static_cast<uint8_t>(business_days_only), 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(RangeGrid::VT_CALENDAR, static_cast<int8_t>(calendar), 21);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(RangeGrid::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  explicit RangeGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RangeGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RangeGrid>(end);
    fbb_.Required(o, RangeGrid::VT_END_DATE);
    return o;
  }
};

inline ::flatbuffers::Offset<RangeGrid> CreateRangeGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> end_date = 0,
    int32_t step_number = 1,
    quantra::enums::TimeUnit step_time_unit = quantra::enums::TimeUnit_Days,
    bool business_days_only = false,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  RangeGridBuilder builder_(_fbb);
  builder_.add_step_number(step_number);
  builder_.add_end_date(end_date);
  builder_.add_start_date(start_date);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_business_days_only(business_days_only);
  builder_.add_step_time_unit(step_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RangeGrid> CreateRangeGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *start_date = nullptr,
    const char *end_date = nullptr,
    int32_t step_number = 1,
    quantra::enums::TimeUnit step_time_unit = quantra::enums::TimeUnit_Days,
    bool business_days_only = false,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_NullCalendar,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  auto start_date__ = start_date ? _fbb.CreateString(start_date) : 0;
  auto end_date__ = end_date ? _fbb.CreateString(end_date) : 0;
  return quantra::CreateRangeGrid(
      _fbb,
      start_date__,
      end_date__,
      step_number,
      step_time_unit,
      business_days_only,
      calendar,
      business_day_convention);
}

::flatbuffers::Offset<RangeGrid> CreateRangeGrid(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CurveGridSpecT : public ::flatbuffers::NativeTable {
  typedef CurveGridSpec TableType;
  quantra::CurveGridUnion grid{};
};

struct CurveGridSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurveGridSpecT NativeTableType;
  typedef CurveGridSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRID_TYPE = 4,
    VT_GRID = 6
  };
  quantra::CurveGrid grid_type() const {
    return static_cast<quantra::CurveGrid>(GetField<uint8_t>(VT_GRID_TYPE, 0));
  }
  const void *grid() const {
    return GetPointer<const void *>(VT_GRID);
  }
  template<typename T> const T *grid_as() const;
  const quantra::TenorGrid *grid_as_TenorGrid() const {
    return grid_type() == quantra::CurveGrid_TenorGrid ? static_cast<const quantra::TenorGrid *>(grid()) : nullptr;
  }
  const quantra::RangeGrid *grid_as_RangeGrid() const {
    return grid_type() == quantra::CurveGrid_RangeGrid ? static_cast<const quantra::RangeGrid *>(grid()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GRID_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_GRID) &&
           VerifyCurveGrid(verifier, grid(), grid_type()) &&
           verifier.EndTable();
  }
  CurveGridSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CurveGridSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CurveGridSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveGridSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::TenorGrid *CurveGridSpec::grid_as<quantra::TenorGrid>() const {
  return grid_as_TenorGrid();
}

template<> inline const quantra::RangeGrid *CurveGridSpec::grid_as<quantra::RangeGrid>() const {
  return grid_as_RangeGrid();
}

struct CurveGridSpecBuilder {
  typedef CurveGridSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_grid_type(quantra::CurveGrid grid_type) {
    fbb_.AddElement<uint8_t>(CurveGridSpec::VT_GRID_TYPE, static_cast<uint8_t>(grid_type), 0);
  }
  void add_grid(::flatbuffers::Offset<void> grid) {
    fbb_.AddOffset(CurveGridSpec::VT_GRID, grid);
  }
  explicit CurveGridSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CurveGridSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CurveGridSpec>(end);
    fbb_.Required(o, CurveGridSpec::VT_GRID);
    return o;
  }
};

inline ::flatbuffers::Offset<CurveGridSpec> CreateCurveGridSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::CurveGrid grid_type = quantra::CurveGrid_NONE,
    ::flatbuffers::Offset<void> grid = 0) {
  CurveGridSpecBuilder builder_(_fbb);
  builder_.add_grid(grid);
  builder_.add_grid_type(grid_type);
  return builder_.Finish();
}

::flatbuffers::Offset<CurveGridSpec> CreateCurveGridSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CurveGridSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ZeroRateQueryT : public ::flatbuffers::NativeTable {
  typedef ZeroRateQuery TableType;
  bool use_curve_day_counter = true;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed;
  quantra::enums::Compounding compounding = quantra::enums::Compounding_Continuous;
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
};

struct ZeroRateQuery FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ZeroRateQueryT NativeTableType;
  typedef ZeroRateQueryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_CURVE_DAY_COUNTER = 4,
    VT_DAY_COUNTER = 6,
    VT_COMPOUNDING = 8,
    VT_FREQUENCY = 10
  };
  bool use_curve_day_counter() const {
    return GetField<uint8_t>(VT_USE_CURVE_DAY_COUNTER, 1) != 0;
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 1));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 1));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_CURVE_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING, 1) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           verifier.EndTable();
  }
  ZeroRateQueryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ZeroRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ZeroRateQuery> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ZeroRateQueryBuilder {
  typedef ZeroRateQuery Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_use_curve_day_counter(bool use_curve_day_counter) {
    fbb_.AddElement<uint8_t>(ZeroRateQuery::VT_USE_CURVE_DAY_COUNTER, static_cast<uint8_t>(use_curve_day_counter), 1);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(ZeroRateQuery::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 1);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(ZeroRateQuery::VT_COMPOUNDING, static_cast<int8_t>(compounding), 1);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(ZeroRateQuery::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  explicit ZeroRateQueryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ZeroRateQuery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ZeroRateQuery>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ZeroRateQuery> CreateZeroRateQuery(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool use_curve_day_counter = true,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Continuous,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual) {
  ZeroRateQueryBuilder builder_(_fbb);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  builder_.add_use_curve_day_counter(use_curve_day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<ZeroRateQuery> CreateZeroRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ForwardRateQueryT : public ::flatbuffers::NativeTable {
  typedef ForwardRateQuery TableType;
  bool use_curve_day_counter = true;
  quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed;
  quantra::enums::Compounding compounding = quantra::enums::Compounding_Simple;
  quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual;
  quantra::ForwardType forward_type = quantra::ForwardType_Instantaneous;
  int32_t instantaneous_eps_number = 1;
  quantra::enums::TimeUnit instantaneous_eps_time_unit = quantra::enums::TimeUnit_Days;
  int32_t tenor_number = 3;
  quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Months;
  bool use_grid_calendar_for_advance = true;
};

struct ForwardRateQuery FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ForwardRateQueryT NativeTableType;
  typedef ForwardRateQueryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_CURVE_DAY_COUNTER = 4,
    VT_DAY_COUNTER = 6,
    VT_COMPOUNDING = 8,
    VT_FREQUENCY = 10,
    VT_FORWARD_TYPE = 12,
    VT_INSTANTANEOUS_EPS_NUMBER = 14,
    VT_INSTANTANEOUS_EPS_TIME_UNIT = 16,
    VT_TENOR_NUMBER = 18,
    VT_TENOR_TIME_UNIT = 20,
    VT_USE_GRID_CALENDAR_FOR_ADVANCE = 22
  };
  bool use_curve_day_counter() const {
    return GetField<uint8_t>(VT_USE_CURVE_DAY_COUNTER, 1) != 0;
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 1));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 2));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  quantra::ForwardType forward_type() const {
    return static_cast<quantra::ForwardType>(GetField<int8_t>(VT_FORWARD_TYPE, 0));
  }
  int32_t instantaneous_eps_number() const {
    return GetField<int32_t>(VT_INSTANTANEOUS_EPS_NUMBER, 1);
  }
  quantra::enums::TimeUnit instantaneous_eps_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_INSTANTANEOUS_EPS_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 3);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 5));
  }
  bool use_grid_calendar_for_advance() const {
    return GetField<uint8_t>(VT_USE_GRID_CALENDAR_FOR_ADVANCE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_CURVE_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING, 1) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_FORWARD_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_INSTANTANEOUS_EPS_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_INSTANTANEOUS_EPS_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<uint8_t>(verifier, VT_USE_GRID_CALENDAR_FOR_ADVANCE, 1) &&
           verifier.EndTable();
  }
  ForwardRateQueryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ForwardRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ForwardRateQuery> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ForwardRateQueryBuilder {
  typedef ForwardRateQuery Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_use_curve_day_counter(bool use_curve_day_counter) {
    fbb_.AddElement<uint8_t>(ForwardRateQuery::VT_USE_CURVE_DAY_COUNTER, static_cast<uint8_t>(use_curve_day_counter), 1);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 1);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_COMPOUNDING, static_cast<int8_t>(compounding), 2);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  void add_forward_type(quantra::ForwardType forward_type) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_FORWARD_TYPE, static_cast<int8_t>(forward_type), 0);
  }
  void add_instantaneous_eps_number(int32_t instantaneous_eps_number) {
    fbb_.AddElement<int32_t>(ForwardRateQuery::VT_INSTANTANEOUS_EPS_NUMBER, instantaneous_eps_number, 1);
  }
  void add_instantaneous_eps_time_unit(quantra::enums::TimeUnit instantaneous_eps_time_unit) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_INSTANTANEOUS_EPS_TIME_UNIT, static_cast<int8_t>(instantaneous_eps_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(ForwardRateQuery::VT_TENOR_NUMBER, tenor_number, 3);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(ForwardRateQuery::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 5);
  }
  void add_use_grid_calendar_for_advance(bool use_grid_calendar_for_advance) {
    fbb_.AddElement<uint8_t>(ForwardRateQuery::VT_USE_GRID_CALENDAR_FOR_ADVANCE, static_cast<uint8_t>(use_grid_calendar_for_advance), 1);
  }
  explicit ForwardRateQueryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ForwardRateQuery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ForwardRateQuery>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ForwardRateQuery> CreateForwardRateQuery(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool use_curve_day_counter = true,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual365Fixed,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Simple,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual,
    quantra::ForwardType forward_type = quantra::ForwardType_Instantaneous,
    int32_t instantaneous_eps_number = 1,
    quantra::enums::TimeUnit instantaneous_eps_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 3,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Months,
    bool use_grid_calendar_for_advance = true) {
  ForwardRateQueryBuilder builder_(_fbb);
  builder_.add_tenor_number(tenor_number);
  builder_.add_instantaneous_eps_number(instantaneous_eps_number);
  builder_.add_use_grid_calendar_for_advance(use_grid_calendar_for_advance);
  builder_.add_tenor_time_unit(tenor_time_unit);
  builder_.add_instantaneous_eps_time_unit(instantaneous_eps_time_unit);
  builder_.add_forward_type(forward_type);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  builder_.add_use_curve_day_counter(use_curve_day_counter);
  return builder_.Finish();
}

::flatbuffers::Offset<ForwardRateQuery> CreateForwardRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CurveQueryT : public ::flatbuffers::NativeTable {
  typedef CurveQuery TableType;
  std::vector<quantra::CurveMeasure> measures{};
  std::unique_ptr<quantra::CurveGridSpecT> grid{};
  std::unique_ptr<quantra::ZeroRateQueryT> zero{};
  std::unique_ptr<quantra::ForwardRateQueryT> fwd{};
  CurveQueryT() = default;
  CurveQueryT(const CurveQueryT &o);
  CurveQueryT(CurveQueryT&&) FLATBUFFERS_NOEXCEPT = default;
  CurveQueryT &operator=(CurveQueryT o) FLATBUFFERS_NOEXCEPT;
};

struct CurveQuery FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CurveQueryT NativeTableType;
  typedef CurveQueryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEASURES = 4,
    VT_GRID = 6,
    VT_ZERO = 8,
    VT_FWD = 10
  };
  const ::flatbuffers::Vector<int8_t> *measures() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_MEASURES);
  }
  const quantra::CurveGridSpec *grid() const {
    return GetPointer<const quantra::CurveGridSpec *>(VT_GRID);
  }
  const quantra::ZeroRateQuery *zero() const {
    return GetPointer<const quantra::ZeroRateQuery *>(VT_ZERO);
  }
  const quantra::ForwardRateQuery *fwd() const {
    return GetPointer<const quantra::ForwardRateQuery *>(VT_FWD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MEASURES) &&
           verifier.VerifyVector(measures()) &&
           VerifyOffsetRequired(verifier, VT_GRID) &&
           verifier.VerifyTable(grid()) &&
           VerifyOffset(verifier, VT_ZERO) &&
           verifier.VerifyTable(zero()) &&
           VerifyOffset(verifier, VT_FWD) &&
           verifier.VerifyTable(fwd()) &&
           verifier.EndTable();
  }
  CurveQueryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CurveQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CurveQuery> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CurveQueryBuilder {
  typedef CurveQuery Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_measures(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> measures) {
    fbb_.AddOffset(CurveQuery::VT_MEASURES, measures);
  }
  void add_grid(::flatbuffers::Offset<quantra::CurveGridSpec> grid) {
    fbb_.AddOffset(CurveQuery::VT_GRID, grid);
  }
  void add_zero(::flatbuffers::Offset<quantra::ZeroRateQuery> zero) {
    fbb_.AddOffset(CurveQuery::VT_ZERO, zero);
  }
  void add_fwd(::flatbuffers::Offset<quantra::ForwardRateQuery> fwd) {
    fbb_.AddOffset(CurveQuery::VT_FWD, fwd);
  }
  explicit CurveQueryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CurveQuery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CurveQuery>(end);
    fbb_.Required(o, CurveQuery::VT_MEASURES);
    fbb_.Required(o, CurveQuery::VT_GRID);
    return o;
  }
};

inline ::flatbuffers::Offset<CurveQuery> CreateCurveQuery(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> measures = 0,
    ::flatbuffers::Offset<quantra::CurveGridSpec> grid = 0,
    ::flatbuffers::Offset<quantra::ZeroRateQuery> zero = 0,
    ::flatbuffers::Offset<quantra::ForwardRateQuery> fwd = 0) {
  CurveQueryBuilder builder_(_fbb);
  builder_.add_fwd(fwd);
  builder_.add_zero(zero);
  builder_.add_grid(grid);
  builder_.add_measures(measures);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CurveQuery> CreateCurveQueryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *measures = nullptr,
    ::flatbuffers::Offset<quantra::CurveGridSpec> grid = 0,
    ::flatbuffers::Offset<quantra::ZeroRateQuery> zero = 0,
    ::flatbuffers::Offset<quantra::ForwardRateQuery> fwd = 0) {
  auto measures__ = measures ? _fbb.CreateVector<int8_t>(*measures) : 0;
  return quantra::CreateCurveQuery(
      _fbb,
      measures__,
      grid,
      zero,
      fwd);
}

::flatbuffers::Offset<CurveQuery> CreateCurveQuery(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BootstrapCurveSpecT : public ::flatbuffers::NativeTable {
  typedef BootstrapCurveSpec TableType;
  std::unique_ptr<quantra::TermStructureT> curve{};
  std::unique_ptr<quantra::CurveQueryT> query{};
  BootstrapCurveSpecT() = default;
  BootstrapCurveSpecT(const BootstrapCurveSpecT &o);
  BootstrapCurveSpecT(BootstrapCurveSpecT&&) FLATBUFFERS_NOEXCEPT = default;
  BootstrapCurveSpecT &operator=(BootstrapCurveSpecT o) FLATBUFFERS_NOEXCEPT;
};

struct BootstrapCurveSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BootstrapCurveSpecT NativeTableType;
  typedef BootstrapCurveSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURVE = 4,
    VT_QUERY = 6
  };
  const quantra::TermStructure *curve() const {
    return GetPointer<const quantra::TermStructure *>(VT_CURVE);
  }
  const quantra::CurveQuery *query() const {
    return GetPointer<const quantra::CurveQuery *>(VT_QUERY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CURVE) &&
           verifier.VerifyTable(curve()) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.VerifyTable(query()) &&
           verifier.EndTable();
  }
  BootstrapCurveSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BootstrapCurveSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BootstrapCurveSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BootstrapCurveSpecBuilder {
  typedef BootstrapCurveSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_curve(::flatbuffers::Offset<quantra::TermStructure> curve) {
    fbb_.AddOffset(BootstrapCurveSpec::VT_CURVE, curve);
  }
  void add_query(::flatbuffers::Offset<quantra::CurveQuery> query) {
    fbb_.AddOffset(BootstrapCurveSpec::VT_QUERY, query);
  }
  explicit BootstrapCurveSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BootstrapCurveSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BootstrapCurveSpec>(end);
    fbb_.Required(o, BootstrapCurveSpec::VT_CURVE);
    return o;
  }
};

inline ::flatbuffers::Offset<BootstrapCurveSpec> CreateBootstrapCurveSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<quantra::TermStructure> curve = 0,
    ::flatbuffers::Offset<quantra::CurveQuery> query = 0) {
  BootstrapCurveSpecBuilder builder_(_fbb);
  builder_.add_query(query);
  builder_.add_curve(curve);
  return builder_.Finish();
}

::flatbuffers::Offset<BootstrapCurveSpec> CreateBootstrapCurveSpec(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BootstrapCurvesRequestT : public ::flatbuffers::NativeTable {
  typedef BootstrapCurvesRequest TableType;
  std::string as_of_date{};
  std::vector<std::unique_ptr<quantra::IndexDefT>> indices{};
  std::vector<std::unique_ptr<quantra::BootstrapCurveSpecT>> curves{};
  BootstrapCurvesRequestT() = default;
  BootstrapCurvesRequestT(const BootstrapCurvesRequestT &o);
  BootstrapCurvesRequestT(BootstrapCurvesRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  BootstrapCurvesRequestT &operator=(BootstrapCurvesRequestT o) FLATBUFFERS_NOEXCEPT;
};

/// Request to bootstrap multiple yield curves.
struct BootstrapCurvesRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BootstrapCurvesRequestT NativeTableType;
  typedef BootstrapCurvesRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AS_OF_DATE = 4,
    VT_INDICES = 6,
    VT_CURVES = 8
  };
  /// Valuation date (YYYY-MM-DD or YYYY/MM/DD) for evaluationDate().
  const ::flatbuffers::String *as_of_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AS_OF_DATE);
  }
  /// Index definitions needed by curve helpers (SwapHelper, OISHelper, etc.)
  /// Every IndexRef in helpers must resolve to an IndexDef here.
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>> *>(VT_INDICES);
  }
  /// Bootstrap many curves at once.
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveSpec>> *curves() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveSpec>> *>(VT_CURVES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_AS_OF_DATE) &&
           verifier.VerifyString(as_of_date()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.VerifyVectorOfTables(indices()) &&
           VerifyOffsetRequired(verifier, VT_CURVES) &&
           verifier.VerifyVector(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           verifier.EndTable();
  }
  BootstrapCurvesRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BootstrapCurvesRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BootstrapCurvesRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BootstrapCurvesRequestBuilder {
  typedef BootstrapCurvesRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_as_of_date(::flatbuffers::Offset<::flatbuffers::String> as_of_date) {
    fbb_.AddOffset(BootstrapCurvesRequest::VT_AS_OF_DATE, as_of_date);
  }
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>>> indices) {
    fbb_.AddOffset(BootstrapCurvesRequest::VT_INDICES, indices);
  }
  void add_curves(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveSpec>>> curves) {
    fbb_.AddOffset(BootstrapCurvesRequest::VT_CURVES, curves);
  }
  explicit BootstrapCurvesRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BootstrapCurvesRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BootstrapCurvesRequest>(end);
    fbb_.Required(o, BootstrapCurvesRequest::VT_AS_OF_DATE);
    fbb_.Required(o, BootstrapCurvesRequest::VT_CURVES);
    return o;
  }
};

inline ::flatbuffers::Offset<BootstrapCurvesRequest> CreateBootstrapCurvesRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> as_of_date = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::IndexDef>>> indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::BootstrapCurveSpec>>> curves = 0) {
  BootstrapCurvesRequestBuilder builder_(_fbb);
  builder_.add_curves(curves);
  builder_.add_indices(indices);
  builder_.add_as_of_date(as_of_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BootstrapCurvesRequest> CreateBootstrapCurvesRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *as_of_date = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::IndexDef>> *indices = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::BootstrapCurveSpec>> *curves = nullptr) {
  auto as_of_date__ = as_of_date ? _fbb.CreateString(as_of_date) : 0;
  auto indices__ = indices ? _fbb.CreateVector<::flatbuffers::Offset<quantra::IndexDef>>(*indices) : 0;
  auto curves__ = curves ? _fbb.CreateVector<::flatbuffers::Offset<quantra::BootstrapCurveSpec>>(*curves) : 0;
  return quantra::CreateBootstrapCurvesRequest(
      _fbb,
      as_of_date__,
      indices__,
      curves__);
}

::flatbuffers::Offset<BootstrapCurvesRequest> CreateBootstrapCurvesRequest(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TenorT *Tenor::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TenorT>(new TenorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tenor::UnPackTo(TenorT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = n(); _o->n = _e; }
  { auto _e = unit(); _o->unit = _e; }
}

inline ::flatbuffers::Offset<Tenor> Tenor::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTenor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Tenor> CreateTenor(::flatbuffers::FlatBufferBuilder &_fbb, const TenorT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TenorT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _n = _o->n;
  auto _unit = _o->unit;
  return quantra::CreateTenor(
      _fbb,
      _n,
      _unit);
}

inline TenorGridT::TenorGridT(const TenorGridT &o)
      : calendar(o.calendar),
        business_day_convention(o.business_day_convention) {
  tenors.reserve(o.tenors.size());
  for (const auto &tenors_ : o.tenors) { tenors.emplace_back((tenors_) ? new quantra::TenorT(*tenors_) : nullptr); }
}

inline TenorGridT &TenorGridT::operator=(TenorGridT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tenors, o.tenors);
  std::swap(calendar, o.calendar);
  std::swap(business_day_convention, o.business_day_convention);
  return *this;
}

inline TenorGridT *TenorGrid::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TenorGridT>(new TenorGridT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TenorGrid::UnPackTo(TenorGridT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tenors(); if (_e) { _o->tenors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tenors[_i]) { _e->Get(_i)->UnPackTo(_o->tenors[_i].get(), _resolver); } else { _o->tenors[_i] = std::unique_ptr<quantra::TenorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tenors.resize(0); } }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
}

inline ::flatbuffers::Offset<TenorGrid> TenorGrid::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTenorGrid(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TenorGrid> CreateTenorGrid(::flatbuffers::FlatBufferBuilder &_fbb, const TenorGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TenorGridT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tenors = _fbb.CreateVector<::flatbuffers::Offset<quantra::Tenor>> (_o->tenors.size(), [](size_t i, _VectorArgs *__va) { return CreateTenor(*__va->__fbb, __va->__o->tenors[i].get(), __va->__rehasher); }, &_va );
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  return quantra::CreateTenorGrid(
      _fbb,
      _tenors,
      _calendar,
      _business_day_convention);
}

inline RangeGridT *RangeGrid::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RangeGridT>(new RangeGridT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RangeGrid::UnPackTo(RangeGridT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_date(); if (_e) _o->start_date = _e->str(); }
  { auto _e = end_date(); if (_e) _o->end_date = _e->str(); }
  { auto _e = step_number(); _o->step_number = _e; }
  { auto _e = step_time_unit(); _o->step_time_unit = _e; }
  { auto _e = business_days_only(); _o->business_days_only = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
}

inline ::flatbuffers::Offset<RangeGrid> RangeGrid::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRangeGrid(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RangeGrid> CreateRangeGrid(::flatbuffers::FlatBufferBuilder &_fbb, const RangeGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RangeGridT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_date = _o->start_date.empty() ? 0 : _fbb.CreateString(_o->start_date);
  auto _end_date = _fbb.CreateString(_o->end_date);
  auto _step_number = _o->step_number;
  auto _step_time_unit = _o->step_time_unit;
  auto _business_days_only = _o->business_days_only;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  return quantra::CreateRangeGrid(
      _fbb,
      _start_date,
      _end_date,
      _step_number,
      _step_time_unit,
      _business_days_only,
      _calendar,
      _business_day_convention);
}

inline CurveGridSpecT *CurveGridSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CurveGridSpecT>(new CurveGridSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CurveGridSpec::UnPackTo(CurveGridSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = grid_type(); _o->grid.type = _e; }
  { auto _e = grid(); if (_e) _o->grid.value = quantra::CurveGridUnion::UnPack(_e, grid_type(), _resolver); }
}

inline ::flatbuffers::Offset<CurveGridSpec> CurveGridSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveGridSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCurveGridSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CurveGridSpec> CreateCurveGridSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CurveGridSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CurveGridSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _grid_type = _o->grid.type;
  auto _grid = _o->grid.Pack(_fbb);
  return quantra::CreateCurveGridSpec(
      _fbb,
      _grid_type,
      _grid);
}

inline ZeroRateQueryT *ZeroRateQuery::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ZeroRateQueryT>(new ZeroRateQueryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ZeroRateQuery::UnPackTo(ZeroRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = use_curve_day_counter(); _o->use_curve_day_counter = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = compounding(); _o->compounding = _e; }
  { auto _e = frequency(); _o->frequency = _e; }
}

inline ::flatbuffers::Offset<ZeroRateQuery> ZeroRateQuery::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateZeroRateQuery(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ZeroRateQuery> CreateZeroRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ZeroRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ZeroRateQueryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _use_curve_day_counter = _o->use_curve_day_counter;
  auto _day_counter = _o->day_counter;
  auto _compounding = _o->compounding;
  auto _frequency = _o->frequency;
  return quantra::CreateZeroRateQuery(
      _fbb,
      _use_curve_day_counter,
      _day_counter,
      _compounding,
      _frequency);
}

inline ForwardRateQueryT *ForwardRateQuery::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ForwardRateQueryT>(new ForwardRateQueryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ForwardRateQuery::UnPackTo(ForwardRateQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = use_curve_day_counter(); _o->use_curve_day_counter = _e; }
  { auto _e = day_counter(); _o->day_counter = _e; }
  { auto _e = compounding(); _o->compounding = _e; }
  { auto _e = frequency(); _o->frequency = _e; }
  { auto _e = forward_type(); _o->forward_type = _e; }
  { auto _e = instantaneous_eps_number(); _o->instantaneous_eps_number = _e; }
  { auto _e = instantaneous_eps_time_unit(); _o->instantaneous_eps_time_unit = _e; }
  { auto _e = tenor_number(); _o->tenor_number = _e; }
  { auto _e = tenor_time_unit(); _o->tenor_time_unit = _e; }
  { auto _e = use_grid_calendar_for_advance(); _o->use_grid_calendar_for_advance = _e; }
}

inline ::flatbuffers::Offset<ForwardRateQuery> ForwardRateQuery::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateForwardRateQuery(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ForwardRateQuery> CreateForwardRateQuery(::flatbuffers::FlatBufferBuilder &_fbb, const ForwardRateQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ForwardRateQueryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _use_curve_day_counter = _o->use_curve_day_counter;
  auto _day_counter = _o->day_counter;
  auto _compounding = _o->compounding;
  auto _frequency = _o->frequency;
  auto _forward_type = _o->forward_type;
  auto _instantaneous_eps_number = _o->instantaneous_eps_number;
  auto _instantaneous_eps_time_unit = _o->instantaneous_eps_time_unit;
  auto _tenor_number = _o->tenor_number;
  auto _tenor_time_unit = _o->tenor_time_unit;
  auto _use_grid_calendar_for_advance = _o->use_grid_calendar_for_advance;
  return quantra::CreateForwardRateQuery(
      _fbb,
      _use_curve_day_counter,
      _day_counter,
      _compounding,
      _frequency,
      _forward_type,
      _instantaneous_eps_number,
      _instantaneous_eps_time_unit,
      _tenor_number,
      _tenor_time_unit,
      _use_grid_calendar_for_advance);
}

inline CurveQueryT::CurveQueryT(const CurveQueryT &o)
      : measures(o.measures),
        grid((o.grid) ? new quantra::CurveGridSpecT(*o.grid) : nullptr),
        zero((o.zero) ? new quantra::ZeroRateQueryT(*o.zero) : nullptr),
        fwd((o.fwd) ? new quantra::ForwardRateQueryT(*o.fwd) : nullptr) {
}

inline CurveQueryT &CurveQueryT::operator=(CurveQueryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(measures, o.measures);
  std::swap(grid, o.grid);
  std::swap(zero, o.zero);
  std::swap(fwd, o.fwd);
  return *this;
}

inline CurveQueryT *CurveQuery::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CurveQueryT>(new CurveQueryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CurveQuery::UnPackTo(CurveQueryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = measures(); if (_e) { _o->measures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->measures[_i] = static_cast<quantra::CurveMeasure>(_e->Get(_i)); } } else { _o->measures.resize(0); } }
  { auto _e = grid(); if (_e) { if(_o->grid) { _e->UnPackTo(_o->grid.get(), _resolver); } else { _o->grid = std::unique_ptr<quantra::CurveGridSpecT>(_e->UnPack(_resolver)); } } else if (_o->grid) { _o->grid.reset(); } }
  { auto _e = zero(); if (_e) { if(_o->zero) { _e->UnPackTo(_o->zero.get(), _resolver); } else { _o->zero = std::unique_ptr<quantra::ZeroRateQueryT>(_e->UnPack(_resolver)); } } else if (_o->zero) { _o->zero.reset(); } }
  { auto _e = fwd(); if (_e) { if(_o->fwd) { _e->UnPackTo(_o->fwd.get(), _resolver); } else { _o->fwd = std::unique_ptr<quantra::ForwardRateQueryT>(_e->UnPack(_resolver)); } } else if (_o->fwd) { _o->fwd.reset(); } }
}

inline ::flatbuffers::Offset<CurveQuery> CurveQuery::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQueryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCurveQuery(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CurveQuery> CreateCurveQuery(::flatbuffers::FlatBufferBuilder &_fbb, const CurveQueryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CurveQueryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _measures = _fbb.CreateVectorScalarCast<int8_t>(::flatbuffers::data(_o->measures), _o->measures.size());
  auto _grid = _o->grid ? CreateCurveGridSpec(_fbb, _o->grid.get(), _rehasher) : 0;
  auto _zero = _o->zero ? CreateZeroRateQuery(_fbb, _o->zero.get(), _rehasher) : 0;
  auto _fwd = _o->fwd ? CreateForwardRateQuery(_fbb, _o->fwd.get(), _rehasher) : 0;
  return quantra::CreateCurveQuery(
      _fbb,
      _measures,
      _grid,
      _zero,
      _fwd);
}

inline BootstrapCurveSpecT::BootstrapCurveSpecT(const BootstrapCurveSpecT &o)
      : curve((o.curve) ? new quantra::TermStructureT(*o.curve) : nullptr),
        query((o.query) ? new quantra::CurveQueryT(*o.query) : nullptr) {
}

inline BootstrapCurveSpecT &BootstrapCurveSpecT::operator=(BootstrapCurveSpecT o) FLATBUFFERS_NOEXCEPT {
  std::swap(curve, o.curve);
  std::swap(query, o.query);
  return *this;
}

inline BootstrapCurveSpecT *BootstrapCurveSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BootstrapCurveSpecT>(new BootstrapCurveSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BootstrapCurveSpec::UnPackTo(BootstrapCurveSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = curve(); if (_e) { if(_o->curve) { _e->UnPackTo(_o->curve.get(), _resolver); } else { _o->curve = std::unique_ptr<quantra::TermStructureT>(_e->UnPack(_resolver)); } } else if (_o->curve) { _o->curve.reset(); } }
  { auto _e = query(); if (_e) { if(_o->query) { _e->UnPackTo(_o->query.get(), _resolver); } else { _o->query = std::unique_ptr<quantra::CurveQueryT>(_e->UnPack(_resolver)); } } else if (_o->query) { _o->query.reset(); } }
}

inline ::flatbuffers::Offset<BootstrapCurveSpec> BootstrapCurveSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBootstrapCurveSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BootstrapCurveSpec> CreateBootstrapCurveSpec(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurveSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BootstrapCurveSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _curve = _o->curve ? CreateTermStructure(_fbb, _o->curve.get(), _rehasher) : 0;
  auto _query = _o->query ? CreateCurveQuery(_fbb, _o->query.get(), _rehasher) : 0;
  return quantra::CreateBootstrapCurveSpec(
      _fbb,
      _curve,
      _query);
}

inline BootstrapCurvesRequestT::BootstrapCurvesRequestT(const BootstrapCurvesRequestT &o)
      : as_of_date(o.as_of_date) {
  indices.reserve(o.indices.size());
  for (const auto &indices_ : o.indices) { indices.emplace_back((indices_) ? new quantra::IndexDefT(*indices_) : nullptr); }
  curves.reserve(o.curves.size());
  for (const auto &curves_ : o.curves) { curves.emplace_back((curves_) ? new quantra::BootstrapCurveSpecT(*curves_) : nullptr); }
}

inline BootstrapCurvesRequestT &BootstrapCurvesRequestT::operator=(BootstrapCurvesRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(as_of_date, o.as_of_date);
  std::swap(indices, o.indices);
  std::swap(curves, o.curves);
  return *this;
}

inline BootstrapCurvesRequestT *BootstrapCurvesRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BootstrapCurvesRequestT>(new BootstrapCurvesRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BootstrapCurvesRequest::UnPackTo(BootstrapCurvesRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = as_of_date(); if (_e) _o->as_of_date = _e->str(); }
  { auto _e = indices(); if (_e) { _o->indices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->indices[_i]) { _e->Get(_i)->UnPackTo(_o->indices[_i].get(), _resolver); } else { _o->indices[_i] = std::unique_ptr<quantra::IndexDefT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->indices.resize(0); } }
  { auto _e = curves(); if (_e) { _o->curves.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->curves[_i]) { _e->Get(_i)->UnPackTo(_o->curves[_i].get(), _resolver); } else { _o->curves[_i] = std::unique_ptr<quantra::BootstrapCurveSpecT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->curves.resize(0); } }
}

inline ::flatbuffers::Offset<BootstrapCurvesRequest> BootstrapCurvesRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBootstrapCurvesRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BootstrapCurvesRequest> CreateBootstrapCurvesRequest(::flatbuffers::FlatBufferBuilder &_fbb, const BootstrapCurvesRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BootstrapCurvesRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _as_of_date = _fbb.CreateString(_o->as_of_date);
  auto _indices = _o->indices.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::IndexDef>> (_o->indices.size(), [](size_t i, _VectorArgs *__va) { return CreateIndexDef(*__va->__fbb, __va->__o->indices[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _curves = _fbb.CreateVector<::flatbuffers::Offset<quantra::BootstrapCurveSpec>> (_o->curves.size(), [](size_t i, _VectorArgs *__va) { return CreateBootstrapCurveSpec(*__va->__fbb, __va->__o->curves[i].get(), __va->__rehasher); }, &_va );
  return quantra::CreateBootstrapCurvesRequest(
      _fbb,
      _as_of_date,
      _indices,
      _curves);
}

inline bool VerifyCurveGrid(::flatbuffers::Verifier &verifier, const void *obj, CurveGrid type) {
  switch (type) {
    case CurveGrid_NONE: {
      return true;
    }
    case CurveGrid_TenorGrid: {
      auto ptr = reinterpret_cast<const quantra::TenorGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CurveGrid_RangeGrid: {
      auto ptr = reinterpret_cast<const quantra::RangeGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCurveGridVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCurveGrid(
        verifier,  values->Get(i), types->GetEnum<CurveGrid>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CurveGridUnion::UnPack(const void *obj, CurveGrid type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case CurveGrid_TenorGrid: {
      auto ptr = reinterpret_cast<const quantra::TenorGrid *>(obj);
      return ptr->UnPack(resolver);
    }
    case CurveGrid_RangeGrid: {
      auto ptr = reinterpret_cast<const quantra::RangeGrid *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> CurveGridUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case CurveGrid_TenorGrid: {
      auto ptr = reinterpret_cast<const quantra::TenorGridT *>(value);
      return CreateTenorGrid(_fbb, ptr, _rehasher).Union();
    }
    case CurveGrid_RangeGrid: {
      auto ptr = reinterpret_cast<const quantra::RangeGridT *>(value);
      return CreateRangeGrid(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CurveGridUnion::CurveGridUnion(const CurveGridUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case CurveGrid_TenorGrid: {
      value = new quantra::TenorGridT(*reinterpret_cast<quantra::TenorGridT *>(u.value));
      break;
    }
    case CurveGrid_RangeGrid: {
      value = new quantra::RangeGridT(*reinterpret_cast<quantra::RangeGridT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CurveGridUnion::Reset() {
  switch (type) {
    case CurveGrid_TenorGrid: {
      auto ptr = reinterpret_cast<quantra::TenorGridT *>(value);
      delete ptr;
      break;
    }
    case CurveGrid_RangeGrid: {
      auto ptr = reinterpret_cast<quantra::RangeGridT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = CurveGrid_NONE;
}

inline const quantra::BootstrapCurvesRequest *GetBootstrapCurvesRequest(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::BootstrapCurvesRequest>(buf);
}

inline const quantra::BootstrapCurvesRequest *GetSizePrefixedBootstrapCurvesRequest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::BootstrapCurvesRequest>(buf);
}

inline bool VerifyBootstrapCurvesRequestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::BootstrapCurvesRequest>(nullptr);
}

inline bool VerifySizePrefixedBootstrapCurvesRequestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::BootstrapCurvesRequest>(nullptr);
}

inline void FinishBootstrapCurvesRequestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::BootstrapCurvesRequest> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBootstrapCurvesRequestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::BootstrapCurvesRequest> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<quantra::BootstrapCurvesRequestT> UnPackBootstrapCurvesRequest(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::BootstrapCurvesRequestT>(GetBootstrapCurvesRequest(buf)->UnPack(res));
}

inline std::unique_ptr<quantra::BootstrapCurvesRequestT> UnPackSizePrefixedBootstrapCurvesRequest(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::BootstrapCurvesRequestT>(GetSizePrefixedBootstrapCurvesRequest(buf)->UnPack(res));
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_BOOTSTRAPCURVESREQUEST_QUANTRA_H_
