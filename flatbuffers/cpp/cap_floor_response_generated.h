// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAPFLOORRESPONSE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_CAPFLOORRESPONSE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace quantra {

struct CapFloorLet;
struct CapFloorLetBuilder;

struct CapFloorResponse;
struct CapFloorResponseBuilder;

struct PriceCapFloorResponse;
struct PriceCapFloorResponseBuilder;

struct CapFloorLet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CapFloorLetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYMENT_DATE = 4,
    VT_ACCRUAL_START_DATE = 6,
    VT_ACCRUAL_END_DATE = 8,
    VT_FIXING_DATE = 10,
    VT_STRIKE = 12,
    VT_FORWARD_RATE = 14,
    VT_DISCOUNT = 16,
    VT_PRICE = 18
  };
  const ::flatbuffers::String *payment_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  double strike() const {
    return GetField<double>(VT_STRIKE, 0.0);
  }
  double forward_rate() const {
    return GetField<double>(VT_FORWARD_RATE, 0.0);
  }
  double discount() const {
    return GetField<double>(VT_DISCOUNT, 0.0);
  }
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYMENT_DATE) &&
           verifier.VerifyString(payment_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyField<double>(verifier, VT_STRIKE, 8) &&
           VerifyField<double>(verifier, VT_FORWARD_RATE, 8) &&
           VerifyField<double>(verifier, VT_DISCOUNT, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           verifier.EndTable();
  }
};

struct CapFloorLetBuilder {
  typedef CapFloorLet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payment_date(::flatbuffers::Offset<::flatbuffers::String> payment_date) {
    fbb_.AddOffset(CapFloorLet::VT_PAYMENT_DATE, payment_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(CapFloorLet::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(CapFloorLet::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(CapFloorLet::VT_FIXING_DATE, fixing_date);
  }
  void add_strike(double strike) {
    fbb_.AddElement<double>(CapFloorLet::VT_STRIKE, strike, 0.0);
  }
  void add_forward_rate(double forward_rate) {
    fbb_.AddElement<double>(CapFloorLet::VT_FORWARD_RATE, forward_rate, 0.0);
  }
  void add_discount(double discount) {
    fbb_.AddElement<double>(CapFloorLet::VT_DISCOUNT, discount, 0.0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(CapFloorLet::VT_PRICE, price, 0.0);
  }
  explicit CapFloorLetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CapFloorLet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CapFloorLet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CapFloorLet> CreateCapFloorLet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> payment_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    double strike = 0.0,
    double forward_rate = 0.0,
    double discount = 0.0,
    double price = 0.0) {
  CapFloorLetBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_discount(discount);
  builder_.add_forward_rate(forward_rate);
  builder_.add_strike(strike);
  builder_.add_fixing_date(fixing_date);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_payment_date(payment_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CapFloorLet> CreateCapFloorLetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *payment_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    const char *fixing_date = nullptr,
    double strike = 0.0,
    double forward_rate = 0.0,
    double discount = 0.0,
    double price = 0.0) {
  auto payment_date__ = payment_date ? _fbb.CreateString(payment_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  return quantra::CreateCapFloorLet(
      _fbb,
      payment_date__,
      accrual_start_date__,
      accrual_end_date__,
      fixing_date__,
      strike,
      forward_rate,
      discount,
      price);
}

struct CapFloorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CapFloorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_ATM_RATE = 6,
    VT_IMPLIED_VOLATILITY = 8,
    VT_CAP_FLOOR_LETS = 10
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double atm_rate() const {
    return GetField<double>(VT_ATM_RATE, 0.0);
  }
  double implied_volatility() const {
    return GetField<double>(VT_IMPLIED_VOLATILITY, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>> *cap_floor_lets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>> *>(VT_CAP_FLOOR_LETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_ATM_RATE, 8) &&
           VerifyField<double>(verifier, VT_IMPLIED_VOLATILITY, 8) &&
           VerifyOffset(verifier, VT_CAP_FLOOR_LETS) &&
           verifier.VerifyVector(cap_floor_lets()) &&
           verifier.VerifyVectorOfTables(cap_floor_lets()) &&
           verifier.EndTable();
  }
};

struct CapFloorResponseBuilder {
  typedef CapFloorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(CapFloorResponse::VT_NPV, npv, 0.0);
  }
  void add_atm_rate(double atm_rate) {
    fbb_.AddElement<double>(CapFloorResponse::VT_ATM_RATE, atm_rate, 0.0);
  }
  void add_implied_volatility(double implied_volatility) {
    fbb_.AddElement<double>(CapFloorResponse::VT_IMPLIED_VOLATILITY, implied_volatility, 0.0);
  }
  void add_cap_floor_lets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>>> cap_floor_lets) {
    fbb_.AddOffset(CapFloorResponse::VT_CAP_FLOOR_LETS, cap_floor_lets);
  }
  explicit CapFloorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CapFloorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CapFloorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CapFloorResponse> CreateCapFloorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double atm_rate = 0.0,
    double implied_volatility = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>>> cap_floor_lets = 0) {
  CapFloorResponseBuilder builder_(_fbb);
  builder_.add_implied_volatility(implied_volatility);
  builder_.add_atm_rate(atm_rate);
  builder_.add_npv(npv);
  builder_.add_cap_floor_lets(cap_floor_lets);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CapFloorResponse> CreateCapFloorResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double atm_rate = 0.0,
    double implied_volatility = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::CapFloorLet>> *cap_floor_lets = nullptr) {
  auto cap_floor_lets__ = cap_floor_lets ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CapFloorLet>>(*cap_floor_lets) : 0;
  return quantra::CreateCapFloorResponse(
      _fbb,
      npv,
      atm_rate,
      implied_volatility,
      cap_floor_lets__);
}

struct PriceCapFloorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriceCapFloorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAP_FLOORS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>> *cap_floors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>> *>(VT_CAP_FLOORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAP_FLOORS) &&
           verifier.VerifyVector(cap_floors()) &&
           verifier.VerifyVectorOfTables(cap_floors()) &&
           verifier.EndTable();
  }
};

struct PriceCapFloorResponseBuilder {
  typedef PriceCapFloorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cap_floors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>>> cap_floors) {
    fbb_.AddOffset(PriceCapFloorResponse::VT_CAP_FLOORS, cap_floors);
  }
  explicit PriceCapFloorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriceCapFloorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriceCapFloorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriceCapFloorResponse> CreatePriceCapFloorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>>> cap_floors = 0) {
  PriceCapFloorResponseBuilder builder_(_fbb);
  builder_.add_cap_floors(cap_floors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PriceCapFloorResponse> CreatePriceCapFloorResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::CapFloorResponse>> *cap_floors = nullptr) {
  auto cap_floors__ = cap_floors ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CapFloorResponse>>(*cap_floors) : 0;
  return quantra::CreatePriceCapFloorResponse(
      _fbb,
      cap_floors__);
}

inline const quantra::PriceCapFloorResponse *GetPriceCapFloorResponse(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::PriceCapFloorResponse>(buf);
}

inline const quantra::PriceCapFloorResponse *GetSizePrefixedPriceCapFloorResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::PriceCapFloorResponse>(buf);
}

inline bool VerifyPriceCapFloorResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::PriceCapFloorResponse>(nullptr);
}

inline bool VerifySizePrefixedPriceCapFloorResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::PriceCapFloorResponse>(nullptr);
}

inline void FinishPriceCapFloorResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceCapFloorResponse> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPriceCapFloorResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceCapFloorResponse> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_CAPFLOORRESPONSE_QUANTRA_H_
