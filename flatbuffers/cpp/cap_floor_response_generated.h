// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAPFLOORRESPONSE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_CAPFLOORRESPONSE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace quantra {

struct CapFloorLet;
struct CapFloorLetBuilder;
struct CapFloorLetT;

struct CapFloorResponse;
struct CapFloorResponseBuilder;
struct CapFloorResponseT;

struct PriceCapFloorResponse;
struct PriceCapFloorResponseBuilder;
struct PriceCapFloorResponseT;

struct CapFloorLetT : public ::flatbuffers::NativeTable {
  typedef CapFloorLet TableType;
  std::string payment_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  std::string fixing_date{};
  double strike = 0.0;
  double forward_rate = 0.0;
  double discount = 0.0;
  double price = 0.0;
};

struct CapFloorLet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CapFloorLetT NativeTableType;
  typedef CapFloorLetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYMENT_DATE = 4,
    VT_ACCRUAL_START_DATE = 6,
    VT_ACCRUAL_END_DATE = 8,
    VT_FIXING_DATE = 10,
    VT_STRIKE = 12,
    VT_FORWARD_RATE = 14,
    VT_DISCOUNT = 16,
    VT_PRICE = 18
  };
  const ::flatbuffers::String *payment_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  double strike() const {
    return GetField<double>(VT_STRIKE, 0.0);
  }
  double forward_rate() const {
    return GetField<double>(VT_FORWARD_RATE, 0.0);
  }
  double discount() const {
    return GetField<double>(VT_DISCOUNT, 0.0);
  }
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYMENT_DATE) &&
           verifier.VerifyString(payment_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyField<double>(verifier, VT_STRIKE, 8) &&
           VerifyField<double>(verifier, VT_FORWARD_RATE, 8) &&
           VerifyField<double>(verifier, VT_DISCOUNT, 8) &&
           VerifyField<double>(verifier, VT_PRICE, 8) &&
           verifier.EndTable();
  }
  CapFloorLetT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CapFloorLetT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CapFloorLet> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorLetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CapFloorLetBuilder {
  typedef CapFloorLet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payment_date(::flatbuffers::Offset<::flatbuffers::String> payment_date) {
    fbb_.AddOffset(CapFloorLet::VT_PAYMENT_DATE, payment_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(CapFloorLet::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(CapFloorLet::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(CapFloorLet::VT_FIXING_DATE, fixing_date);
  }
  void add_strike(double strike) {
    fbb_.AddElement<double>(CapFloorLet::VT_STRIKE, strike, 0.0);
  }
  void add_forward_rate(double forward_rate) {
    fbb_.AddElement<double>(CapFloorLet::VT_FORWARD_RATE, forward_rate, 0.0);
  }
  void add_discount(double discount) {
    fbb_.AddElement<double>(CapFloorLet::VT_DISCOUNT, discount, 0.0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(CapFloorLet::VT_PRICE, price, 0.0);
  }
  explicit CapFloorLetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CapFloorLet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CapFloorLet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CapFloorLet> CreateCapFloorLet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> payment_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    double strike = 0.0,
    double forward_rate = 0.0,
    double discount = 0.0,
    double price = 0.0) {
  CapFloorLetBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_discount(discount);
  builder_.add_forward_rate(forward_rate);
  builder_.add_strike(strike);
  builder_.add_fixing_date(fixing_date);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_payment_date(payment_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CapFloorLet> CreateCapFloorLetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *payment_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    const char *fixing_date = nullptr,
    double strike = 0.0,
    double forward_rate = 0.0,
    double discount = 0.0,
    double price = 0.0) {
  auto payment_date__ = payment_date ? _fbb.CreateString(payment_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  return quantra::CreateCapFloorLet(
      _fbb,
      payment_date__,
      accrual_start_date__,
      accrual_end_date__,
      fixing_date__,
      strike,
      forward_rate,
      discount,
      price);
}

::flatbuffers::Offset<CapFloorLet> CreateCapFloorLet(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorLetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CapFloorResponseT : public ::flatbuffers::NativeTable {
  typedef CapFloorResponse TableType;
  double npv = 0.0;
  double atm_rate = 0.0;
  double implied_volatility = 0.0;
  std::vector<std::unique_ptr<quantra::CapFloorLetT>> cap_floor_lets{};
  CapFloorResponseT() = default;
  CapFloorResponseT(const CapFloorResponseT &o);
  CapFloorResponseT(CapFloorResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  CapFloorResponseT &operator=(CapFloorResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct CapFloorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CapFloorResponseT NativeTableType;
  typedef CapFloorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_ATM_RATE = 6,
    VT_IMPLIED_VOLATILITY = 8,
    VT_CAP_FLOOR_LETS = 10
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double atm_rate() const {
    return GetField<double>(VT_ATM_RATE, 0.0);
  }
  double implied_volatility() const {
    return GetField<double>(VT_IMPLIED_VOLATILITY, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>> *cap_floor_lets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>> *>(VT_CAP_FLOOR_LETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_ATM_RATE, 8) &&
           VerifyField<double>(verifier, VT_IMPLIED_VOLATILITY, 8) &&
           VerifyOffset(verifier, VT_CAP_FLOOR_LETS) &&
           verifier.VerifyVector(cap_floor_lets()) &&
           verifier.VerifyVectorOfTables(cap_floor_lets()) &&
           verifier.EndTable();
  }
  CapFloorResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CapFloorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CapFloorResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CapFloorResponseBuilder {
  typedef CapFloorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(CapFloorResponse::VT_NPV, npv, 0.0);
  }
  void add_atm_rate(double atm_rate) {
    fbb_.AddElement<double>(CapFloorResponse::VT_ATM_RATE, atm_rate, 0.0);
  }
  void add_implied_volatility(double implied_volatility) {
    fbb_.AddElement<double>(CapFloorResponse::VT_IMPLIED_VOLATILITY, implied_volatility, 0.0);
  }
  void add_cap_floor_lets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>>> cap_floor_lets) {
    fbb_.AddOffset(CapFloorResponse::VT_CAP_FLOOR_LETS, cap_floor_lets);
  }
  explicit CapFloorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CapFloorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CapFloorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CapFloorResponse> CreateCapFloorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double atm_rate = 0.0,
    double implied_volatility = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorLet>>> cap_floor_lets = 0) {
  CapFloorResponseBuilder builder_(_fbb);
  builder_.add_implied_volatility(implied_volatility);
  builder_.add_atm_rate(atm_rate);
  builder_.add_npv(npv);
  builder_.add_cap_floor_lets(cap_floor_lets);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CapFloorResponse> CreateCapFloorResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double atm_rate = 0.0,
    double implied_volatility = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::CapFloorLet>> *cap_floor_lets = nullptr) {
  auto cap_floor_lets__ = cap_floor_lets ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CapFloorLet>>(*cap_floor_lets) : 0;
  return quantra::CreateCapFloorResponse(
      _fbb,
      npv,
      atm_rate,
      implied_volatility,
      cap_floor_lets__);
}

::flatbuffers::Offset<CapFloorResponse> CreateCapFloorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriceCapFloorResponseT : public ::flatbuffers::NativeTable {
  typedef PriceCapFloorResponse TableType;
  std::vector<std::unique_ptr<quantra::CapFloorResponseT>> cap_floors{};
  PriceCapFloorResponseT() = default;
  PriceCapFloorResponseT(const PriceCapFloorResponseT &o);
  PriceCapFloorResponseT(PriceCapFloorResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  PriceCapFloorResponseT &operator=(PriceCapFloorResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct PriceCapFloorResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriceCapFloorResponseT NativeTableType;
  typedef PriceCapFloorResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAP_FLOORS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>> *cap_floors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>> *>(VT_CAP_FLOORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAP_FLOORS) &&
           verifier.VerifyVector(cap_floors()) &&
           verifier.VerifyVectorOfTables(cap_floors()) &&
           verifier.EndTable();
  }
  PriceCapFloorResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriceCapFloorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PriceCapFloorResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PriceCapFloorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriceCapFloorResponseBuilder {
  typedef PriceCapFloorResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cap_floors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>>> cap_floors) {
    fbb_.AddOffset(PriceCapFloorResponse::VT_CAP_FLOORS, cap_floors);
  }
  explicit PriceCapFloorResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriceCapFloorResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriceCapFloorResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriceCapFloorResponse> CreatePriceCapFloorResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CapFloorResponse>>> cap_floors = 0) {
  PriceCapFloorResponseBuilder builder_(_fbb);
  builder_.add_cap_floors(cap_floors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PriceCapFloorResponse> CreatePriceCapFloorResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::CapFloorResponse>> *cap_floors = nullptr) {
  auto cap_floors__ = cap_floors ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CapFloorResponse>>(*cap_floors) : 0;
  return quantra::CreatePriceCapFloorResponse(
      _fbb,
      cap_floors__);
}

::flatbuffers::Offset<PriceCapFloorResponse> CreatePriceCapFloorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const PriceCapFloorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CapFloorLetT *CapFloorLet::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CapFloorLetT>(new CapFloorLetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CapFloorLet::UnPackTo(CapFloorLetT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = payment_date(); if (_e) _o->payment_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = strike(); _o->strike = _e; }
  { auto _e = forward_rate(); _o->forward_rate = _e; }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = price(); _o->price = _e; }
}

inline ::flatbuffers::Offset<CapFloorLet> CapFloorLet::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorLetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCapFloorLet(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CapFloorLet> CreateCapFloorLet(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorLetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CapFloorLetT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _payment_date = _o->payment_date.empty() ? 0 : _fbb.CreateString(_o->payment_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _strike = _o->strike;
  auto _forward_rate = _o->forward_rate;
  auto _discount = _o->discount;
  auto _price = _o->price;
  return quantra::CreateCapFloorLet(
      _fbb,
      _payment_date,
      _accrual_start_date,
      _accrual_end_date,
      _fixing_date,
      _strike,
      _forward_rate,
      _discount,
      _price);
}

inline CapFloorResponseT::CapFloorResponseT(const CapFloorResponseT &o)
      : npv(o.npv),
        atm_rate(o.atm_rate),
        implied_volatility(o.implied_volatility) {
  cap_floor_lets.reserve(o.cap_floor_lets.size());
  for (const auto &cap_floor_lets_ : o.cap_floor_lets) { cap_floor_lets.emplace_back((cap_floor_lets_) ? new quantra::CapFloorLetT(*cap_floor_lets_) : nullptr); }
}

inline CapFloorResponseT &CapFloorResponseT::operator=(CapFloorResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(npv, o.npv);
  std::swap(atm_rate, o.atm_rate);
  std::swap(implied_volatility, o.implied_volatility);
  std::swap(cap_floor_lets, o.cap_floor_lets);
  return *this;
}

inline CapFloorResponseT *CapFloorResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CapFloorResponseT>(new CapFloorResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CapFloorResponse::UnPackTo(CapFloorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = npv(); _o->npv = _e; }
  { auto _e = atm_rate(); _o->atm_rate = _e; }
  { auto _e = implied_volatility(); _o->implied_volatility = _e; }
  { auto _e = cap_floor_lets(); if (_e) { _o->cap_floor_lets.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cap_floor_lets[_i]) { _e->Get(_i)->UnPackTo(_o->cap_floor_lets[_i].get(), _resolver); } else { _o->cap_floor_lets[_i] = std::unique_ptr<quantra::CapFloorLetT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->cap_floor_lets.resize(0); } }
}

inline ::flatbuffers::Offset<CapFloorResponse> CapFloorResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCapFloorResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CapFloorResponse> CreateCapFloorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CapFloorResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _npv = _o->npv;
  auto _atm_rate = _o->atm_rate;
  auto _implied_volatility = _o->implied_volatility;
  auto _cap_floor_lets = _o->cap_floor_lets.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CapFloorLet>> (_o->cap_floor_lets.size(), [](size_t i, _VectorArgs *__va) { return CreateCapFloorLet(*__va->__fbb, __va->__o->cap_floor_lets[i].get(), __va->__rehasher); }, &_va ) : 0;
  return quantra::CreateCapFloorResponse(
      _fbb,
      _npv,
      _atm_rate,
      _implied_volatility,
      _cap_floor_lets);
}

inline PriceCapFloorResponseT::PriceCapFloorResponseT(const PriceCapFloorResponseT &o) {
  cap_floors.reserve(o.cap_floors.size());
  for (const auto &cap_floors_ : o.cap_floors) { cap_floors.emplace_back((cap_floors_) ? new quantra::CapFloorResponseT(*cap_floors_) : nullptr); }
}

inline PriceCapFloorResponseT &PriceCapFloorResponseT::operator=(PriceCapFloorResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(cap_floors, o.cap_floors);
  return *this;
}

inline PriceCapFloorResponseT *PriceCapFloorResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PriceCapFloorResponseT>(new PriceCapFloorResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PriceCapFloorResponse::UnPackTo(PriceCapFloorResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cap_floors(); if (_e) { _o->cap_floors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cap_floors[_i]) { _e->Get(_i)->UnPackTo(_o->cap_floors[_i].get(), _resolver); } else { _o->cap_floors[_i] = std::unique_ptr<quantra::CapFloorResponseT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->cap_floors.resize(0); } }
}

inline ::flatbuffers::Offset<PriceCapFloorResponse> PriceCapFloorResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PriceCapFloorResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriceCapFloorResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PriceCapFloorResponse> CreatePriceCapFloorResponse(::flatbuffers::FlatBufferBuilder &_fbb, const PriceCapFloorResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PriceCapFloorResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cap_floors = _o->cap_floors.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CapFloorResponse>> (_o->cap_floors.size(), [](size_t i, _VectorArgs *__va) { return CreateCapFloorResponse(*__va->__fbb, __va->__o->cap_floors[i].get(), __va->__rehasher); }, &_va ) : 0;
  return quantra::CreatePriceCapFloorResponse(
      _fbb,
      _cap_floors);
}

inline const quantra::PriceCapFloorResponse *GetPriceCapFloorResponse(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::PriceCapFloorResponse>(buf);
}

inline const quantra::PriceCapFloorResponse *GetSizePrefixedPriceCapFloorResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::PriceCapFloorResponse>(buf);
}

inline bool VerifyPriceCapFloorResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::PriceCapFloorResponse>(nullptr);
}

inline bool VerifySizePrefixedPriceCapFloorResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::PriceCapFloorResponse>(nullptr);
}

inline void FinishPriceCapFloorResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceCapFloorResponse> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPriceCapFloorResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceCapFloorResponse> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<quantra::PriceCapFloorResponseT> UnPackPriceCapFloorResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::PriceCapFloorResponseT>(GetPriceCapFloorResponse(buf)->UnPack(res));
}

inline std::unique_ptr<quantra::PriceCapFloorResponseT> UnPackSizePrefixedPriceCapFloorResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::PriceCapFloorResponseT>(GetSizePrefixedPriceCapFloorResponse(buf)->UnPack(res));
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_CAPFLOORRESPONSE_QUANTRA_H_
