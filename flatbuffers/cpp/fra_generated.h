// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRA_QUANTRA_H_
#define FLATBUFFERS_GENERATED_FRA_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace quantra {

struct Fixing;
struct FixingBuilder;

struct Index;
struct IndexBuilder;

struct FRA;
struct FRABuilder;

namespace enums {

enum DayCounter : int8_t {
  DayCounter_Actual360 = 0,
  DayCounter_Actual365Fixed = 1,
  DayCounter_Actual365NoLeap = 2,
  DayCounter_ActualActual = 3,
  DayCounter_ActualActualISMA = 4,
  DayCounter_ActualActualBond = 5,
  DayCounter_ActualActualISDA = 6,
  DayCounter_ActualActualHistorical = 7,
  DayCounter_ActualActual365 = 8,
  DayCounter_ActualActualAFB = 9,
  DayCounter_ActualActualEuro = 10,
  DayCounter_Business252 = 11,
  DayCounter_One = 12,
  DayCounter_Simple = 13,
  DayCounter_Thirty360 = 14,
  DayCounter_MIN = DayCounter_Actual360,
  DayCounter_MAX = DayCounter_Thirty360
};

inline const DayCounter (&EnumValuesDayCounter())[15] {
  static const DayCounter values[] = {
    DayCounter_Actual360,
    DayCounter_Actual365Fixed,
    DayCounter_Actual365NoLeap,
    DayCounter_ActualActual,
    DayCounter_ActualActualISMA,
    DayCounter_ActualActualBond,
    DayCounter_ActualActualISDA,
    DayCounter_ActualActualHistorical,
    DayCounter_ActualActual365,
    DayCounter_ActualActualAFB,
    DayCounter_ActualActualEuro,
    DayCounter_Business252,
    DayCounter_One,
    DayCounter_Simple,
    DayCounter_Thirty360
  };
  return values;
}

inline const char * const *EnumNamesDayCounter() {
  static const char * const names[16] = {
    "Actual360",
    "Actual365Fixed",
    "Actual365NoLeap",
    "ActualActual",
    "ActualActualISMA",
    "ActualActualBond",
    "ActualActualISDA",
    "ActualActualHistorical",
    "ActualActual365",
    "ActualActualAFB",
    "ActualActualEuro",
    "Business252",
    "One",
    "Simple",
    "Thirty360",
    nullptr
  };
  return names;
}

inline const char *EnumNameDayCounter(DayCounter e) {
  if (::flatbuffers::IsOutRange(e, DayCounter_Actual360, DayCounter_Thirty360)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDayCounter()[index];
}

enum Interpolator : int8_t {
  Interpolator_BackwardFlat = 0,
  Interpolator_ForwardFlat = 1,
  Interpolator_Linear = 2,
  Interpolator_LogCubic = 3,
  Interpolator_LogLinear = 4,
  Interpolator_MIN = Interpolator_BackwardFlat,
  Interpolator_MAX = Interpolator_LogLinear
};

inline const Interpolator (&EnumValuesInterpolator())[5] {
  static const Interpolator values[] = {
    Interpolator_BackwardFlat,
    Interpolator_ForwardFlat,
    Interpolator_Linear,
    Interpolator_LogCubic,
    Interpolator_LogLinear
  };
  return values;
}

inline const char * const *EnumNamesInterpolator() {
  static const char * const names[6] = {
    "BackwardFlat",
    "ForwardFlat",
    "Linear",
    "LogCubic",
    "LogLinear",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterpolator(Interpolator e) {
  if (::flatbuffers::IsOutRange(e, Interpolator_BackwardFlat, Interpolator_LogLinear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterpolator()[index];
}

enum BootstrapTrait : int8_t {
  BootstrapTrait_Discount = 0,
  BootstrapTrait_FwdRate = 1,
  BootstrapTrait_InterpolatedDiscount = 2,
  BootstrapTrait_InterpolatedFwd = 3,
  BootstrapTrait_InterpolatedZero = 4,
  BootstrapTrait_ZeroRate = 5,
  BootstrapTrait_MIN = BootstrapTrait_Discount,
  BootstrapTrait_MAX = BootstrapTrait_ZeroRate
};

inline const BootstrapTrait (&EnumValuesBootstrapTrait())[6] {
  static const BootstrapTrait values[] = {
    BootstrapTrait_Discount,
    BootstrapTrait_FwdRate,
    BootstrapTrait_InterpolatedDiscount,
    BootstrapTrait_InterpolatedFwd,
    BootstrapTrait_InterpolatedZero,
    BootstrapTrait_ZeroRate
  };
  return values;
}

inline const char * const *EnumNamesBootstrapTrait() {
  static const char * const names[7] = {
    "Discount",
    "FwdRate",
    "InterpolatedDiscount",
    "InterpolatedFwd",
    "InterpolatedZero",
    "ZeroRate",
    nullptr
  };
  return names;
}

inline const char *EnumNameBootstrapTrait(BootstrapTrait e) {
  if (::flatbuffers::IsOutRange(e, BootstrapTrait_Discount, BootstrapTrait_ZeroRate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBootstrapTrait()[index];
}

enum TimeUnit : int8_t {
  TimeUnit_Days = 0,
  TimeUnit_Hours = 1,
  TimeUnit_Microseconds = 2,
  TimeUnit_Milliseconds = 3,
  TimeUnit_Minutes = 4,
  TimeUnit_Months = 5,
  TimeUnit_Seconds = 6,
  TimeUnit_Weeks = 7,
  TimeUnit_Years = 8,
  TimeUnit_MIN = TimeUnit_Days,
  TimeUnit_MAX = TimeUnit_Years
};

inline const TimeUnit (&EnumValuesTimeUnit())[9] {
  static const TimeUnit values[] = {
    TimeUnit_Days,
    TimeUnit_Hours,
    TimeUnit_Microseconds,
    TimeUnit_Milliseconds,
    TimeUnit_Minutes,
    TimeUnit_Months,
    TimeUnit_Seconds,
    TimeUnit_Weeks,
    TimeUnit_Years
  };
  return values;
}

inline const char * const *EnumNamesTimeUnit() {
  static const char * const names[10] = {
    "Days",
    "Hours",
    "Microseconds",
    "Milliseconds",
    "Minutes",
    "Months",
    "Seconds",
    "Weeks",
    "Years",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeUnit(TimeUnit e) {
  if (::flatbuffers::IsOutRange(e, TimeUnit_Days, TimeUnit_Years)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeUnit()[index];
}

enum Calendar : int8_t {
  Calendar_Argentina = 0,
  Calendar_Australia = 1,
  Calendar_BespokeCalendar = 2,
  Calendar_Brazil = 3,
  Calendar_Canada = 4,
  Calendar_China = 5,
  Calendar_CzechRepublic = 6,
  Calendar_Denmark = 7,
  Calendar_Finland = 8,
  Calendar_Germany = 9,
  Calendar_HongKong = 10,
  Calendar_Hungary = 11,
  Calendar_Iceland = 12,
  Calendar_India = 13,
  Calendar_Indonesia = 14,
  Calendar_Israel = 15,
  Calendar_Italy = 16,
  Calendar_Japan = 17,
  Calendar_Mexico = 18,
  Calendar_NewZealand = 19,
  Calendar_Norway = 20,
  Calendar_NullCalendar = 21,
  Calendar_Poland = 22,
  Calendar_Romania = 23,
  Calendar_Russia = 24,
  Calendar_SaudiArabia = 25,
  Calendar_Singapore = 26,
  Calendar_Slovakia = 27,
  Calendar_SouthAfrica = 28,
  Calendar_SouthKorea = 29,
  Calendar_Sweden = 30,
  Calendar_Switzerland = 31,
  Calendar_TARGET = 32,
  Calendar_Taiwan = 33,
  Calendar_Turkey = 34,
  Calendar_Ukraine = 35,
  Calendar_UnitedKingdom = 36,
  Calendar_UnitedStates = 37,
  Calendar_UnitedStatesGovernmentBond = 38,
  Calendar_UnitedStatesNERC = 39,
  Calendar_UnitedStatesNYSE = 40,
  Calendar_UnitedStatesSettlement = 41,
  Calendar_WeekendsOnly = 42,
  Calendar_MIN = Calendar_Argentina,
  Calendar_MAX = Calendar_WeekendsOnly
};

inline const Calendar (&EnumValuesCalendar())[43] {
  static const Calendar values[] = {
    Calendar_Argentina,
    Calendar_Australia,
    Calendar_BespokeCalendar,
    Calendar_Brazil,
    Calendar_Canada,
    Calendar_China,
    Calendar_CzechRepublic,
    Calendar_Denmark,
    Calendar_Finland,
    Calendar_Germany,
    Calendar_HongKong,
    Calendar_Hungary,
    Calendar_Iceland,
    Calendar_India,
    Calendar_Indonesia,
    Calendar_Israel,
    Calendar_Italy,
    Calendar_Japan,
    Calendar_Mexico,
    Calendar_NewZealand,
    Calendar_Norway,
    Calendar_NullCalendar,
    Calendar_Poland,
    Calendar_Romania,
    Calendar_Russia,
    Calendar_SaudiArabia,
    Calendar_Singapore,
    Calendar_Slovakia,
    Calendar_SouthAfrica,
    Calendar_SouthKorea,
    Calendar_Sweden,
    Calendar_Switzerland,
    Calendar_TARGET,
    Calendar_Taiwan,
    Calendar_Turkey,
    Calendar_Ukraine,
    Calendar_UnitedKingdom,
    Calendar_UnitedStates,
    Calendar_UnitedStatesGovernmentBond,
    Calendar_UnitedStatesNERC,
    Calendar_UnitedStatesNYSE,
    Calendar_UnitedStatesSettlement,
    Calendar_WeekendsOnly
  };
  return values;
}

inline const char * const *EnumNamesCalendar() {
  static const char * const names[44] = {
    "Argentina",
    "Australia",
    "BespokeCalendar",
    "Brazil",
    "Canada",
    "China",
    "CzechRepublic",
    "Denmark",
    "Finland",
    "Germany",
    "HongKong",
    "Hungary",
    "Iceland",
    "India",
    "Indonesia",
    "Israel",
    "Italy",
    "Japan",
    "Mexico",
    "NewZealand",
    "Norway",
    "NullCalendar",
    "Poland",
    "Romania",
    "Russia",
    "SaudiArabia",
    "Singapore",
    "Slovakia",
    "SouthAfrica",
    "SouthKorea",
    "Sweden",
    "Switzerland",
    "TARGET",
    "Taiwan",
    "Turkey",
    "Ukraine",
    "UnitedKingdom",
    "UnitedStates",
    "UnitedStatesGovernmentBond",
    "UnitedStatesNERC",
    "UnitedStatesNYSE",
    "UnitedStatesSettlement",
    "WeekendsOnly",
    nullptr
  };
  return names;
}

inline const char *EnumNameCalendar(Calendar e) {
  if (::flatbuffers::IsOutRange(e, Calendar_Argentina, Calendar_WeekendsOnly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCalendar()[index];
}

enum BusinessDayConvention : int8_t {
  BusinessDayConvention_Following = 0,
  BusinessDayConvention_HalfMonthModifiedFollowing = 1,
  BusinessDayConvention_ModifiedFollowing = 2,
  BusinessDayConvention_ModifiedPreceding = 3,
  BusinessDayConvention_Nearest = 4,
  BusinessDayConvention_Preceding = 5,
  BusinessDayConvention_Unadjusted = 6,
  BusinessDayConvention_MIN = BusinessDayConvention_Following,
  BusinessDayConvention_MAX = BusinessDayConvention_Unadjusted
};

inline const BusinessDayConvention (&EnumValuesBusinessDayConvention())[7] {
  static const BusinessDayConvention values[] = {
    BusinessDayConvention_Following,
    BusinessDayConvention_HalfMonthModifiedFollowing,
    BusinessDayConvention_ModifiedFollowing,
    BusinessDayConvention_ModifiedPreceding,
    BusinessDayConvention_Nearest,
    BusinessDayConvention_Preceding,
    BusinessDayConvention_Unadjusted
  };
  return values;
}

inline const char * const *EnumNamesBusinessDayConvention() {
  static const char * const names[8] = {
    "Following",
    "HalfMonthModifiedFollowing",
    "ModifiedFollowing",
    "ModifiedPreceding",
    "Nearest",
    "Preceding",
    "Unadjusted",
    nullptr
  };
  return names;
}

inline const char *EnumNameBusinessDayConvention(BusinessDayConvention e) {
  if (::flatbuffers::IsOutRange(e, BusinessDayConvention_Following, BusinessDayConvention_Unadjusted)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBusinessDayConvention()[index];
}

enum Frequency : int8_t {
  Frequency_Annual = 0,
  Frequency_Bimonthly = 1,
  Frequency_Biweekly = 2,
  Frequency_Daily = 3,
  Frequency_EveryFourthMonth = 4,
  Frequency_EveryFourthWeek = 5,
  Frequency_Monthly = 6,
  Frequency_NoFrequency = 7,
  Frequency_Once = 8,
  Frequency_OtherFrequency = 9,
  Frequency_Quarterly = 10,
  Frequency_Semiannual = 11,
  Frequency_Weekly = 12,
  Frequency_MIN = Frequency_Annual,
  Frequency_MAX = Frequency_Weekly
};

inline const Frequency (&EnumValuesFrequency())[13] {
  static const Frequency values[] = {
    Frequency_Annual,
    Frequency_Bimonthly,
    Frequency_Biweekly,
    Frequency_Daily,
    Frequency_EveryFourthMonth,
    Frequency_EveryFourthWeek,
    Frequency_Monthly,
    Frequency_NoFrequency,
    Frequency_Once,
    Frequency_OtherFrequency,
    Frequency_Quarterly,
    Frequency_Semiannual,
    Frequency_Weekly
  };
  return values;
}

inline const char * const *EnumNamesFrequency() {
  static const char * const names[14] = {
    "Annual",
    "Bimonthly",
    "Biweekly",
    "Daily",
    "EveryFourthMonth",
    "EveryFourthWeek",
    "Monthly",
    "NoFrequency",
    "Once",
    "OtherFrequency",
    "Quarterly",
    "Semiannual",
    "Weekly",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrequency(Frequency e) {
  if (::flatbuffers::IsOutRange(e, Frequency_Annual, Frequency_Weekly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFrequency()[index];
}

enum DateGenerationRule : int8_t {
  DateGenerationRule_Backward = 0,
  DateGenerationRule_CDS = 1,
  DateGenerationRule_Forward = 2,
  DateGenerationRule_OldCDS = 3,
  DateGenerationRule_ThirdWednesday = 4,
  DateGenerationRule_Twentieth = 5,
  DateGenerationRule_TwentiethIMM = 6,
  DateGenerationRule_Zero = 7,
  DateGenerationRule_MIN = DateGenerationRule_Backward,
  DateGenerationRule_MAX = DateGenerationRule_Zero
};

inline const DateGenerationRule (&EnumValuesDateGenerationRule())[8] {
  static const DateGenerationRule values[] = {
    DateGenerationRule_Backward,
    DateGenerationRule_CDS,
    DateGenerationRule_Forward,
    DateGenerationRule_OldCDS,
    DateGenerationRule_ThirdWednesday,
    DateGenerationRule_Twentieth,
    DateGenerationRule_TwentiethIMM,
    DateGenerationRule_Zero
  };
  return values;
}

inline const char * const *EnumNamesDateGenerationRule() {
  static const char * const names[9] = {
    "Backward",
    "CDS",
    "Forward",
    "OldCDS",
    "ThirdWednesday",
    "Twentieth",
    "TwentiethIMM",
    "Zero",
    nullptr
  };
  return names;
}

inline const char *EnumNameDateGenerationRule(DateGenerationRule e) {
  if (::flatbuffers::IsOutRange(e, DateGenerationRule_Backward, DateGenerationRule_Zero)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDateGenerationRule()[index];
}

enum Ibor : int8_t {
  Ibor_Euribor10M = 0,
  Ibor_Euribor11M = 1,
  Ibor_Euribor1M = 2,
  Ibor_Euribor1Y = 3,
  Ibor_Euribor2M = 4,
  Ibor_Euribor2W = 5,
  Ibor_Euribor365_10M = 6,
  Ibor_Euribor365_11M = 7,
  Ibor_Euribor365_1M = 8,
  Ibor_Euribor365_1Y = 9,
  Ibor_Euribor365_2M = 10,
  Ibor_Euribor365_2W = 11,
  Ibor_Euribor365_3M = 12,
  Ibor_Euribor365_3W = 13,
  Ibor_Euribor365_4M = 14,
  Ibor_Euribor365_5M = 15,
  Ibor_Euribor365_6M = 16,
  Ibor_Euribor365_7M = 17,
  Ibor_Euribor365_8M = 18,
  Ibor_Euribor365_9M = 19,
  Ibor_Euribor365_SW = 20,
  Ibor_Euribor3M = 21,
  Ibor_Euribor3W = 22,
  Ibor_Euribor4M = 23,
  Ibor_Euribor5M = 24,
  Ibor_Euribor6M = 25,
  Ibor_Euribor7M = 26,
  Ibor_Euribor8M = 27,
  Ibor_Euribor9M = 28,
  Ibor_EuriborSW = 29,
  Ibor_MIN = Ibor_Euribor10M,
  Ibor_MAX = Ibor_EuriborSW
};

inline const Ibor (&EnumValuesIbor())[30] {
  static const Ibor values[] = {
    Ibor_Euribor10M,
    Ibor_Euribor11M,
    Ibor_Euribor1M,
    Ibor_Euribor1Y,
    Ibor_Euribor2M,
    Ibor_Euribor2W,
    Ibor_Euribor365_10M,
    Ibor_Euribor365_11M,
    Ibor_Euribor365_1M,
    Ibor_Euribor365_1Y,
    Ibor_Euribor365_2M,
    Ibor_Euribor365_2W,
    Ibor_Euribor365_3M,
    Ibor_Euribor365_3W,
    Ibor_Euribor365_4M,
    Ibor_Euribor365_5M,
    Ibor_Euribor365_6M,
    Ibor_Euribor365_7M,
    Ibor_Euribor365_8M,
    Ibor_Euribor365_9M,
    Ibor_Euribor365_SW,
    Ibor_Euribor3M,
    Ibor_Euribor3W,
    Ibor_Euribor4M,
    Ibor_Euribor5M,
    Ibor_Euribor6M,
    Ibor_Euribor7M,
    Ibor_Euribor8M,
    Ibor_Euribor9M,
    Ibor_EuriborSW
  };
  return values;
}

inline const char * const *EnumNamesIbor() {
  static const char * const names[31] = {
    "Euribor10M",
    "Euribor11M",
    "Euribor1M",
    "Euribor1Y",
    "Euribor2M",
    "Euribor2W",
    "Euribor365_10M",
    "Euribor365_11M",
    "Euribor365_1M",
    "Euribor365_1Y",
    "Euribor365_2M",
    "Euribor365_2W",
    "Euribor365_3M",
    "Euribor365_3W",
    "Euribor365_4M",
    "Euribor365_5M",
    "Euribor365_6M",
    "Euribor365_7M",
    "Euribor365_8M",
    "Euribor365_9M",
    "Euribor365_SW",
    "Euribor3M",
    "Euribor3W",
    "Euribor4M",
    "Euribor5M",
    "Euribor6M",
    "Euribor7M",
    "Euribor8M",
    "Euribor9M",
    "EuriborSW",
    nullptr
  };
  return names;
}

inline const char *EnumNameIbor(Ibor e) {
  if (::flatbuffers::IsOutRange(e, Ibor_Euribor10M, Ibor_EuriborSW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIbor()[index];
}

enum Compounding : int8_t {
  Compounding_Compounded = 0,
  Compounding_Continuous = 1,
  Compounding_Simple = 2,
  Compounding_SimpleThenCompounded = 3,
  Compounding_MIN = Compounding_Compounded,
  Compounding_MAX = Compounding_SimpleThenCompounded
};

inline const Compounding (&EnumValuesCompounding())[4] {
  static const Compounding values[] = {
    Compounding_Compounded,
    Compounding_Continuous,
    Compounding_Simple,
    Compounding_SimpleThenCompounded
  };
  return values;
}

inline const char * const *EnumNamesCompounding() {
  static const char * const names[5] = {
    "Compounded",
    "Continuous",
    "Simple",
    "SimpleThenCompounded",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompounding(Compounding e) {
  if (::flatbuffers::IsOutRange(e, Compounding_Compounded, Compounding_SimpleThenCompounded)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompounding()[index];
}

enum SwapType : int8_t {
  SwapType_Payer = 0,
  SwapType_Receiver = 1,
  SwapType_MIN = SwapType_Payer,
  SwapType_MAX = SwapType_Receiver
};

inline const SwapType (&EnumValuesSwapType())[2] {
  static const SwapType values[] = {
    SwapType_Payer,
    SwapType_Receiver
  };
  return values;
}

inline const char * const *EnumNamesSwapType() {
  static const char * const names[3] = {
    "Payer",
    "Receiver",
    nullptr
  };
  return names;
}

inline const char *EnumNameSwapType(SwapType e) {
  if (::flatbuffers::IsOutRange(e, SwapType_Payer, SwapType_Receiver)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSwapType()[index];
}

enum FRAType : int8_t {
  FRAType_Long = 0,
  FRAType_Short = 1,
  FRAType_MIN = FRAType_Long,
  FRAType_MAX = FRAType_Short
};

inline const FRAType (&EnumValuesFRAType())[2] {
  static const FRAType values[] = {
    FRAType_Long,
    FRAType_Short
  };
  return values;
}

inline const char * const *EnumNamesFRAType() {
  static const char * const names[3] = {
    "Long",
    "Short",
    nullptr
  };
  return names;
}

inline const char *EnumNameFRAType(FRAType e) {
  if (::flatbuffers::IsOutRange(e, FRAType_Long, FRAType_Short)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFRAType()[index];
}

enum CapFloorType : int8_t {
  CapFloorType_Cap = 0,
  CapFloorType_Floor = 1,
  CapFloorType_Collar = 2,
  CapFloorType_MIN = CapFloorType_Cap,
  CapFloorType_MAX = CapFloorType_Collar
};

inline const CapFloorType (&EnumValuesCapFloorType())[3] {
  static const CapFloorType values[] = {
    CapFloorType_Cap,
    CapFloorType_Floor,
    CapFloorType_Collar
  };
  return values;
}

inline const char * const *EnumNamesCapFloorType() {
  static const char * const names[4] = {
    "Cap",
    "Floor",
    "Collar",
    nullptr
  };
  return names;
}

inline const char *EnumNameCapFloorType(CapFloorType e) {
  if (::flatbuffers::IsOutRange(e, CapFloorType_Cap, CapFloorType_Collar)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCapFloorType()[index];
}

enum ExerciseType : int8_t {
  ExerciseType_European = 0,
  ExerciseType_Bermudan = 1,
  ExerciseType_American = 2,
  ExerciseType_MIN = ExerciseType_European,
  ExerciseType_MAX = ExerciseType_American
};

inline const ExerciseType (&EnumValuesExerciseType())[3] {
  static const ExerciseType values[] = {
    ExerciseType_European,
    ExerciseType_Bermudan,
    ExerciseType_American
  };
  return values;
}

inline const char * const *EnumNamesExerciseType() {
  static const char * const names[4] = {
    "European",
    "Bermudan",
    "American",
    nullptr
  };
  return names;
}

inline const char *EnumNameExerciseType(ExerciseType e) {
  if (::flatbuffers::IsOutRange(e, ExerciseType_European, ExerciseType_American)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExerciseType()[index];
}

enum SettlementType : int8_t {
  SettlementType_Physical = 0,
  SettlementType_Cash = 1,
  SettlementType_MIN = SettlementType_Physical,
  SettlementType_MAX = SettlementType_Cash
};

inline const SettlementType (&EnumValuesSettlementType())[2] {
  static const SettlementType values[] = {
    SettlementType_Physical,
    SettlementType_Cash
  };
  return values;
}

inline const char * const *EnumNamesSettlementType() {
  static const char * const names[3] = {
    "Physical",
    "Cash",
    nullptr
  };
  return names;
}

inline const char *EnumNameSettlementType(SettlementType e) {
  if (::flatbuffers::IsOutRange(e, SettlementType_Physical, SettlementType_Cash)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSettlementType()[index];
}

enum ProtectionSide : int8_t {
  ProtectionSide_Buyer = 0,
  ProtectionSide_Seller = 1,
  ProtectionSide_MIN = ProtectionSide_Buyer,
  ProtectionSide_MAX = ProtectionSide_Seller
};

inline const ProtectionSide (&EnumValuesProtectionSide())[2] {
  static const ProtectionSide values[] = {
    ProtectionSide_Buyer,
    ProtectionSide_Seller
  };
  return values;
}

inline const char * const *EnumNamesProtectionSide() {
  static const char * const names[3] = {
    "Buyer",
    "Seller",
    nullptr
  };
  return names;
}

inline const char *EnumNameProtectionSide(ProtectionSide e) {
  if (::flatbuffers::IsOutRange(e, ProtectionSide_Buyer, ProtectionSide_Seller)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProtectionSide()[index];
}

enum VolatilityType : int8_t {
  VolatilityType_ShiftedLognormal = 0,
  VolatilityType_Normal = 1,
  VolatilityType_MIN = VolatilityType_ShiftedLognormal,
  VolatilityType_MAX = VolatilityType_Normal
};

inline const VolatilityType (&EnumValuesVolatilityType())[2] {
  static const VolatilityType values[] = {
    VolatilityType_ShiftedLognormal,
    VolatilityType_Normal
  };
  return values;
}

inline const char * const *EnumNamesVolatilityType() {
  static const char * const names[3] = {
    "ShiftedLognormal",
    "Normal",
    nullptr
  };
  return names;
}

inline const char *EnumNameVolatilityType(VolatilityType e) {
  if (::flatbuffers::IsOutRange(e, VolatilityType_ShiftedLognormal, VolatilityType_Normal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVolatilityType()[index];
}

}  // namespace enums

struct Fixing FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FixingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_RATE = 6
  };
  const ::flatbuffers::String *date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           verifier.EndTable();
  }
};

struct FixingBuilder {
  typedef Fixing Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_date(::flatbuffers::Offset<::flatbuffers::String> date) {
    fbb_.AddOffset(Fixing::VT_DATE, date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(Fixing::VT_RATE, rate, 0.0f);
  }
  explicit FixingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Fixing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Fixing>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Fixing> CreateFixing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> date = 0,
    float rate = 0.0f) {
  FixingBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_date(date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Fixing> CreateFixingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *date = nullptr,
    float rate = 0.0f) {
  auto date__ = date ? _fbb.CreateString(date) : 0;
  return quantra::CreateFixing(
      _fbb,
      date__,
      rate);
}

struct Index FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERIOD_NUMBER = 4,
    VT_PERIOD_TIME_UNIT = 6,
    VT_SETTLEMENT_DAYS = 8,
    VT_CALENDAR = 10,
    VT_BUSINESS_DAY_CONVENTION = 12,
    VT_END_OF_MONTH = 14,
    VT_DAY_COUNTER = 16,
    VT_FIXINGS = 18
  };
  int32_t period_number() const {
    return GetField<int32_t>(VT_PERIOD_NUMBER, 0);
  }
  quantra::enums::TimeUnit period_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_PERIOD_TIME_UNIT, 0));
  }
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  bool end_of_month() const {
    return GetField<uint8_t>(VT_END_OF_MONTH, 0) != 0;
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>> *fixings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>> *>(VT_FIXINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PERIOD_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_PERIOD_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_END_OF_MONTH, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyOffset(verifier, VT_FIXINGS) &&
           verifier.VerifyVector(fixings()) &&
           verifier.VerifyVectorOfTables(fixings()) &&
           verifier.EndTable();
  }
};

struct IndexBuilder {
  typedef Index Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_period_number(int32_t period_number) {
    fbb_.AddElement<int32_t>(Index::VT_PERIOD_NUMBER, period_number, 0);
  }
  void add_period_time_unit(quantra::enums::TimeUnit period_time_unit) {
    fbb_.AddElement<int8_t>(Index::VT_PERIOD_TIME_UNIT, static_cast<int8_t>(period_time_unit), 0);
  }
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(Index::VT_SETTLEMENT_DAYS, settlement_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(Index::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(Index::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_end_of_month(bool end_of_month) {
    fbb_.AddElement<uint8_t>(Index::VT_END_OF_MONTH, static_cast<uint8_t>(end_of_month), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(Index::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_fixings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>>> fixings) {
    fbb_.AddOffset(Index::VT_FIXINGS, fixings);
  }
  explicit IndexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Index> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Index>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Index> CreateIndex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t period_number = 0,
    quantra::enums::TimeUnit period_time_unit = quantra::enums::TimeUnit_Days,
    int32_t settlement_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    bool end_of_month = false,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Fixing>>> fixings = 0) {
  IndexBuilder builder_(_fbb);
  builder_.add_fixings(fixings);
  builder_.add_settlement_days(settlement_days);
  builder_.add_period_number(period_number);
  builder_.add_day_counter(day_counter);
  builder_.add_end_of_month(end_of_month);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_period_time_unit(period_time_unit);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Index> CreateIndexDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t period_number = 0,
    quantra::enums::TimeUnit period_time_unit = quantra::enums::TimeUnit_Days,
    int32_t settlement_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    bool end_of_month = false,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    const std::vector<::flatbuffers::Offset<quantra::Fixing>> *fixings = nullptr) {
  auto fixings__ = fixings ? _fbb.CreateVector<::flatbuffers::Offset<quantra::Fixing>>(*fixings) : 0;
  return quantra::CreateIndex(
      _fbb,
      period_number,
      period_time_unit,
      settlement_days,
      calendar,
      business_day_convention,
      end_of_month,
      day_counter,
      fixings__);
}

struct FRA FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FRABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRA_TYPE = 4,
    VT_NOTIONAL = 6,
    VT_START_DATE = 8,
    VT_MATURITY_DATE = 10,
    VT_STRIKE = 12,
    VT_INDEX = 14,
    VT_DAY_COUNTER = 16,
    VT_CALENDAR = 18,
    VT_BUSINESS_DAY_CONVENTION = 20
  };
  quantra::enums::FRAType fra_type() const {
    return static_cast<quantra::enums::FRAType>(GetField<int8_t>(VT_FRA_TYPE, 0));
  }
  double notional() const {
    return GetField<double>(VT_NOTIONAL, 0.0);
  }
  const ::flatbuffers::String *start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_DATE);
  }
  const ::flatbuffers::String *maturity_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATURITY_DATE);
  }
  double strike() const {
    return GetField<double>(VT_STRIKE, 0.0);
  }
  const quantra::Index *index() const {
    return GetPointer<const quantra::Index *>(VT_INDEX);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FRA_TYPE, 1) &&
           VerifyField<double>(verifier, VT_NOTIONAL, 8) &&
           VerifyOffset(verifier, VT_START_DATE) &&
           verifier.VerifyString(start_date()) &&
           VerifyOffset(verifier, VT_MATURITY_DATE) &&
           verifier.VerifyString(maturity_date()) &&
           VerifyField<double>(verifier, VT_STRIKE, 8) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyTable(index()) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           verifier.EndTable();
  }
};

struct FRABuilder {
  typedef FRA Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fra_type(quantra::enums::FRAType fra_type) {
    fbb_.AddElement<int8_t>(FRA::VT_FRA_TYPE, static_cast<int8_t>(fra_type), 0);
  }
  void add_notional(double notional) {
    fbb_.AddElement<double>(FRA::VT_NOTIONAL, notional, 0.0);
  }
  void add_start_date(::flatbuffers::Offset<::flatbuffers::String> start_date) {
    fbb_.AddOffset(FRA::VT_START_DATE, start_date);
  }
  void add_maturity_date(::flatbuffers::Offset<::flatbuffers::String> maturity_date) {
    fbb_.AddOffset(FRA::VT_MATURITY_DATE, maturity_date);
  }
  void add_strike(double strike) {
    fbb_.AddElement<double>(FRA::VT_STRIKE, strike, 0.0);
  }
  void add_index(::flatbuffers::Offset<quantra::Index> index) {
    fbb_.AddOffset(FRA::VT_INDEX, index);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FRA::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FRA::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FRA::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  explicit FRABuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FRA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FRA>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FRA> CreateFRA(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::FRAType fra_type = quantra::enums::FRAType_Long,
    double notional = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> maturity_date = 0,
    double strike = 0.0,
    ::flatbuffers::Offset<quantra::Index> index = 0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  FRABuilder builder_(_fbb);
  builder_.add_strike(strike);
  builder_.add_notional(notional);
  builder_.add_index(index);
  builder_.add_maturity_date(maturity_date);
  builder_.add_start_date(start_date);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_day_counter(day_counter);
  builder_.add_fra_type(fra_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FRA> CreateFRADirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::FRAType fra_type = quantra::enums::FRAType_Long,
    double notional = 0.0,
    const char *start_date = nullptr,
    const char *maturity_date = nullptr,
    double strike = 0.0,
    ::flatbuffers::Offset<quantra::Index> index = 0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following) {
  auto start_date__ = start_date ? _fbb.CreateString(start_date) : 0;
  auto maturity_date__ = maturity_date ? _fbb.CreateString(maturity_date) : 0;
  return quantra::CreateFRA(
      _fbb,
      fra_type,
      notional,
      start_date__,
      maturity_date__,
      strike,
      index,
      day_counter,
      calendar,
      business_day_convention);
}

inline const quantra::FRA *GetFRA(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::FRA>(buf);
}

inline const quantra::FRA *GetSizePrefixedFRA(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::FRA>(buf);
}

inline bool VerifyFRABuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::FRA>(nullptr);
}

inline bool VerifySizePrefixedFRABuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::FRA>(nullptr);
}

inline void FinishFRABuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::FRA> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFRABuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::FRA> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_FRA_QUANTRA_H_
