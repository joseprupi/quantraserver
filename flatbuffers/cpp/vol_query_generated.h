// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VOLQUERY_QUANTRA_H_
#define FLATBUFFERS_GENERATED_VOLQUERY_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"
#include "curve_query_generated.h"
#include "enums_generated.h"

namespace quantra {

struct StrikeGrid;
struct StrikeGridBuilder;
struct StrikeGridT;

struct VolQuerySpec;
struct VolQuerySpecBuilder;
struct VolQuerySpecT;

struct VolSurfaceSample;
struct VolSurfaceSampleBuilder;
struct VolSurfaceSampleT;

enum VolSurfaceType : int8_t {
  VolSurfaceType_Swaption = 0,
  VolSurfaceType_Optionlet = 1,
  VolSurfaceType_MIN = VolSurfaceType_Swaption,
  VolSurfaceType_MAX = VolSurfaceType_Optionlet
};

inline const VolSurfaceType (&EnumValuesVolSurfaceType())[2] {
  static const VolSurfaceType values[] = {
    VolSurfaceType_Swaption,
    VolSurfaceType_Optionlet
  };
  return values;
}

inline const char * const *EnumNamesVolSurfaceType() {
  static const char * const names[3] = {
    "Swaption",
    "Optionlet",
    nullptr
  };
  return names;
}

inline const char *EnumNameVolSurfaceType(VolSurfaceType e) {
  if (::flatbuffers::IsOutRange(e, VolSurfaceType_Swaption, VolSurfaceType_Optionlet)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVolSurfaceType()[index];
}

enum VolStrikeAxis : int8_t {
  VolStrikeAxis_AbsoluteStrike = 0,
  VolStrikeAxis_SpreadFromATM = 1,
  VolStrikeAxis_MIN = VolStrikeAxis_AbsoluteStrike,
  VolStrikeAxis_MAX = VolStrikeAxis_SpreadFromATM
};

inline const VolStrikeAxis (&EnumValuesVolStrikeAxis())[2] {
  static const VolStrikeAxis values[] = {
    VolStrikeAxis_AbsoluteStrike,
    VolStrikeAxis_SpreadFromATM
  };
  return values;
}

inline const char * const *EnumNamesVolStrikeAxis() {
  static const char * const names[3] = {
    "AbsoluteStrike",
    "SpreadFromATM",
    nullptr
  };
  return names;
}

inline const char *EnumNameVolStrikeAxis(VolStrikeAxis e) {
  if (::flatbuffers::IsOutRange(e, VolStrikeAxis_AbsoluteStrike, VolStrikeAxis_SpreadFromATM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVolStrikeAxis()[index];
}

enum VolOutputMode : int8_t {
  VolOutputMode_Cube = 0,
  VolOutputMode_SmileSlice = 1,
  VolOutputMode_TermSlice = 2,
  VolOutputMode_ExpirySlice = 3,
  VolOutputMode_MIN = VolOutputMode_Cube,
  VolOutputMode_MAX = VolOutputMode_ExpirySlice
};

inline const VolOutputMode (&EnumValuesVolOutputMode())[4] {
  static const VolOutputMode values[] = {
    VolOutputMode_Cube,
    VolOutputMode_SmileSlice,
    VolOutputMode_TermSlice,
    VolOutputMode_ExpirySlice
  };
  return values;
}

inline const char * const *EnumNamesVolOutputMode() {
  static const char * const names[5] = {
    "Cube",
    "SmileSlice",
    "TermSlice",
    "ExpirySlice",
    nullptr
  };
  return names;
}

inline const char *EnumNameVolOutputMode(VolOutputMode e) {
  if (::flatbuffers::IsOutRange(e, VolOutputMode_Cube, VolOutputMode_ExpirySlice)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVolOutputMode()[index];
}

enum ExpiryKind : int8_t {
  ExpiryKind_ExerciseDate = 0,
  ExpiryKind_GridDate = 1,
  ExpiryKind_MIN = ExpiryKind_ExerciseDate,
  ExpiryKind_MAX = ExpiryKind_GridDate
};

inline const ExpiryKind (&EnumValuesExpiryKind())[2] {
  static const ExpiryKind values[] = {
    ExpiryKind_ExerciseDate,
    ExpiryKind_GridDate
  };
  return values;
}

inline const char * const *EnumNamesExpiryKind() {
  static const char * const names[3] = {
    "ExerciseDate",
    "GridDate",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpiryKind(ExpiryKind e) {
  if (::flatbuffers::IsOutRange(e, ExpiryKind_ExerciseDate, ExpiryKind_GridDate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpiryKind()[index];
}

struct StrikeGridT : public ::flatbuffers::NativeTable {
  typedef StrikeGrid TableType;
  quantra::VolStrikeAxis axis = quantra::VolStrikeAxis_AbsoluteStrike;
  std::vector<double> strikes{};
};

struct StrikeGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StrikeGridT NativeTableType;
  typedef StrikeGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_STRIKES = 6
  };
  quantra::VolStrikeAxis axis() const {
    return static_cast<quantra::VolStrikeAxis>(GetField<int8_t>(VT_AXIS, 0));
  }
  const ::flatbuffers::Vector<double> *strikes() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_STRIKES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_AXIS, 1) &&
           VerifyOffsetRequired(verifier, VT_STRIKES) &&
           verifier.VerifyVector(strikes()) &&
           verifier.EndTable();
  }
  StrikeGridT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StrikeGridT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StrikeGrid> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StrikeGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StrikeGridBuilder {
  typedef StrikeGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(quantra::VolStrikeAxis axis) {
    fbb_.AddElement<int8_t>(StrikeGrid::VT_AXIS, static_cast<int8_t>(axis), 0);
  }
  void add_strikes(::flatbuffers::Offset<::flatbuffers::Vector<double>> strikes) {
    fbb_.AddOffset(StrikeGrid::VT_STRIKES, strikes);
  }
  explicit StrikeGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StrikeGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StrikeGrid>(end);
    fbb_.Required(o, StrikeGrid::VT_STRIKES);
    return o;
  }
};

inline ::flatbuffers::Offset<StrikeGrid> CreateStrikeGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::VolStrikeAxis axis = quantra::VolStrikeAxis_AbsoluteStrike,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> strikes = 0) {
  StrikeGridBuilder builder_(_fbb);
  builder_.add_strikes(strikes);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StrikeGrid> CreateStrikeGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::VolStrikeAxis axis = quantra::VolStrikeAxis_AbsoluteStrike,
    const std::vector<double> *strikes = nullptr) {
  auto strikes__ = strikes ? _fbb.CreateVector<double>(*strikes) : 0;
  return quantra::CreateStrikeGrid(
      _fbb,
      axis,
      strikes__);
}

::flatbuffers::Offset<StrikeGrid> CreateStrikeGrid(::flatbuffers::FlatBufferBuilder &_fbb, const StrikeGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VolQuerySpecT : public ::flatbuffers::NativeTable {
  typedef VolQuerySpec TableType;
  std::string vol_id{};
  quantra::VolSurfaceType surface_type = quantra::VolSurfaceType_Swaption;
  std::unique_ptr<quantra::DateGridSpecT> expiry_grid{};
  std::unique_ptr<quantra::DateGridSpecT> tenor_grid{};
  std::unique_ptr<quantra::StrikeGridT> strike_grid{};
  std::unique_ptr<quantra::QueryOptionsT> options{};
  quantra::VolOutputMode output_mode = quantra::VolOutputMode_Cube;
  std::string swap_index_id{};
  int32_t slice_expiry_index = -1;
  int32_t slice_tenor_index = -1;
  double slice_strike = 0.0;
  bool slice_strike_is_set = false;
  std::string discounting_curve_id{};
  std::string forwarding_curve_id{};
  VolQuerySpecT() = default;
  VolQuerySpecT(const VolQuerySpecT &o);
  VolQuerySpecT(VolQuerySpecT&&) FLATBUFFERS_NOEXCEPT = default;
  VolQuerySpecT &operator=(VolQuerySpecT o) FLATBUFFERS_NOEXCEPT;
};

struct VolQuerySpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VolQuerySpecT NativeTableType;
  typedef VolQuerySpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VOL_ID = 4,
    VT_SURFACE_TYPE = 6,
    VT_EXPIRY_GRID = 8,
    VT_TENOR_GRID = 10,
    VT_STRIKE_GRID = 12,
    VT_OPTIONS = 14,
    VT_OUTPUT_MODE = 16,
    VT_SWAP_INDEX_ID = 18,
    VT_SLICE_EXPIRY_INDEX = 20,
    VT_SLICE_TENOR_INDEX = 22,
    VT_SLICE_STRIKE = 24,
    VT_SLICE_STRIKE_IS_SET = 26,
    VT_DISCOUNTING_CURVE_ID = 28,
    VT_FORWARDING_CURVE_ID = 30
  };
  const ::flatbuffers::String *vol_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOL_ID);
  }
  quantra::VolSurfaceType surface_type() const {
    return static_cast<quantra::VolSurfaceType>(GetField<int8_t>(VT_SURFACE_TYPE, 0));
  }
  const quantra::DateGridSpec *expiry_grid() const {
    return GetPointer<const quantra::DateGridSpec *>(VT_EXPIRY_GRID);
  }
  const quantra::DateGridSpec *tenor_grid() const {
    return GetPointer<const quantra::DateGridSpec *>(VT_TENOR_GRID);
  }
  const quantra::StrikeGrid *strike_grid() const {
    return GetPointer<const quantra::StrikeGrid *>(VT_STRIKE_GRID);
  }
  const quantra::QueryOptions *options() const {
    return GetPointer<const quantra::QueryOptions *>(VT_OPTIONS);
  }
  quantra::VolOutputMode output_mode() const {
    return static_cast<quantra::VolOutputMode>(GetField<int8_t>(VT_OUTPUT_MODE, 0));
  }
  const ::flatbuffers::String *swap_index_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SWAP_INDEX_ID);
  }
  int32_t slice_expiry_index() const {
    return GetField<int32_t>(VT_SLICE_EXPIRY_INDEX, -1);
  }
  int32_t slice_tenor_index() const {
    return GetField<int32_t>(VT_SLICE_TENOR_INDEX, -1);
  }
  double slice_strike() const {
    return GetField<double>(VT_SLICE_STRIKE, 0.0);
  }
  bool slice_strike_is_set() const {
    return GetField<uint8_t>(VT_SLICE_STRIKE_IS_SET, 0) != 0;
  }
  const ::flatbuffers::String *discounting_curve_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISCOUNTING_CURVE_ID);
  }
  const ::flatbuffers::String *forwarding_curve_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORWARDING_CURVE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VOL_ID) &&
           verifier.VerifyString(vol_id()) &&
           VerifyField<int8_t>(verifier, VT_SURFACE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_EXPIRY_GRID) &&
           verifier.VerifyTable(expiry_grid()) &&
           VerifyOffset(verifier, VT_TENOR_GRID) &&
           verifier.VerifyTable(tenor_grid()) &&
           VerifyOffsetRequired(verifier, VT_STRIKE_GRID) &&
           verifier.VerifyTable(strike_grid()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyTable(options()) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_MODE, 1) &&
           VerifyOffset(verifier, VT_SWAP_INDEX_ID) &&
           verifier.VerifyString(swap_index_id()) &&
           VerifyField<int32_t>(verifier, VT_SLICE_EXPIRY_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_SLICE_TENOR_INDEX, 4) &&
           VerifyField<double>(verifier, VT_SLICE_STRIKE, 8) &&
           VerifyField<uint8_t>(verifier, VT_SLICE_STRIKE_IS_SET, 1) &&
           VerifyOffset(verifier, VT_DISCOUNTING_CURVE_ID) &&
           verifier.VerifyString(discounting_curve_id()) &&
           VerifyOffset(verifier, VT_FORWARDING_CURVE_ID) &&
           verifier.VerifyString(forwarding_curve_id()) &&
           verifier.EndTable();
  }
  VolQuerySpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VolQuerySpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VolQuerySpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VolQuerySpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VolQuerySpecBuilder {
  typedef VolQuerySpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vol_id(::flatbuffers::Offset<::flatbuffers::String> vol_id) {
    fbb_.AddOffset(VolQuerySpec::VT_VOL_ID, vol_id);
  }
  void add_surface_type(quantra::VolSurfaceType surface_type) {
    fbb_.AddElement<int8_t>(VolQuerySpec::VT_SURFACE_TYPE, static_cast<int8_t>(surface_type), 0);
  }
  void add_expiry_grid(::flatbuffers::Offset<quantra::DateGridSpec> expiry_grid) {
    fbb_.AddOffset(VolQuerySpec::VT_EXPIRY_GRID, expiry_grid);
  }
  void add_tenor_grid(::flatbuffers::Offset<quantra::DateGridSpec> tenor_grid) {
    fbb_.AddOffset(VolQuerySpec::VT_TENOR_GRID, tenor_grid);
  }
  void add_strike_grid(::flatbuffers::Offset<quantra::StrikeGrid> strike_grid) {
    fbb_.AddOffset(VolQuerySpec::VT_STRIKE_GRID, strike_grid);
  }
  void add_options(::flatbuffers::Offset<quantra::QueryOptions> options) {
    fbb_.AddOffset(VolQuerySpec::VT_OPTIONS, options);
  }
  void add_output_mode(quantra::VolOutputMode output_mode) {
    fbb_.AddElement<int8_t>(VolQuerySpec::VT_OUTPUT_MODE, static_cast<int8_t>(output_mode), 0);
  }
  void add_swap_index_id(::flatbuffers::Offset<::flatbuffers::String> swap_index_id) {
    fbb_.AddOffset(VolQuerySpec::VT_SWAP_INDEX_ID, swap_index_id);
  }
  void add_slice_expiry_index(int32_t slice_expiry_index) {
    fbb_.AddElement<int32_t>(VolQuerySpec::VT_SLICE_EXPIRY_INDEX, slice_expiry_index, -1);
  }
  void add_slice_tenor_index(int32_t slice_tenor_index) {
    fbb_.AddElement<int32_t>(VolQuerySpec::VT_SLICE_TENOR_INDEX, slice_tenor_index, -1);
  }
  void add_slice_strike(double slice_strike) {
    fbb_.AddElement<double>(VolQuerySpec::VT_SLICE_STRIKE, slice_strike, 0.0);
  }
  void add_slice_strike_is_set(bool slice_strike_is_set) {
    fbb_.AddElement<uint8_t>(VolQuerySpec::VT_SLICE_STRIKE_IS_SET, static_cast<uint8_t>(slice_strike_is_set), 0);
  }
  void add_discounting_curve_id(::flatbuffers::Offset<::flatbuffers::String> discounting_curve_id) {
    fbb_.AddOffset(VolQuerySpec::VT_DISCOUNTING_CURVE_ID, discounting_curve_id);
  }
  void add_forwarding_curve_id(::flatbuffers::Offset<::flatbuffers::String> forwarding_curve_id) {
    fbb_.AddOffset(VolQuerySpec::VT_FORWARDING_CURVE_ID, forwarding_curve_id);
  }
  explicit VolQuerySpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VolQuerySpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VolQuerySpec>(end);
    fbb_.Required(o, VolQuerySpec::VT_VOL_ID);
    fbb_.Required(o, VolQuerySpec::VT_EXPIRY_GRID);
    fbb_.Required(o, VolQuerySpec::VT_STRIKE_GRID);
    return o;
  }
};

inline ::flatbuffers::Offset<VolQuerySpec> CreateVolQuerySpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> vol_id = 0,
    quantra::VolSurfaceType surface_type = quantra::VolSurfaceType_Swaption,
    ::flatbuffers::Offset<quantra::DateGridSpec> expiry_grid = 0,
    ::flatbuffers::Offset<quantra::DateGridSpec> tenor_grid = 0,
    ::flatbuffers::Offset<quantra::StrikeGrid> strike_grid = 0,
    ::flatbuffers::Offset<quantra::QueryOptions> options = 0,
    quantra::VolOutputMode output_mode = quantra::VolOutputMode_Cube,
    ::flatbuffers::Offset<::flatbuffers::String> swap_index_id = 0,
    int32_t slice_expiry_index = -1,
    int32_t slice_tenor_index = -1,
    double slice_strike = 0.0,
    bool slice_strike_is_set = false,
    ::flatbuffers::Offset<::flatbuffers::String> discounting_curve_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> forwarding_curve_id = 0) {
  VolQuerySpecBuilder builder_(_fbb);
  builder_.add_slice_strike(slice_strike);
  builder_.add_forwarding_curve_id(forwarding_curve_id);
  builder_.add_discounting_curve_id(discounting_curve_id);
  builder_.add_slice_tenor_index(slice_tenor_index);
  builder_.add_slice_expiry_index(slice_expiry_index);
  builder_.add_swap_index_id(swap_index_id);
  builder_.add_options(options);
  builder_.add_strike_grid(strike_grid);
  builder_.add_tenor_grid(tenor_grid);
  builder_.add_expiry_grid(expiry_grid);
  builder_.add_vol_id(vol_id);
  builder_.add_slice_strike_is_set(slice_strike_is_set);
  builder_.add_output_mode(output_mode);
  builder_.add_surface_type(surface_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VolQuerySpec> CreateVolQuerySpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *vol_id = nullptr,
    quantra::VolSurfaceType surface_type = quantra::VolSurfaceType_Swaption,
    ::flatbuffers::Offset<quantra::DateGridSpec> expiry_grid = 0,
    ::flatbuffers::Offset<quantra::DateGridSpec> tenor_grid = 0,
    ::flatbuffers::Offset<quantra::StrikeGrid> strike_grid = 0,
    ::flatbuffers::Offset<quantra::QueryOptions> options = 0,
    quantra::VolOutputMode output_mode = quantra::VolOutputMode_Cube,
    const char *swap_index_id = nullptr,
    int32_t slice_expiry_index = -1,
    int32_t slice_tenor_index = -1,
    double slice_strike = 0.0,
    bool slice_strike_is_set = false,
    const char *discounting_curve_id = nullptr,
    const char *forwarding_curve_id = nullptr) {
  auto vol_id__ = vol_id ? _fbb.CreateString(vol_id) : 0;
  auto swap_index_id__ = swap_index_id ? _fbb.CreateString(swap_index_id) : 0;
  auto discounting_curve_id__ = discounting_curve_id ? _fbb.CreateString(discounting_curve_id) : 0;
  auto forwarding_curve_id__ = forwarding_curve_id ? _fbb.CreateString(forwarding_curve_id) : 0;
  return quantra::CreateVolQuerySpec(
      _fbb,
      vol_id__,
      surface_type,
      expiry_grid,
      tenor_grid,
      strike_grid,
      options,
      output_mode,
      swap_index_id__,
      slice_expiry_index,
      slice_tenor_index,
      slice_strike,
      slice_strike_is_set,
      discounting_curve_id__,
      forwarding_curve_id__);
}

::flatbuffers::Offset<VolQuerySpec> CreateVolQuerySpec(::flatbuffers::FlatBufferBuilder &_fbb, const VolQuerySpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VolSurfaceSampleT : public ::flatbuffers::NativeTable {
  typedef VolSurfaceSample TableType;
  std::string vol_id{};
  std::string reference_date{};
  quantra::enums::VolatilityType ql_vol_type = quantra::enums::VolatilityType_Normal;
  quantra::VolStrikeAxis requested_strike_axis = quantra::VolStrikeAxis_AbsoluteStrike;
  quantra::enums::SwaptionStrikeKind canonical_strike_kind = quantra::enums::SwaptionStrikeKind_Absolute;
  bool allow_extrapolation_used = false;
  quantra::enums::Calendar calendar_used = quantra::enums::Calendar_Argentina;
  quantra::enums::BusinessDayConvention business_day_convention_used = quantra::enums::BusinessDayConvention_Following;
  quantra::ExpiryKind expiry_kind = quantra::ExpiryKind_GridDate;
  std::vector<std::string> expiries{};
  std::vector<std::string> requested_expiry_grid_points{};
  std::vector<std::unique_ptr<quantra::PeriodT>> tenors{};
  std::vector<std::string> effective_swap_starts{};
  std::vector<std::string> effective_swap_ends{};
  std::vector<double> strikes{};
  std::vector<double> vols{};
  int32_t n_expiries = 0;
  int32_t n_tenors = 0;
  int32_t n_strikes = 0;
  std::vector<double> atm_levels{};
  std::unique_ptr<quantra::ErrorT> error{};
  VolSurfaceSampleT() = default;
  VolSurfaceSampleT(const VolSurfaceSampleT &o);
  VolSurfaceSampleT(VolSurfaceSampleT&&) FLATBUFFERS_NOEXCEPT = default;
  VolSurfaceSampleT &operator=(VolSurfaceSampleT o) FLATBUFFERS_NOEXCEPT;
};

struct VolSurfaceSample FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VolSurfaceSampleT NativeTableType;
  typedef VolSurfaceSampleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VOL_ID = 4,
    VT_REFERENCE_DATE = 6,
    VT_QL_VOL_TYPE = 8,
    VT_REQUESTED_STRIKE_AXIS = 10,
    VT_CANONICAL_STRIKE_KIND = 12,
    VT_ALLOW_EXTRAPOLATION_USED = 14,
    VT_CALENDAR_USED = 16,
    VT_BUSINESS_DAY_CONVENTION_USED = 18,
    VT_EXPIRY_KIND = 20,
    VT_EXPIRIES = 22,
    VT_REQUESTED_EXPIRY_GRID_POINTS = 24,
    VT_TENORS = 26,
    VT_EFFECTIVE_SWAP_STARTS = 28,
    VT_EFFECTIVE_SWAP_ENDS = 30,
    VT_STRIKES = 32,
    VT_VOLS = 34,
    VT_N_EXPIRIES = 36,
    VT_N_TENORS = 38,
    VT_N_STRIKES = 40,
    VT_ATM_LEVELS = 42,
    VT_ERROR = 44
  };
  const ::flatbuffers::String *vol_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOL_ID);
  }
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  quantra::enums::VolatilityType ql_vol_type() const {
    return static_cast<quantra::enums::VolatilityType>(GetField<int8_t>(VT_QL_VOL_TYPE, 0));
  }
  quantra::VolStrikeAxis requested_strike_axis() const {
    return static_cast<quantra::VolStrikeAxis>(GetField<int8_t>(VT_REQUESTED_STRIKE_AXIS, 0));
  }
  quantra::enums::SwaptionStrikeKind canonical_strike_kind() const {
    return static_cast<quantra::enums::SwaptionStrikeKind>(GetField<int8_t>(VT_CANONICAL_STRIKE_KIND, 0));
  }
  bool allow_extrapolation_used() const {
    return GetField<uint8_t>(VT_ALLOW_EXTRAPOLATION_USED, 0) != 0;
  }
  quantra::enums::Calendar calendar_used() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR_USED, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention_used() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION_USED, 0));
  }
  quantra::ExpiryKind expiry_kind() const {
    return static_cast<quantra::ExpiryKind>(GetField<int8_t>(VT_EXPIRY_KIND, 1));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *expiries() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_EXPIRIES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *requested_expiry_grid_points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_REQUESTED_EXPIRY_GRID_POINTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>> *tenors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>> *>(VT_TENORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *effective_swap_starts() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_EFFECTIVE_SWAP_STARTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *effective_swap_ends() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_EFFECTIVE_SWAP_ENDS);
  }
  const ::flatbuffers::Vector<double> *strikes() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_STRIKES);
  }
  const ::flatbuffers::Vector<double> *vols() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_VOLS);
  }
  int32_t n_expiries() const {
    return GetField<int32_t>(VT_N_EXPIRIES, 0);
  }
  int32_t n_tenors() const {
    return GetField<int32_t>(VT_N_TENORS, 0);
  }
  int32_t n_strikes() const {
    return GetField<int32_t>(VT_N_STRIKES, 0);
  }
  const ::flatbuffers::Vector<double> *atm_levels() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ATM_LEVELS);
  }
  const quantra::Error *error() const {
    return GetPointer<const quantra::Error *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VOL_ID) &&
           verifier.VerifyString(vol_id()) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           VerifyField<int8_t>(verifier, VT_QL_VOL_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_REQUESTED_STRIKE_AXIS, 1) &&
           VerifyField<int8_t>(verifier, VT_CANONICAL_STRIKE_KIND, 1) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_EXTRAPOLATION_USED, 1) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR_USED, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION_USED, 1) &&
           VerifyField<int8_t>(verifier, VT_EXPIRY_KIND, 1) &&
           VerifyOffset(verifier, VT_EXPIRIES) &&
           verifier.VerifyVector(expiries()) &&
           verifier.VerifyVectorOfStrings(expiries()) &&
           VerifyOffset(verifier, VT_REQUESTED_EXPIRY_GRID_POINTS) &&
           verifier.VerifyVector(requested_expiry_grid_points()) &&
           verifier.VerifyVectorOfStrings(requested_expiry_grid_points()) &&
           VerifyOffset(verifier, VT_TENORS) &&
           verifier.VerifyVector(tenors()) &&
           verifier.VerifyVectorOfTables(tenors()) &&
           VerifyOffset(verifier, VT_EFFECTIVE_SWAP_STARTS) &&
           verifier.VerifyVector(effective_swap_starts()) &&
           verifier.VerifyVectorOfStrings(effective_swap_starts()) &&
           VerifyOffset(verifier, VT_EFFECTIVE_SWAP_ENDS) &&
           verifier.VerifyVector(effective_swap_ends()) &&
           verifier.VerifyVectorOfStrings(effective_swap_ends()) &&
           VerifyOffset(verifier, VT_STRIKES) &&
           verifier.VerifyVector(strikes()) &&
           VerifyOffset(verifier, VT_VOLS) &&
           verifier.VerifyVector(vols()) &&
           VerifyField<int32_t>(verifier, VT_N_EXPIRIES, 4) &&
           VerifyField<int32_t>(verifier, VT_N_TENORS, 4) &&
           VerifyField<int32_t>(verifier, VT_N_STRIKES, 4) &&
           VerifyOffset(verifier, VT_ATM_LEVELS) &&
           verifier.VerifyVector(atm_levels()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  VolSurfaceSampleT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VolSurfaceSampleT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VolSurfaceSample> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSampleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VolSurfaceSampleBuilder {
  typedef VolSurfaceSample Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vol_id(::flatbuffers::Offset<::flatbuffers::String> vol_id) {
    fbb_.AddOffset(VolSurfaceSample::VT_VOL_ID, vol_id);
  }
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(VolSurfaceSample::VT_REFERENCE_DATE, reference_date);
  }
  void add_ql_vol_type(quantra::enums::VolatilityType ql_vol_type) {
    fbb_.AddElement<int8_t>(VolSurfaceSample::VT_QL_VOL_TYPE, static_cast<int8_t>(ql_vol_type), 0);
  }
  void add_requested_strike_axis(quantra::VolStrikeAxis requested_strike_axis) {
    fbb_.AddElement<int8_t>(VolSurfaceSample::VT_REQUESTED_STRIKE_AXIS, static_cast<int8_t>(requested_strike_axis), 0);
  }
  void add_canonical_strike_kind(quantra::enums::SwaptionStrikeKind canonical_strike_kind) {
    fbb_.AddElement<int8_t>(VolSurfaceSample::VT_CANONICAL_STRIKE_KIND, static_cast<int8_t>(canonical_strike_kind), 0);
  }
  void add_allow_extrapolation_used(bool allow_extrapolation_used) {
    fbb_.AddElement<uint8_t>(VolSurfaceSample::VT_ALLOW_EXTRAPOLATION_USED, static_cast<uint8_t>(allow_extrapolation_used), 0);
  }
  void add_calendar_used(quantra::enums::Calendar calendar_used) {
    fbb_.AddElement<int8_t>(VolSurfaceSample::VT_CALENDAR_USED, static_cast<int8_t>(calendar_used), 0);
  }
  void add_business_day_convention_used(quantra::enums::BusinessDayConvention business_day_convention_used) {
    fbb_.AddElement<int8_t>(VolSurfaceSample::VT_BUSINESS_DAY_CONVENTION_USED, static_cast<int8_t>(business_day_convention_used), 0);
  }
  void add_expiry_kind(quantra::ExpiryKind expiry_kind) {
    fbb_.AddElement<int8_t>(VolSurfaceSample::VT_EXPIRY_KIND, static_cast<int8_t>(expiry_kind), 1);
  }
  void add_expiries(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> expiries) {
    fbb_.AddOffset(VolSurfaceSample::VT_EXPIRIES, expiries);
  }
  void add_requested_expiry_grid_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> requested_expiry_grid_points) {
    fbb_.AddOffset(VolSurfaceSample::VT_REQUESTED_EXPIRY_GRID_POINTS, requested_expiry_grid_points);
  }
  void add_tenors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>>> tenors) {
    fbb_.AddOffset(VolSurfaceSample::VT_TENORS, tenors);
  }
  void add_effective_swap_starts(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> effective_swap_starts) {
    fbb_.AddOffset(VolSurfaceSample::VT_EFFECTIVE_SWAP_STARTS, effective_swap_starts);
  }
  void add_effective_swap_ends(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> effective_swap_ends) {
    fbb_.AddOffset(VolSurfaceSample::VT_EFFECTIVE_SWAP_ENDS, effective_swap_ends);
  }
  void add_strikes(::flatbuffers::Offset<::flatbuffers::Vector<double>> strikes) {
    fbb_.AddOffset(VolSurfaceSample::VT_STRIKES, strikes);
  }
  void add_vols(::flatbuffers::Offset<::flatbuffers::Vector<double>> vols) {
    fbb_.AddOffset(VolSurfaceSample::VT_VOLS, vols);
  }
  void add_n_expiries(int32_t n_expiries) {
    fbb_.AddElement<int32_t>(VolSurfaceSample::VT_N_EXPIRIES, n_expiries, 0);
  }
  void add_n_tenors(int32_t n_tenors) {
    fbb_.AddElement<int32_t>(VolSurfaceSample::VT_N_TENORS, n_tenors, 0);
  }
  void add_n_strikes(int32_t n_strikes) {
    fbb_.AddElement<int32_t>(VolSurfaceSample::VT_N_STRIKES, n_strikes, 0);
  }
  void add_atm_levels(::flatbuffers::Offset<::flatbuffers::Vector<double>> atm_levels) {
    fbb_.AddOffset(VolSurfaceSample::VT_ATM_LEVELS, atm_levels);
  }
  void add_error(::flatbuffers::Offset<quantra::Error> error) {
    fbb_.AddOffset(VolSurfaceSample::VT_ERROR, error);
  }
  explicit VolSurfaceSampleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VolSurfaceSample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VolSurfaceSample>(end);
    fbb_.Required(o, VolSurfaceSample::VT_VOL_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<VolSurfaceSample> CreateVolSurfaceSample(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> vol_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0,
    quantra::enums::VolatilityType ql_vol_type = quantra::enums::VolatilityType_Normal,
    quantra::VolStrikeAxis requested_strike_axis = quantra::VolStrikeAxis_AbsoluteStrike,
    quantra::enums::SwaptionStrikeKind canonical_strike_kind = quantra::enums::SwaptionStrikeKind_Absolute,
    bool allow_extrapolation_used = false,
    quantra::enums::Calendar calendar_used = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention_used = quantra::enums::BusinessDayConvention_Following,
    quantra::ExpiryKind expiry_kind = quantra::ExpiryKind_GridDate,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> expiries = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> requested_expiry_grid_points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::Period>>> tenors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> effective_swap_starts = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> effective_swap_ends = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> strikes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> vols = 0,
    int32_t n_expiries = 0,
    int32_t n_tenors = 0,
    int32_t n_strikes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> atm_levels = 0,
    ::flatbuffers::Offset<quantra::Error> error = 0) {
  VolSurfaceSampleBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_atm_levels(atm_levels);
  builder_.add_n_strikes(n_strikes);
  builder_.add_n_tenors(n_tenors);
  builder_.add_n_expiries(n_expiries);
  builder_.add_vols(vols);
  builder_.add_strikes(strikes);
  builder_.add_effective_swap_ends(effective_swap_ends);
  builder_.add_effective_swap_starts(effective_swap_starts);
  builder_.add_tenors(tenors);
  builder_.add_requested_expiry_grid_points(requested_expiry_grid_points);
  builder_.add_expiries(expiries);
  builder_.add_reference_date(reference_date);
  builder_.add_vol_id(vol_id);
  builder_.add_expiry_kind(expiry_kind);
  builder_.add_business_day_convention_used(business_day_convention_used);
  builder_.add_calendar_used(calendar_used);
  builder_.add_allow_extrapolation_used(allow_extrapolation_used);
  builder_.add_canonical_strike_kind(canonical_strike_kind);
  builder_.add_requested_strike_axis(requested_strike_axis);
  builder_.add_ql_vol_type(ql_vol_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VolSurfaceSample> CreateVolSurfaceSampleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *vol_id = nullptr,
    const char *reference_date = nullptr,
    quantra::enums::VolatilityType ql_vol_type = quantra::enums::VolatilityType_Normal,
    quantra::VolStrikeAxis requested_strike_axis = quantra::VolStrikeAxis_AbsoluteStrike,
    quantra::enums::SwaptionStrikeKind canonical_strike_kind = quantra::enums::SwaptionStrikeKind_Absolute,
    bool allow_extrapolation_used = false,
    quantra::enums::Calendar calendar_used = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention_used = quantra::enums::BusinessDayConvention_Following,
    quantra::ExpiryKind expiry_kind = quantra::ExpiryKind_GridDate,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *expiries = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *requested_expiry_grid_points = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::Period>> *tenors = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *effective_swap_starts = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *effective_swap_ends = nullptr,
    const std::vector<double> *strikes = nullptr,
    const std::vector<double> *vols = nullptr,
    int32_t n_expiries = 0,
    int32_t n_tenors = 0,
    int32_t n_strikes = 0,
    const std::vector<double> *atm_levels = nullptr,
    ::flatbuffers::Offset<quantra::Error> error = 0) {
  auto vol_id__ = vol_id ? _fbb.CreateString(vol_id) : 0;
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  auto expiries__ = expiries ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*expiries) : 0;
  auto requested_expiry_grid_points__ = requested_expiry_grid_points ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*requested_expiry_grid_points) : 0;
  auto tenors__ = tenors ? _fbb.CreateVector<::flatbuffers::Offset<quantra::Period>>(*tenors) : 0;
  auto effective_swap_starts__ = effective_swap_starts ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*effective_swap_starts) : 0;
  auto effective_swap_ends__ = effective_swap_ends ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*effective_swap_ends) : 0;
  auto strikes__ = strikes ? _fbb.CreateVector<double>(*strikes) : 0;
  auto vols__ = vols ? _fbb.CreateVector<double>(*vols) : 0;
  auto atm_levels__ = atm_levels ? _fbb.CreateVector<double>(*atm_levels) : 0;
  return quantra::CreateVolSurfaceSample(
      _fbb,
      vol_id__,
      reference_date__,
      ql_vol_type,
      requested_strike_axis,
      canonical_strike_kind,
      allow_extrapolation_used,
      calendar_used,
      business_day_convention_used,
      expiry_kind,
      expiries__,
      requested_expiry_grid_points__,
      tenors__,
      effective_swap_starts__,
      effective_swap_ends__,
      strikes__,
      vols__,
      n_expiries,
      n_tenors,
      n_strikes,
      atm_levels__,
      error);
}

::flatbuffers::Offset<VolSurfaceSample> CreateVolSurfaceSample(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSampleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StrikeGridT *StrikeGrid::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StrikeGridT>(new StrikeGridT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StrikeGrid::UnPackTo(StrikeGridT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = strikes(); if (_e) { _o->strikes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strikes[_i] = _e->Get(_i); } } else { _o->strikes.resize(0); } }
}

inline ::flatbuffers::Offset<StrikeGrid> StrikeGrid::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StrikeGridT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStrikeGrid(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StrikeGrid> CreateStrikeGrid(::flatbuffers::FlatBufferBuilder &_fbb, const StrikeGridT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StrikeGridT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _strikes = _fbb.CreateVector(_o->strikes);
  return quantra::CreateStrikeGrid(
      _fbb,
      _axis,
      _strikes);
}

inline VolQuerySpecT::VolQuerySpecT(const VolQuerySpecT &o)
      : vol_id(o.vol_id),
        surface_type(o.surface_type),
        expiry_grid((o.expiry_grid) ? new quantra::DateGridSpecT(*o.expiry_grid) : nullptr),
        tenor_grid((o.tenor_grid) ? new quantra::DateGridSpecT(*o.tenor_grid) : nullptr),
        strike_grid((o.strike_grid) ? new quantra::StrikeGridT(*o.strike_grid) : nullptr),
        options((o.options) ? new quantra::QueryOptionsT(*o.options) : nullptr),
        output_mode(o.output_mode),
        swap_index_id(o.swap_index_id),
        slice_expiry_index(o.slice_expiry_index),
        slice_tenor_index(o.slice_tenor_index),
        slice_strike(o.slice_strike),
        slice_strike_is_set(o.slice_strike_is_set),
        discounting_curve_id(o.discounting_curve_id),
        forwarding_curve_id(o.forwarding_curve_id) {
}

inline VolQuerySpecT &VolQuerySpecT::operator=(VolQuerySpecT o) FLATBUFFERS_NOEXCEPT {
  std::swap(vol_id, o.vol_id);
  std::swap(surface_type, o.surface_type);
  std::swap(expiry_grid, o.expiry_grid);
  std::swap(tenor_grid, o.tenor_grid);
  std::swap(strike_grid, o.strike_grid);
  std::swap(options, o.options);
  std::swap(output_mode, o.output_mode);
  std::swap(swap_index_id, o.swap_index_id);
  std::swap(slice_expiry_index, o.slice_expiry_index);
  std::swap(slice_tenor_index, o.slice_tenor_index);
  std::swap(slice_strike, o.slice_strike);
  std::swap(slice_strike_is_set, o.slice_strike_is_set);
  std::swap(discounting_curve_id, o.discounting_curve_id);
  std::swap(forwarding_curve_id, o.forwarding_curve_id);
  return *this;
}

inline VolQuerySpecT *VolQuerySpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VolQuerySpecT>(new VolQuerySpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VolQuerySpec::UnPackTo(VolQuerySpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vol_id(); if (_e) _o->vol_id = _e->str(); }
  { auto _e = surface_type(); _o->surface_type = _e; }
  { auto _e = expiry_grid(); if (_e) { if(_o->expiry_grid) { _e->UnPackTo(_o->expiry_grid.get(), _resolver); } else { _o->expiry_grid = std::unique_ptr<quantra::DateGridSpecT>(_e->UnPack(_resolver)); } } else if (_o->expiry_grid) { _o->expiry_grid.reset(); } }
  { auto _e = tenor_grid(); if (_e) { if(_o->tenor_grid) { _e->UnPackTo(_o->tenor_grid.get(), _resolver); } else { _o->tenor_grid = std::unique_ptr<quantra::DateGridSpecT>(_e->UnPack(_resolver)); } } else if (_o->tenor_grid) { _o->tenor_grid.reset(); } }
  { auto _e = strike_grid(); if (_e) { if(_o->strike_grid) { _e->UnPackTo(_o->strike_grid.get(), _resolver); } else { _o->strike_grid = std::unique_ptr<quantra::StrikeGridT>(_e->UnPack(_resolver)); } } else if (_o->strike_grid) { _o->strike_grid.reset(); } }
  { auto _e = options(); if (_e) { if(_o->options) { _e->UnPackTo(_o->options.get(), _resolver); } else { _o->options = std::unique_ptr<quantra::QueryOptionsT>(_e->UnPack(_resolver)); } } else if (_o->options) { _o->options.reset(); } }
  { auto _e = output_mode(); _o->output_mode = _e; }
  { auto _e = swap_index_id(); if (_e) _o->swap_index_id = _e->str(); }
  { auto _e = slice_expiry_index(); _o->slice_expiry_index = _e; }
  { auto _e = slice_tenor_index(); _o->slice_tenor_index = _e; }
  { auto _e = slice_strike(); _o->slice_strike = _e; }
  { auto _e = slice_strike_is_set(); _o->slice_strike_is_set = _e; }
  { auto _e = discounting_curve_id(); if (_e) _o->discounting_curve_id = _e->str(); }
  { auto _e = forwarding_curve_id(); if (_e) _o->forwarding_curve_id = _e->str(); }
}

inline ::flatbuffers::Offset<VolQuerySpec> VolQuerySpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VolQuerySpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVolQuerySpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VolQuerySpec> CreateVolQuerySpec(::flatbuffers::FlatBufferBuilder &_fbb, const VolQuerySpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VolQuerySpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vol_id = _fbb.CreateString(_o->vol_id);
  auto _surface_type = _o->surface_type;
  auto _expiry_grid = _o->expiry_grid ? CreateDateGridSpec(_fbb, _o->expiry_grid.get(), _rehasher) : 0;
  auto _tenor_grid = _o->tenor_grid ? CreateDateGridSpec(_fbb, _o->tenor_grid.get(), _rehasher) : 0;
  auto _strike_grid = _o->strike_grid ? CreateStrikeGrid(_fbb, _o->strike_grid.get(), _rehasher) : 0;
  auto _options = _o->options ? CreateQueryOptions(_fbb, _o->options.get(), _rehasher) : 0;
  auto _output_mode = _o->output_mode;
  auto _swap_index_id = _o->swap_index_id.empty() ? 0 : _fbb.CreateString(_o->swap_index_id);
  auto _slice_expiry_index = _o->slice_expiry_index;
  auto _slice_tenor_index = _o->slice_tenor_index;
  auto _slice_strike = _o->slice_strike;
  auto _slice_strike_is_set = _o->slice_strike_is_set;
  auto _discounting_curve_id = _o->discounting_curve_id.empty() ? 0 : _fbb.CreateString(_o->discounting_curve_id);
  auto _forwarding_curve_id = _o->forwarding_curve_id.empty() ? 0 : _fbb.CreateString(_o->forwarding_curve_id);
  return quantra::CreateVolQuerySpec(
      _fbb,
      _vol_id,
      _surface_type,
      _expiry_grid,
      _tenor_grid,
      _strike_grid,
      _options,
      _output_mode,
      _swap_index_id,
      _slice_expiry_index,
      _slice_tenor_index,
      _slice_strike,
      _slice_strike_is_set,
      _discounting_curve_id,
      _forwarding_curve_id);
}

inline VolSurfaceSampleT::VolSurfaceSampleT(const VolSurfaceSampleT &o)
      : vol_id(o.vol_id),
        reference_date(o.reference_date),
        ql_vol_type(o.ql_vol_type),
        requested_strike_axis(o.requested_strike_axis),
        canonical_strike_kind(o.canonical_strike_kind),
        allow_extrapolation_used(o.allow_extrapolation_used),
        calendar_used(o.calendar_used),
        business_day_convention_used(o.business_day_convention_used),
        expiry_kind(o.expiry_kind),
        expiries(o.expiries),
        requested_expiry_grid_points(o.requested_expiry_grid_points),
        effective_swap_starts(o.effective_swap_starts),
        effective_swap_ends(o.effective_swap_ends),
        strikes(o.strikes),
        vols(o.vols),
        n_expiries(o.n_expiries),
        n_tenors(o.n_tenors),
        n_strikes(o.n_strikes),
        atm_levels(o.atm_levels),
        error((o.error) ? new quantra::ErrorT(*o.error) : nullptr) {
  tenors.reserve(o.tenors.size());
  for (const auto &tenors_ : o.tenors) { tenors.emplace_back((tenors_) ? new quantra::PeriodT(*tenors_) : nullptr); }
}

inline VolSurfaceSampleT &VolSurfaceSampleT::operator=(VolSurfaceSampleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(vol_id, o.vol_id);
  std::swap(reference_date, o.reference_date);
  std::swap(ql_vol_type, o.ql_vol_type);
  std::swap(requested_strike_axis, o.requested_strike_axis);
  std::swap(canonical_strike_kind, o.canonical_strike_kind);
  std::swap(allow_extrapolation_used, o.allow_extrapolation_used);
  std::swap(calendar_used, o.calendar_used);
  std::swap(business_day_convention_used, o.business_day_convention_used);
  std::swap(expiry_kind, o.expiry_kind);
  std::swap(expiries, o.expiries);
  std::swap(requested_expiry_grid_points, o.requested_expiry_grid_points);
  std::swap(tenors, o.tenors);
  std::swap(effective_swap_starts, o.effective_swap_starts);
  std::swap(effective_swap_ends, o.effective_swap_ends);
  std::swap(strikes, o.strikes);
  std::swap(vols, o.vols);
  std::swap(n_expiries, o.n_expiries);
  std::swap(n_tenors, o.n_tenors);
  std::swap(n_strikes, o.n_strikes);
  std::swap(atm_levels, o.atm_levels);
  std::swap(error, o.error);
  return *this;
}

inline VolSurfaceSampleT *VolSurfaceSample::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VolSurfaceSampleT>(new VolSurfaceSampleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VolSurfaceSample::UnPackTo(VolSurfaceSampleT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = vol_id(); if (_e) _o->vol_id = _e->str(); }
  { auto _e = reference_date(); if (_e) _o->reference_date = _e->str(); }
  { auto _e = ql_vol_type(); _o->ql_vol_type = _e; }
  { auto _e = requested_strike_axis(); _o->requested_strike_axis = _e; }
  { auto _e = canonical_strike_kind(); _o->canonical_strike_kind = _e; }
  { auto _e = allow_extrapolation_used(); _o->allow_extrapolation_used = _e; }
  { auto _e = calendar_used(); _o->calendar_used = _e; }
  { auto _e = business_day_convention_used(); _o->business_day_convention_used = _e; }
  { auto _e = expiry_kind(); _o->expiry_kind = _e; }
  { auto _e = expiries(); if (_e) { _o->expiries.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->expiries[_i] = _e->Get(_i)->str(); } } else { _o->expiries.resize(0); } }
  { auto _e = requested_expiry_grid_points(); if (_e) { _o->requested_expiry_grid_points.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->requested_expiry_grid_points[_i] = _e->Get(_i)->str(); } } else { _o->requested_expiry_grid_points.resize(0); } }
  { auto _e = tenors(); if (_e) { _o->tenors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tenors[_i]) { _e->Get(_i)->UnPackTo(_o->tenors[_i].get(), _resolver); } else { _o->tenors[_i] = std::unique_ptr<quantra::PeriodT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tenors.resize(0); } }
  { auto _e = effective_swap_starts(); if (_e) { _o->effective_swap_starts.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->effective_swap_starts[_i] = _e->Get(_i)->str(); } } else { _o->effective_swap_starts.resize(0); } }
  { auto _e = effective_swap_ends(); if (_e) { _o->effective_swap_ends.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->effective_swap_ends[_i] = _e->Get(_i)->str(); } } else { _o->effective_swap_ends.resize(0); } }
  { auto _e = strikes(); if (_e) { _o->strikes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->strikes[_i] = _e->Get(_i); } } else { _o->strikes.resize(0); } }
  { auto _e = vols(); if (_e) { _o->vols.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->vols[_i] = _e->Get(_i); } } else { _o->vols.resize(0); } }
  { auto _e = n_expiries(); _o->n_expiries = _e; }
  { auto _e = n_tenors(); _o->n_tenors = _e; }
  { auto _e = n_strikes(); _o->n_strikes = _e; }
  { auto _e = atm_levels(); if (_e) { _o->atm_levels.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->atm_levels[_i] = _e->Get(_i); } } else { _o->atm_levels.resize(0); } }
  { auto _e = error(); if (_e) { if(_o->error) { _e->UnPackTo(_o->error.get(), _resolver); } else { _o->error = std::unique_ptr<quantra::ErrorT>(_e->UnPack(_resolver)); } } else if (_o->error) { _o->error.reset(); } }
}

inline ::flatbuffers::Offset<VolSurfaceSample> VolSurfaceSample::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSampleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVolSurfaceSample(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VolSurfaceSample> CreateVolSurfaceSample(::flatbuffers::FlatBufferBuilder &_fbb, const VolSurfaceSampleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VolSurfaceSampleT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _vol_id = _fbb.CreateString(_o->vol_id);
  auto _reference_date = _o->reference_date.empty() ? 0 : _fbb.CreateString(_o->reference_date);
  auto _ql_vol_type = _o->ql_vol_type;
  auto _requested_strike_axis = _o->requested_strike_axis;
  auto _canonical_strike_kind = _o->canonical_strike_kind;
  auto _allow_extrapolation_used = _o->allow_extrapolation_used;
  auto _calendar_used = _o->calendar_used;
  auto _business_day_convention_used = _o->business_day_convention_used;
  auto _expiry_kind = _o->expiry_kind;
  auto _expiries = _o->expiries.size() ? _fbb.CreateVectorOfStrings(_o->expiries) : 0;
  auto _requested_expiry_grid_points = _o->requested_expiry_grid_points.size() ? _fbb.CreateVectorOfStrings(_o->requested_expiry_grid_points) : 0;
  auto _tenors = _o->tenors.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::Period>> (_o->tenors.size(), [](size_t i, _VectorArgs *__va) { return CreatePeriod(*__va->__fbb, __va->__o->tenors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _effective_swap_starts = _o->effective_swap_starts.size() ? _fbb.CreateVectorOfStrings(_o->effective_swap_starts) : 0;
  auto _effective_swap_ends = _o->effective_swap_ends.size() ? _fbb.CreateVectorOfStrings(_o->effective_swap_ends) : 0;
  auto _strikes = _o->strikes.size() ? _fbb.CreateVector(_o->strikes) : 0;
  auto _vols = _o->vols.size() ? _fbb.CreateVector(_o->vols) : 0;
  auto _n_expiries = _o->n_expiries;
  auto _n_tenors = _o->n_tenors;
  auto _n_strikes = _o->n_strikes;
  auto _atm_levels = _o->atm_levels.size() ? _fbb.CreateVector(_o->atm_levels) : 0;
  auto _error = _o->error ? CreateError(_fbb, _o->error.get(), _rehasher) : 0;
  return quantra::CreateVolSurfaceSample(
      _fbb,
      _vol_id,
      _reference_date,
      _ql_vol_type,
      _requested_strike_axis,
      _canonical_strike_kind,
      _allow_extrapolation_used,
      _calendar_used,
      _business_day_convention_used,
      _expiry_kind,
      _expiries,
      _requested_expiry_grid_points,
      _tenors,
      _effective_swap_starts,
      _effective_swap_ends,
      _strikes,
      _vols,
      _n_expiries,
      _n_tenors,
      _n_strikes,
      _atm_levels,
      _error);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_VOLQUERY_QUANTRA_H_
