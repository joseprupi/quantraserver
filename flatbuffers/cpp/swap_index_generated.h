// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SWAPINDEX_QUANTRA_H_
#define FLATBUFFERS_GENERATED_SWAPINDEX_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"

namespace quantra {

struct SwapIndexFixedLegSpec;
struct SwapIndexFixedLegSpecBuilder;
struct SwapIndexFixedLegSpecT;

struct SwapIndexFloatLegSpec;
struct SwapIndexFloatLegSpecBuilder;
struct SwapIndexFloatLegSpecT;

struct SwapIndexDef;
struct SwapIndexDefBuilder;
struct SwapIndexDefT;

enum SwapIndexKind : int8_t {
  SwapIndexKind_IborSwapIndex = 0,
  SwapIndexKind_OisSwapIndex = 1,
  SwapIndexKind_MIN = SwapIndexKind_IborSwapIndex,
  SwapIndexKind_MAX = SwapIndexKind_OisSwapIndex
};

inline const SwapIndexKind (&EnumValuesSwapIndexKind())[2] {
  static const SwapIndexKind values[] = {
    SwapIndexKind_IborSwapIndex,
    SwapIndexKind_OisSwapIndex
  };
  return values;
}

inline const char * const *EnumNamesSwapIndexKind() {
  static const char * const names[3] = {
    "IborSwapIndex",
    "OisSwapIndex",
    nullptr
  };
  return names;
}

inline const char *EnumNameSwapIndexKind(SwapIndexKind e) {
  if (::flatbuffers::IsOutRange(e, SwapIndexKind_IborSwapIndex, SwapIndexKind_OisSwapIndex)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSwapIndexKind()[index];
}

struct SwapIndexFixedLegSpecT : public ::flatbuffers::NativeTable {
  typedef SwapIndexFixedLegSpec TableType;
  quantra::enums::Frequency fixed_frequency = quantra::enums::Frequency_Annual;
  quantra::enums::DayCounter fixed_day_counter = quantra::enums::DayCounter_Thirty360;
  quantra::enums::Calendar fixed_calendar = quantra::enums::Calendar_TARGET;
  quantra::enums::BusinessDayConvention fixed_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  quantra::enums::BusinessDayConvention fixed_term_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  quantra::enums::DateGenerationRule fixed_date_rule = quantra::enums::DateGenerationRule_Forward;
  bool fixed_eom = false;
};

struct SwapIndexFixedLegSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapIndexFixedLegSpecT NativeTableType;
  typedef SwapIndexFixedLegSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIXED_FREQUENCY = 4,
    VT_FIXED_DAY_COUNTER = 6,
    VT_FIXED_CALENDAR = 8,
    VT_FIXED_BDC = 10,
    VT_FIXED_TERM_BDC = 12,
    VT_FIXED_DATE_RULE = 14,
    VT_FIXED_EOM = 16
  };
  quantra::enums::Frequency fixed_frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FIXED_FREQUENCY, 0));
  }
  quantra::enums::DayCounter fixed_day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_FIXED_DAY_COUNTER, 14));
  }
  quantra::enums::Calendar fixed_calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_FIXED_CALENDAR, 32));
  }
  quantra::enums::BusinessDayConvention fixed_bdc() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_FIXED_BDC, 2));
  }
  quantra::enums::BusinessDayConvention fixed_term_bdc() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_FIXED_TERM_BDC, 2));
  }
  quantra::enums::DateGenerationRule fixed_date_rule() const {
    return static_cast<quantra::enums::DateGenerationRule>(GetField<int8_t>(VT_FIXED_DATE_RULE, 2));
  }
  bool fixed_eom() const {
    return GetField<uint8_t>(VT_FIXED_EOM, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FIXED_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_BDC, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_TERM_BDC, 1) &&
           VerifyField<int8_t>(verifier, VT_FIXED_DATE_RULE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIXED_EOM, 1) &&
           verifier.EndTable();
  }
  SwapIndexFixedLegSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapIndexFixedLegSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapIndexFixedLegSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFixedLegSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapIndexFixedLegSpecBuilder {
  typedef SwapIndexFixedLegSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fixed_frequency(quantra::enums::Frequency fixed_frequency) {
    fbb_.AddElement<int8_t>(SwapIndexFixedLegSpec::VT_FIXED_FREQUENCY, static_cast<int8_t>(fixed_frequency), 0);
  }
  void add_fixed_day_counter(quantra::enums::DayCounter fixed_day_counter) {
    fbb_.AddElement<int8_t>(SwapIndexFixedLegSpec::VT_FIXED_DAY_COUNTER, static_cast<int8_t>(fixed_day_counter), 14);
  }
  void add_fixed_calendar(quantra::enums::Calendar fixed_calendar) {
    fbb_.AddElement<int8_t>(SwapIndexFixedLegSpec::VT_FIXED_CALENDAR, static_cast<int8_t>(fixed_calendar), 32);
  }
  void add_fixed_bdc(quantra::enums::BusinessDayConvention fixed_bdc) {
    fbb_.AddElement<int8_t>(SwapIndexFixedLegSpec::VT_FIXED_BDC, static_cast<int8_t>(fixed_bdc), 2);
  }
  void add_fixed_term_bdc(quantra::enums::BusinessDayConvention fixed_term_bdc) {
    fbb_.AddElement<int8_t>(SwapIndexFixedLegSpec::VT_FIXED_TERM_BDC, static_cast<int8_t>(fixed_term_bdc), 2);
  }
  void add_fixed_date_rule(quantra::enums::DateGenerationRule fixed_date_rule) {
    fbb_.AddElement<int8_t>(SwapIndexFixedLegSpec::VT_FIXED_DATE_RULE, static_cast<int8_t>(fixed_date_rule), 2);
  }
  void add_fixed_eom(bool fixed_eom) {
    fbb_.AddElement<uint8_t>(SwapIndexFixedLegSpec::VT_FIXED_EOM, static_cast<uint8_t>(fixed_eom), 0);
  }
  explicit SwapIndexFixedLegSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapIndexFixedLegSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapIndexFixedLegSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapIndexFixedLegSpec> CreateSwapIndexFixedLegSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::Frequency fixed_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::DayCounter fixed_day_counter = quantra::enums::DayCounter_Thirty360,
    quantra::enums::Calendar fixed_calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::BusinessDayConvention fixed_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::BusinessDayConvention fixed_term_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::DateGenerationRule fixed_date_rule = quantra::enums::DateGenerationRule_Forward,
    bool fixed_eom = false) {
  SwapIndexFixedLegSpecBuilder builder_(_fbb);
  builder_.add_fixed_eom(fixed_eom);
  builder_.add_fixed_date_rule(fixed_date_rule);
  builder_.add_fixed_term_bdc(fixed_term_bdc);
  builder_.add_fixed_bdc(fixed_bdc);
  builder_.add_fixed_calendar(fixed_calendar);
  builder_.add_fixed_day_counter(fixed_day_counter);
  builder_.add_fixed_frequency(fixed_frequency);
  return builder_.Finish();
}

::flatbuffers::Offset<SwapIndexFixedLegSpec> CreateSwapIndexFixedLegSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFixedLegSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwapIndexFloatLegSpecT : public ::flatbuffers::NativeTable {
  typedef SwapIndexFloatLegSpec TableType;
  int32_t float_tenor_number = 6;
  quantra::enums::TimeUnit float_tenor_time_unit = quantra::enums::TimeUnit_Months;
  quantra::enums::Calendar float_calendar = quantra::enums::Calendar_TARGET;
  quantra::enums::BusinessDayConvention float_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  quantra::enums::BusinessDayConvention float_term_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  quantra::enums::DateGenerationRule float_date_rule = quantra::enums::DateGenerationRule_Forward;
  bool float_eom = false;
};

struct SwapIndexFloatLegSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapIndexFloatLegSpecT NativeTableType;
  typedef SwapIndexFloatLegSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOAT_TENOR_NUMBER = 4,
    VT_FLOAT_TENOR_TIME_UNIT = 6,
    VT_FLOAT_CALENDAR = 8,
    VT_FLOAT_BDC = 10,
    VT_FLOAT_TERM_BDC = 12,
    VT_FLOAT_DATE_RULE = 14,
    VT_FLOAT_EOM = 16
  };
  int32_t float_tenor_number() const {
    return GetField<int32_t>(VT_FLOAT_TENOR_NUMBER, 6);
  }
  quantra::enums::TimeUnit float_tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_FLOAT_TENOR_TIME_UNIT, 5));
  }
  quantra::enums::Calendar float_calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_FLOAT_CALENDAR, 32));
  }
  quantra::enums::BusinessDayConvention float_bdc() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_FLOAT_BDC, 2));
  }
  quantra::enums::BusinessDayConvention float_term_bdc() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_FLOAT_TERM_BDC, 2));
  }
  quantra::enums::DateGenerationRule float_date_rule() const {
    return static_cast<quantra::enums::DateGenerationRule>(GetField<int8_t>(VT_FLOAT_DATE_RULE, 2));
  }
  bool float_eom() const {
    return GetField<uint8_t>(VT_FLOAT_EOM, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLOAT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_FLOAT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int8_t>(verifier, VT_FLOAT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_FLOAT_BDC, 1) &&
           VerifyField<int8_t>(verifier, VT_FLOAT_TERM_BDC, 1) &&
           VerifyField<int8_t>(verifier, VT_FLOAT_DATE_RULE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOAT_EOM, 1) &&
           verifier.EndTable();
  }
  SwapIndexFloatLegSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapIndexFloatLegSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapIndexFloatLegSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFloatLegSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapIndexFloatLegSpecBuilder {
  typedef SwapIndexFloatLegSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_float_tenor_number(int32_t float_tenor_number) {
    fbb_.AddElement<int32_t>(SwapIndexFloatLegSpec::VT_FLOAT_TENOR_NUMBER, float_tenor_number, 6);
  }
  void add_float_tenor_time_unit(quantra::enums::TimeUnit float_tenor_time_unit) {
    fbb_.AddElement<int8_t>(SwapIndexFloatLegSpec::VT_FLOAT_TENOR_TIME_UNIT, static_cast<int8_t>(float_tenor_time_unit), 5);
  }
  void add_float_calendar(quantra::enums::Calendar float_calendar) {
    fbb_.AddElement<int8_t>(SwapIndexFloatLegSpec::VT_FLOAT_CALENDAR, static_cast<int8_t>(float_calendar), 32);
  }
  void add_float_bdc(quantra::enums::BusinessDayConvention float_bdc) {
    fbb_.AddElement<int8_t>(SwapIndexFloatLegSpec::VT_FLOAT_BDC, static_cast<int8_t>(float_bdc), 2);
  }
  void add_float_term_bdc(quantra::enums::BusinessDayConvention float_term_bdc) {
    fbb_.AddElement<int8_t>(SwapIndexFloatLegSpec::VT_FLOAT_TERM_BDC, static_cast<int8_t>(float_term_bdc), 2);
  }
  void add_float_date_rule(quantra::enums::DateGenerationRule float_date_rule) {
    fbb_.AddElement<int8_t>(SwapIndexFloatLegSpec::VT_FLOAT_DATE_RULE, static_cast<int8_t>(float_date_rule), 2);
  }
  void add_float_eom(bool float_eom) {
    fbb_.AddElement<uint8_t>(SwapIndexFloatLegSpec::VT_FLOAT_EOM, static_cast<uint8_t>(float_eom), 0);
  }
  explicit SwapIndexFloatLegSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapIndexFloatLegSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapIndexFloatLegSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapIndexFloatLegSpec> CreateSwapIndexFloatLegSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t float_tenor_number = 6,
    quantra::enums::TimeUnit float_tenor_time_unit = quantra::enums::TimeUnit_Months,
    quantra::enums::Calendar float_calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::BusinessDayConvention float_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::BusinessDayConvention float_term_bdc = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    quantra::enums::DateGenerationRule float_date_rule = quantra::enums::DateGenerationRule_Forward,
    bool float_eom = false) {
  SwapIndexFloatLegSpecBuilder builder_(_fbb);
  builder_.add_float_tenor_number(float_tenor_number);
  builder_.add_float_eom(float_eom);
  builder_.add_float_date_rule(float_date_rule);
  builder_.add_float_term_bdc(float_term_bdc);
  builder_.add_float_bdc(float_bdc);
  builder_.add_float_calendar(float_calendar);
  builder_.add_float_tenor_time_unit(float_tenor_time_unit);
  return builder_.Finish();
}

::flatbuffers::Offset<SwapIndexFloatLegSpec> CreateSwapIndexFloatLegSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFloatLegSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwapIndexDefT : public ::flatbuffers::NativeTable {
  typedef SwapIndexDef TableType;
  std::string id{};
  quantra::SwapIndexKind kind = quantra::SwapIndexKind_IborSwapIndex;
  int32_t spot_days = 2;
  quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET;
  quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing;
  bool end_of_month = false;
  std::unique_ptr<quantra::SwapIndexFixedLegSpecT> fixed_leg{};
  std::string float_index_id{};
  std::unique_ptr<quantra::SwapIndexFloatLegSpecT> float_leg{};
  bool allow_override_from_trade = false;
  SwapIndexDefT() = default;
  SwapIndexDefT(const SwapIndexDefT &o);
  SwapIndexDefT(SwapIndexDefT&&) FLATBUFFERS_NOEXCEPT = default;
  SwapIndexDefT &operator=(SwapIndexDefT o) FLATBUFFERS_NOEXCEPT;
};

struct SwapIndexDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapIndexDefT NativeTableType;
  typedef SwapIndexDefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_KIND = 6,
    VT_SPOT_DAYS = 8,
    VT_CALENDAR = 10,
    VT_BUSINESS_DAY_CONVENTION = 12,
    VT_END_OF_MONTH = 14,
    VT_FIXED_LEG = 16,
    VT_FLOAT_INDEX_ID = 18,
    VT_FLOAT_LEG = 20,
    VT_ALLOW_OVERRIDE_FROM_TRADE = 22
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::SwapIndexKind kind() const {
    return static_cast<quantra::SwapIndexKind>(GetField<int8_t>(VT_KIND, 0));
  }
  int32_t spot_days() const {
    return GetField<int32_t>(VT_SPOT_DAYS, 2);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 32));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 2));
  }
  bool end_of_month() const {
    return GetField<uint8_t>(VT_END_OF_MONTH, 0) != 0;
  }
  const quantra::SwapIndexFixedLegSpec *fixed_leg() const {
    return GetPointer<const quantra::SwapIndexFixedLegSpec *>(VT_FIXED_LEG);
  }
  const ::flatbuffers::String *float_index_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FLOAT_INDEX_ID);
  }
  const quantra::SwapIndexFloatLegSpec *float_leg() const {
    return GetPointer<const quantra::SwapIndexFloatLegSpec *>(VT_FLOAT_LEG);
  }
  bool allow_override_from_trade() const {
    return GetField<uint8_t>(VT_ALLOW_OVERRIDE_FROM_TRADE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int8_t>(verifier, VT_KIND, 1) &&
           VerifyField<int32_t>(verifier, VT_SPOT_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_END_OF_MONTH, 1) &&
           VerifyOffset(verifier, VT_FIXED_LEG) &&
           verifier.VerifyTable(fixed_leg()) &&
           VerifyOffsetRequired(verifier, VT_FLOAT_INDEX_ID) &&
           verifier.VerifyString(float_index_id()) &&
           VerifyOffset(verifier, VT_FLOAT_LEG) &&
           verifier.VerifyTable(float_leg()) &&
           VerifyField<uint8_t>(verifier, VT_ALLOW_OVERRIDE_FROM_TRADE, 1) &&
           verifier.EndTable();
  }
  SwapIndexDefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapIndexDefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapIndexDef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapIndexDefBuilder {
  typedef SwapIndexDef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(SwapIndexDef::VT_ID, id);
  }
  void add_kind(quantra::SwapIndexKind kind) {
    fbb_.AddElement<int8_t>(SwapIndexDef::VT_KIND, static_cast<int8_t>(kind), 0);
  }
  void add_spot_days(int32_t spot_days) {
    fbb_.AddElement<int32_t>(SwapIndexDef::VT_SPOT_DAYS, spot_days, 2);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(SwapIndexDef::VT_CALENDAR, static_cast<int8_t>(calendar), 32);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(SwapIndexDef::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 2);
  }
  void add_end_of_month(bool end_of_month) {
    fbb_.AddElement<uint8_t>(SwapIndexDef::VT_END_OF_MONTH, static_cast<uint8_t>(end_of_month), 0);
  }
  void add_fixed_leg(::flatbuffers::Offset<quantra::SwapIndexFixedLegSpec> fixed_leg) {
    fbb_.AddOffset(SwapIndexDef::VT_FIXED_LEG, fixed_leg);
  }
  void add_float_index_id(::flatbuffers::Offset<::flatbuffers::String> float_index_id) {
    fbb_.AddOffset(SwapIndexDef::VT_FLOAT_INDEX_ID, float_index_id);
  }
  void add_float_leg(::flatbuffers::Offset<quantra::SwapIndexFloatLegSpec> float_leg) {
    fbb_.AddOffset(SwapIndexDef::VT_FLOAT_LEG, float_leg);
  }
  void add_allow_override_from_trade(bool allow_override_from_trade) {
    fbb_.AddElement<uint8_t>(SwapIndexDef::VT_ALLOW_OVERRIDE_FROM_TRADE, static_cast<uint8_t>(allow_override_from_trade), 0);
  }
  explicit SwapIndexDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapIndexDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapIndexDef>(end);
    fbb_.Required(o, SwapIndexDef::VT_ID);
    fbb_.Required(o, SwapIndexDef::VT_FLOAT_INDEX_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapIndexDef> CreateSwapIndexDef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::SwapIndexKind kind = quantra::SwapIndexKind_IborSwapIndex,
    int32_t spot_days = 2,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    bool end_of_month = false,
    ::flatbuffers::Offset<quantra::SwapIndexFixedLegSpec> fixed_leg = 0,
    ::flatbuffers::Offset<::flatbuffers::String> float_index_id = 0,
    ::flatbuffers::Offset<quantra::SwapIndexFloatLegSpec> float_leg = 0,
    bool allow_override_from_trade = false) {
  SwapIndexDefBuilder builder_(_fbb);
  builder_.add_float_leg(float_leg);
  builder_.add_float_index_id(float_index_id);
  builder_.add_fixed_leg(fixed_leg);
  builder_.add_spot_days(spot_days);
  builder_.add_id(id);
  builder_.add_allow_override_from_trade(allow_override_from_trade);
  builder_.add_end_of_month(end_of_month);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapIndexDef> CreateSwapIndexDefDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::SwapIndexKind kind = quantra::SwapIndexKind_IborSwapIndex,
    int32_t spot_days = 2,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_TARGET,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_ModifiedFollowing,
    bool end_of_month = false,
    ::flatbuffers::Offset<quantra::SwapIndexFixedLegSpec> fixed_leg = 0,
    const char *float_index_id = nullptr,
    ::flatbuffers::Offset<quantra::SwapIndexFloatLegSpec> float_leg = 0,
    bool allow_override_from_trade = false) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto float_index_id__ = float_index_id ? _fbb.CreateString(float_index_id) : 0;
  return quantra::CreateSwapIndexDef(
      _fbb,
      id__,
      kind,
      spot_days,
      calendar,
      business_day_convention,
      end_of_month,
      fixed_leg,
      float_index_id__,
      float_leg,
      allow_override_from_trade);
}

::flatbuffers::Offset<SwapIndexDef> CreateSwapIndexDef(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SwapIndexFixedLegSpecT *SwapIndexFixedLegSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapIndexFixedLegSpecT>(new SwapIndexFixedLegSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapIndexFixedLegSpec::UnPackTo(SwapIndexFixedLegSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fixed_frequency(); _o->fixed_frequency = _e; }
  { auto _e = fixed_day_counter(); _o->fixed_day_counter = _e; }
  { auto _e = fixed_calendar(); _o->fixed_calendar = _e; }
  { auto _e = fixed_bdc(); _o->fixed_bdc = _e; }
  { auto _e = fixed_term_bdc(); _o->fixed_term_bdc = _e; }
  { auto _e = fixed_date_rule(); _o->fixed_date_rule = _e; }
  { auto _e = fixed_eom(); _o->fixed_eom = _e; }
}

inline ::flatbuffers::Offset<SwapIndexFixedLegSpec> SwapIndexFixedLegSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFixedLegSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapIndexFixedLegSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapIndexFixedLegSpec> CreateSwapIndexFixedLegSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFixedLegSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapIndexFixedLegSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fixed_frequency = _o->fixed_frequency;
  auto _fixed_day_counter = _o->fixed_day_counter;
  auto _fixed_calendar = _o->fixed_calendar;
  auto _fixed_bdc = _o->fixed_bdc;
  auto _fixed_term_bdc = _o->fixed_term_bdc;
  auto _fixed_date_rule = _o->fixed_date_rule;
  auto _fixed_eom = _o->fixed_eom;
  return quantra::CreateSwapIndexFixedLegSpec(
      _fbb,
      _fixed_frequency,
      _fixed_day_counter,
      _fixed_calendar,
      _fixed_bdc,
      _fixed_term_bdc,
      _fixed_date_rule,
      _fixed_eom);
}

inline SwapIndexFloatLegSpecT *SwapIndexFloatLegSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapIndexFloatLegSpecT>(new SwapIndexFloatLegSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapIndexFloatLegSpec::UnPackTo(SwapIndexFloatLegSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = float_tenor_number(); _o->float_tenor_number = _e; }
  { auto _e = float_tenor_time_unit(); _o->float_tenor_time_unit = _e; }
  { auto _e = float_calendar(); _o->float_calendar = _e; }
  { auto _e = float_bdc(); _o->float_bdc = _e; }
  { auto _e = float_term_bdc(); _o->float_term_bdc = _e; }
  { auto _e = float_date_rule(); _o->float_date_rule = _e; }
  { auto _e = float_eom(); _o->float_eom = _e; }
}

inline ::flatbuffers::Offset<SwapIndexFloatLegSpec> SwapIndexFloatLegSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFloatLegSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapIndexFloatLegSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapIndexFloatLegSpec> CreateSwapIndexFloatLegSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexFloatLegSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapIndexFloatLegSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _float_tenor_number = _o->float_tenor_number;
  auto _float_tenor_time_unit = _o->float_tenor_time_unit;
  auto _float_calendar = _o->float_calendar;
  auto _float_bdc = _o->float_bdc;
  auto _float_term_bdc = _o->float_term_bdc;
  auto _float_date_rule = _o->float_date_rule;
  auto _float_eom = _o->float_eom;
  return quantra::CreateSwapIndexFloatLegSpec(
      _fbb,
      _float_tenor_number,
      _float_tenor_time_unit,
      _float_calendar,
      _float_bdc,
      _float_term_bdc,
      _float_date_rule,
      _float_eom);
}

inline SwapIndexDefT::SwapIndexDefT(const SwapIndexDefT &o)
      : id(o.id),
        kind(o.kind),
        spot_days(o.spot_days),
        calendar(o.calendar),
        business_day_convention(o.business_day_convention),
        end_of_month(o.end_of_month),
        fixed_leg((o.fixed_leg) ? new quantra::SwapIndexFixedLegSpecT(*o.fixed_leg) : nullptr),
        float_index_id(o.float_index_id),
        float_leg((o.float_leg) ? new quantra::SwapIndexFloatLegSpecT(*o.float_leg) : nullptr),
        allow_override_from_trade(o.allow_override_from_trade) {
}

inline SwapIndexDefT &SwapIndexDefT::operator=(SwapIndexDefT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(kind, o.kind);
  std::swap(spot_days, o.spot_days);
  std::swap(calendar, o.calendar);
  std::swap(business_day_convention, o.business_day_convention);
  std::swap(end_of_month, o.end_of_month);
  std::swap(fixed_leg, o.fixed_leg);
  std::swap(float_index_id, o.float_index_id);
  std::swap(float_leg, o.float_leg);
  std::swap(allow_override_from_trade, o.allow_override_from_trade);
  return *this;
}

inline SwapIndexDefT *SwapIndexDef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapIndexDefT>(new SwapIndexDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapIndexDef::UnPackTo(SwapIndexDefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = kind(); _o->kind = _e; }
  { auto _e = spot_days(); _o->spot_days = _e; }
  { auto _e = calendar(); _o->calendar = _e; }
  { auto _e = business_day_convention(); _o->business_day_convention = _e; }
  { auto _e = end_of_month(); _o->end_of_month = _e; }
  { auto _e = fixed_leg(); if (_e) { if(_o->fixed_leg) { _e->UnPackTo(_o->fixed_leg.get(), _resolver); } else { _o->fixed_leg = std::unique_ptr<quantra::SwapIndexFixedLegSpecT>(_e->UnPack(_resolver)); } } else if (_o->fixed_leg) { _o->fixed_leg.reset(); } }
  { auto _e = float_index_id(); if (_e) _o->float_index_id = _e->str(); }
  { auto _e = float_leg(); if (_e) { if(_o->float_leg) { _e->UnPackTo(_o->float_leg.get(), _resolver); } else { _o->float_leg = std::unique_ptr<quantra::SwapIndexFloatLegSpecT>(_e->UnPack(_resolver)); } } else if (_o->float_leg) { _o->float_leg.reset(); } }
  { auto _e = allow_override_from_trade(); _o->allow_override_from_trade = _e; }
}

inline ::flatbuffers::Offset<SwapIndexDef> SwapIndexDef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapIndexDef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapIndexDef> CreateSwapIndexDef(::flatbuffers::FlatBufferBuilder &_fbb, const SwapIndexDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapIndexDefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _kind = _o->kind;
  auto _spot_days = _o->spot_days;
  auto _calendar = _o->calendar;
  auto _business_day_convention = _o->business_day_convention;
  auto _end_of_month = _o->end_of_month;
  auto _fixed_leg = _o->fixed_leg ? CreateSwapIndexFixedLegSpec(_fbb, _o->fixed_leg.get(), _rehasher) : 0;
  auto _float_index_id = _fbb.CreateString(_o->float_index_id);
  auto _float_leg = _o->float_leg ? CreateSwapIndexFloatLegSpec(_fbb, _o->float_leg.get(), _rehasher) : 0;
  auto _allow_override_from_trade = _o->allow_override_from_trade;
  return quantra::CreateSwapIndexDef(
      _fbb,
      _id,
      _kind,
      _spot_days,
      _calendar,
      _business_day_convention,
      _end_of_month,
      _fixed_leg,
      _float_index_id,
      _float_leg,
      _allow_override_from_trade);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_SWAPINDEX_QUANTRA_H_
