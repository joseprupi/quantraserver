// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_QUANTRA_H_
#define FLATBUFFERS_GENERATED_MODEL_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"

namespace quantra {

struct CapFloorModelSpec;
struct CapFloorModelSpecBuilder;
struct CapFloorModelSpecT;

struct SwaptionModelSpec;
struct SwaptionModelSpecBuilder;
struct SwaptionModelSpecT;

struct EquityVanillaModelSpec;
struct EquityVanillaModelSpecBuilder;
struct EquityVanillaModelSpecT;

struct ModelSpec;
struct ModelSpecBuilder;
struct ModelSpecT;

/// Union of all model types
enum ModelPayload : uint8_t {
  ModelPayload_NONE = 0,
  ModelPayload_CapFloorModelSpec = 1,
  ModelPayload_SwaptionModelSpec = 2,
  ModelPayload_EquityVanillaModelSpec = 3,
  ModelPayload_MIN = ModelPayload_NONE,
  ModelPayload_MAX = ModelPayload_EquityVanillaModelSpec
};

inline const ModelPayload (&EnumValuesModelPayload())[4] {
  static const ModelPayload values[] = {
    ModelPayload_NONE,
    ModelPayload_CapFloorModelSpec,
    ModelPayload_SwaptionModelSpec,
    ModelPayload_EquityVanillaModelSpec
  };
  return values;
}

inline const char * const *EnumNamesModelPayload() {
  static const char * const names[5] = {
    "NONE",
    "CapFloorModelSpec",
    "SwaptionModelSpec",
    "EquityVanillaModelSpec",
    nullptr
  };
  return names;
}

inline const char *EnumNameModelPayload(ModelPayload e) {
  if (::flatbuffers::IsOutRange(e, ModelPayload_NONE, ModelPayload_EquityVanillaModelSpec)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModelPayload()[index];
}

template<typename T> struct ModelPayloadTraits {
  static const ModelPayload enum_value = ModelPayload_NONE;
};

template<> struct ModelPayloadTraits<quantra::CapFloorModelSpec> {
  static const ModelPayload enum_value = ModelPayload_CapFloorModelSpec;
};

template<> struct ModelPayloadTraits<quantra::SwaptionModelSpec> {
  static const ModelPayload enum_value = ModelPayload_SwaptionModelSpec;
};

template<> struct ModelPayloadTraits<quantra::EquityVanillaModelSpec> {
  static const ModelPayload enum_value = ModelPayload_EquityVanillaModelSpec;
};

template<typename T> struct ModelPayloadUnionTraits {
  static const ModelPayload enum_value = ModelPayload_NONE;
};

template<> struct ModelPayloadUnionTraits<quantra::CapFloorModelSpecT> {
  static const ModelPayload enum_value = ModelPayload_CapFloorModelSpec;
};

template<> struct ModelPayloadUnionTraits<quantra::SwaptionModelSpecT> {
  static const ModelPayload enum_value = ModelPayload_SwaptionModelSpec;
};

template<> struct ModelPayloadUnionTraits<quantra::EquityVanillaModelSpecT> {
  static const ModelPayload enum_value = ModelPayload_EquityVanillaModelSpec;
};

struct ModelPayloadUnion {
  ModelPayload type;
  void *value;

  ModelPayloadUnion() : type(ModelPayload_NONE), value(nullptr) {}
  ModelPayloadUnion(ModelPayloadUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ModelPayload_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ModelPayloadUnion(const ModelPayloadUnion &);
  ModelPayloadUnion &operator=(const ModelPayloadUnion &u)
    { ModelPayloadUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ModelPayloadUnion &operator=(ModelPayloadUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ModelPayloadUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ModelPayloadUnionTraits<RT>::enum_value;
    if (type != ModelPayload_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ModelPayload type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::CapFloorModelSpecT *AsCapFloorModelSpec() {
    return type == ModelPayload_CapFloorModelSpec ?
      reinterpret_cast<quantra::CapFloorModelSpecT *>(value) : nullptr;
  }
  const quantra::CapFloorModelSpecT *AsCapFloorModelSpec() const {
    return type == ModelPayload_CapFloorModelSpec ?
      reinterpret_cast<const quantra::CapFloorModelSpecT *>(value) : nullptr;
  }
  quantra::SwaptionModelSpecT *AsSwaptionModelSpec() {
    return type == ModelPayload_SwaptionModelSpec ?
      reinterpret_cast<quantra::SwaptionModelSpecT *>(value) : nullptr;
  }
  const quantra::SwaptionModelSpecT *AsSwaptionModelSpec() const {
    return type == ModelPayload_SwaptionModelSpec ?
      reinterpret_cast<const quantra::SwaptionModelSpecT *>(value) : nullptr;
  }
  quantra::EquityVanillaModelSpecT *AsEquityVanillaModelSpec() {
    return type == ModelPayload_EquityVanillaModelSpec ?
      reinterpret_cast<quantra::EquityVanillaModelSpecT *>(value) : nullptr;
  }
  const quantra::EquityVanillaModelSpecT *AsEquityVanillaModelSpec() const {
    return type == ModelPayload_EquityVanillaModelSpec ?
      reinterpret_cast<const quantra::EquityVanillaModelSpecT *>(value) : nullptr;
  }
};

bool VerifyModelPayload(::flatbuffers::Verifier &verifier, const void *obj, ModelPayload type);
bool VerifyModelPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct CapFloorModelSpecT : public ::flatbuffers::NativeTable {
  typedef CapFloorModelSpec TableType;
  quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black;
};

/// Cap/Floor pricing model specification
struct CapFloorModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CapFloorModelSpecT NativeTableType;
  typedef CapFloorModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_TYPE = 4
  };
  quantra::enums::IrModelType model_type() const {
    return static_cast<quantra::enums::IrModelType>(GetField<int8_t>(VT_MODEL_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODEL_TYPE, 1) &&
           verifier.EndTable();
  }
  CapFloorModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CapFloorModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CapFloorModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CapFloorModelSpecBuilder {
  typedef CapFloorModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model_type(quantra::enums::IrModelType model_type) {
    fbb_.AddElement<int8_t>(CapFloorModelSpec::VT_MODEL_TYPE, static_cast<int8_t>(model_type), 0);
  }
  explicit CapFloorModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CapFloorModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CapFloorModelSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CapFloorModelSpec> CreateCapFloorModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black) {
  CapFloorModelSpecBuilder builder_(_fbb);
  builder_.add_model_type(model_type);
  return builder_.Finish();
}

::flatbuffers::Offset<CapFloorModelSpec> CreateCapFloorModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwaptionModelSpecT : public ::flatbuffers::NativeTable {
  typedef SwaptionModelSpec TableType;
  quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black;
};

/// Swaption pricing model specification
struct SwaptionModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwaptionModelSpecT NativeTableType;
  typedef SwaptionModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_TYPE = 4
  };
  quantra::enums::IrModelType model_type() const {
    return static_cast<quantra::enums::IrModelType>(GetField<int8_t>(VT_MODEL_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODEL_TYPE, 1) &&
           verifier.EndTable();
  }
  SwaptionModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwaptionModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwaptionModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwaptionModelSpecBuilder {
  typedef SwaptionModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model_type(quantra::enums::IrModelType model_type) {
    fbb_.AddElement<int8_t>(SwaptionModelSpec::VT_MODEL_TYPE, static_cast<int8_t>(model_type), 0);
  }
  explicit SwaptionModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwaptionModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwaptionModelSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwaptionModelSpec> CreateSwaptionModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black) {
  SwaptionModelSpecBuilder builder_(_fbb);
  builder_.add_model_type(model_type);
  return builder_.Finish();
}

::flatbuffers::Offset<SwaptionModelSpec> CreateSwaptionModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EquityVanillaModelSpecT : public ::flatbuffers::NativeTable {
  typedef EquityVanillaModelSpec TableType;
  quantra::enums::EquityModelType model_type = quantra::enums::EquityModelType_BlackScholesAnalytic;
  int32_t binomial_steps = 500;
};

/// Equity vanilla option pricing model specification (future)
struct EquityVanillaModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EquityVanillaModelSpecT NativeTableType;
  typedef EquityVanillaModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_TYPE = 4,
    VT_BINOMIAL_STEPS = 6
  };
  quantra::enums::EquityModelType model_type() const {
    return static_cast<quantra::enums::EquityModelType>(GetField<int8_t>(VT_MODEL_TYPE, 0));
  }
  int32_t binomial_steps() const {
    return GetField<int32_t>(VT_BINOMIAL_STEPS, 500);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODEL_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_BINOMIAL_STEPS, 4) &&
           verifier.EndTable();
  }
  EquityVanillaModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EquityVanillaModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EquityVanillaModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EquityVanillaModelSpecBuilder {
  typedef EquityVanillaModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model_type(quantra::enums::EquityModelType model_type) {
    fbb_.AddElement<int8_t>(EquityVanillaModelSpec::VT_MODEL_TYPE, static_cast<int8_t>(model_type), 0);
  }
  void add_binomial_steps(int32_t binomial_steps) {
    fbb_.AddElement<int32_t>(EquityVanillaModelSpec::VT_BINOMIAL_STEPS, binomial_steps, 500);
  }
  explicit EquityVanillaModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EquityVanillaModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EquityVanillaModelSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EquityVanillaModelSpec> CreateEquityVanillaModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::EquityModelType model_type = quantra::enums::EquityModelType_BlackScholesAnalytic,
    int32_t binomial_steps = 500) {
  EquityVanillaModelSpecBuilder builder_(_fbb);
  builder_.add_binomial_steps(binomial_steps);
  builder_.add_model_type(model_type);
  return builder_.Finish();
}

::flatbuffers::Offset<EquityVanillaModelSpec> CreateEquityVanillaModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelSpecT : public ::flatbuffers::NativeTable {
  typedef ModelSpec TableType;
  std::string id{};
  quantra::ModelPayloadUnion payload{};
};

/// Model specification - references by id in trade requests
struct ModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelSpecT NativeTableType;
  typedef ModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::ModelPayload payload_type() const {
    return static_cast<quantra::ModelPayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const quantra::CapFloorModelSpec *payload_as_CapFloorModelSpec() const {
    return payload_type() == quantra::ModelPayload_CapFloorModelSpec ? static_cast<const quantra::CapFloorModelSpec *>(payload()) : nullptr;
  }
  const quantra::SwaptionModelSpec *payload_as_SwaptionModelSpec() const {
    return payload_type() == quantra::ModelPayload_SwaptionModelSpec ? static_cast<const quantra::SwaptionModelSpec *>(payload()) : nullptr;
  }
  const quantra::EquityVanillaModelSpec *payload_as_EquityVanillaModelSpec() const {
    return payload_type() == quantra::ModelPayload_EquityVanillaModelSpec ? static_cast<const quantra::EquityVanillaModelSpec *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyModelPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
  ModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::CapFloorModelSpec *ModelSpec::payload_as<quantra::CapFloorModelSpec>() const {
  return payload_as_CapFloorModelSpec();
}

template<> inline const quantra::SwaptionModelSpec *ModelSpec::payload_as<quantra::SwaptionModelSpec>() const {
  return payload_as_SwaptionModelSpec();
}

template<> inline const quantra::EquityVanillaModelSpec *ModelSpec::payload_as<quantra::EquityVanillaModelSpec>() const {
  return payload_as_EquityVanillaModelSpec();
}

struct ModelSpecBuilder {
  typedef ModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ModelSpec::VT_ID, id);
  }
  void add_payload_type(quantra::ModelPayload payload_type) {
    fbb_.AddElement<uint8_t>(ModelSpec::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(ModelSpec::VT_PAYLOAD, payload);
  }
  explicit ModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelSpec>(end);
    fbb_.Required(o, ModelSpec::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelSpec> CreateModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::ModelPayload payload_type = quantra::ModelPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  ModelSpecBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_id(id);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelSpec> CreateModelSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::ModelPayload payload_type = quantra::ModelPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return quantra::CreateModelSpec(
      _fbb,
      id__,
      payload_type,
      payload);
}

::flatbuffers::Offset<ModelSpec> CreateModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CapFloorModelSpecT *CapFloorModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CapFloorModelSpecT>(new CapFloorModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CapFloorModelSpec::UnPackTo(CapFloorModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model_type(); _o->model_type = _e; }
}

inline ::flatbuffers::Offset<CapFloorModelSpec> CapFloorModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCapFloorModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CapFloorModelSpec> CreateCapFloorModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CapFloorModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model_type = _o->model_type;
  return quantra::CreateCapFloorModelSpec(
      _fbb,
      _model_type);
}

inline SwaptionModelSpecT *SwaptionModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwaptionModelSpecT>(new SwaptionModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwaptionModelSpec::UnPackTo(SwaptionModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model_type(); _o->model_type = _e; }
}

inline ::flatbuffers::Offset<SwaptionModelSpec> SwaptionModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwaptionModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwaptionModelSpec> CreateSwaptionModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwaptionModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model_type = _o->model_type;
  return quantra::CreateSwaptionModelSpec(
      _fbb,
      _model_type);
}

inline EquityVanillaModelSpecT *EquityVanillaModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EquityVanillaModelSpecT>(new EquityVanillaModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EquityVanillaModelSpec::UnPackTo(EquityVanillaModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model_type(); _o->model_type = _e; }
  { auto _e = binomial_steps(); _o->binomial_steps = _e; }
}

inline ::flatbuffers::Offset<EquityVanillaModelSpec> EquityVanillaModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEquityVanillaModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EquityVanillaModelSpec> CreateEquityVanillaModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EquityVanillaModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model_type = _o->model_type;
  auto _binomial_steps = _o->binomial_steps;
  return quantra::CreateEquityVanillaModelSpec(
      _fbb,
      _model_type,
      _binomial_steps);
}

inline ModelSpecT *ModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ModelSpecT>(new ModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ModelSpec::UnPackTo(ModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = payload_type(); _o->payload.type = _e; }
  { auto _e = payload(); if (_e) _o->payload.value = quantra::ModelPayloadUnion::UnPack(_e, payload_type(), _resolver); }
}

inline ::flatbuffers::Offset<ModelSpec> ModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ModelSpec> CreateModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _payload_type = _o->payload.type;
  auto _payload = _o->payload.Pack(_fbb);
  return quantra::CreateModelSpec(
      _fbb,
      _id,
      _payload_type,
      _payload);
}

inline bool VerifyModelPayload(::flatbuffers::Verifier &verifier, const void *obj, ModelPayload type) {
  switch (type) {
    case ModelPayload_NONE: {
      return true;
    }
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CapFloorModelSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionModelSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<const quantra::EquityVanillaModelSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyModelPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyModelPayload(
        verifier,  values->Get(i), types->GetEnum<ModelPayload>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ModelPayloadUnion::UnPack(const void *obj, ModelPayload type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CapFloorModelSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionModelSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<const quantra::EquityVanillaModelSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ModelPayloadUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CapFloorModelSpecT *>(value);
      return CreateCapFloorModelSpec(_fbb, ptr, _rehasher).Union();
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionModelSpecT *>(value);
      return CreateSwaptionModelSpec(_fbb, ptr, _rehasher).Union();
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<const quantra::EquityVanillaModelSpecT *>(value);
      return CreateEquityVanillaModelSpec(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ModelPayloadUnion::ModelPayloadUnion(const ModelPayloadUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      value = new quantra::CapFloorModelSpecT(*reinterpret_cast<quantra::CapFloorModelSpecT *>(u.value));
      break;
    }
    case ModelPayload_SwaptionModelSpec: {
      value = new quantra::SwaptionModelSpecT(*reinterpret_cast<quantra::SwaptionModelSpecT *>(u.value));
      break;
    }
    case ModelPayload_EquityVanillaModelSpec: {
      value = new quantra::EquityVanillaModelSpecT(*reinterpret_cast<quantra::EquityVanillaModelSpecT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ModelPayloadUnion::Reset() {
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<quantra::CapFloorModelSpecT *>(value);
      delete ptr;
      break;
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<quantra::SwaptionModelSpecT *>(value);
      delete ptr;
      break;
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<quantra::EquityVanillaModelSpecT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ModelPayload_NONE;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_MODEL_QUANTRA_H_
