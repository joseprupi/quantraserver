// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_QUANTRA_H_
#define FLATBUFFERS_GENERATED_MODEL_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "enums_generated.h"

namespace quantra {

struct CapFloorModelSpec;
struct CapFloorModelSpecBuilder;
struct CapFloorModelSpecT;

struct SwaptionModelSpec;
struct SwaptionModelSpecBuilder;
struct SwaptionModelSpecT;

struct CdsModelSpec;
struct CdsModelSpecBuilder;
struct CdsModelSpecT;

struct EquityVanillaModelSpec;
struct EquityVanillaModelSpecBuilder;
struct EquityVanillaModelSpecT;

struct ModelSpec;
struct ModelSpecBuilder;
struct ModelSpecT;

/// Union of all model types
enum ModelPayload : uint8_t {
  ModelPayload_NONE = 0,
  ModelPayload_CapFloorModelSpec = 1,
  ModelPayload_SwaptionModelSpec = 2,
  ModelPayload_CdsModelSpec = 3,
  ModelPayload_EquityVanillaModelSpec = 4,
  ModelPayload_MIN = ModelPayload_NONE,
  ModelPayload_MAX = ModelPayload_EquityVanillaModelSpec
};

inline const ModelPayload (&EnumValuesModelPayload())[5] {
  static const ModelPayload values[] = {
    ModelPayload_NONE,
    ModelPayload_CapFloorModelSpec,
    ModelPayload_SwaptionModelSpec,
    ModelPayload_CdsModelSpec,
    ModelPayload_EquityVanillaModelSpec
  };
  return values;
}

inline const char * const *EnumNamesModelPayload() {
  static const char * const names[6] = {
    "NONE",
    "CapFloorModelSpec",
    "SwaptionModelSpec",
    "CdsModelSpec",
    "EquityVanillaModelSpec",
    nullptr
  };
  return names;
}

inline const char *EnumNameModelPayload(ModelPayload e) {
  if (::flatbuffers::IsOutRange(e, ModelPayload_NONE, ModelPayload_EquityVanillaModelSpec)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModelPayload()[index];
}

template<typename T> struct ModelPayloadTraits {
  static const ModelPayload enum_value = ModelPayload_NONE;
};

template<> struct ModelPayloadTraits<quantra::CapFloorModelSpec> {
  static const ModelPayload enum_value = ModelPayload_CapFloorModelSpec;
};

template<> struct ModelPayloadTraits<quantra::SwaptionModelSpec> {
  static const ModelPayload enum_value = ModelPayload_SwaptionModelSpec;
};

template<> struct ModelPayloadTraits<quantra::CdsModelSpec> {
  static const ModelPayload enum_value = ModelPayload_CdsModelSpec;
};

template<> struct ModelPayloadTraits<quantra::EquityVanillaModelSpec> {
  static const ModelPayload enum_value = ModelPayload_EquityVanillaModelSpec;
};

template<typename T> struct ModelPayloadUnionTraits {
  static const ModelPayload enum_value = ModelPayload_NONE;
};

template<> struct ModelPayloadUnionTraits<quantra::CapFloorModelSpecT> {
  static const ModelPayload enum_value = ModelPayload_CapFloorModelSpec;
};

template<> struct ModelPayloadUnionTraits<quantra::SwaptionModelSpecT> {
  static const ModelPayload enum_value = ModelPayload_SwaptionModelSpec;
};

template<> struct ModelPayloadUnionTraits<quantra::CdsModelSpecT> {
  static const ModelPayload enum_value = ModelPayload_CdsModelSpec;
};

template<> struct ModelPayloadUnionTraits<quantra::EquityVanillaModelSpecT> {
  static const ModelPayload enum_value = ModelPayload_EquityVanillaModelSpec;
};

struct ModelPayloadUnion {
  ModelPayload type;
  void *value;

  ModelPayloadUnion() : type(ModelPayload_NONE), value(nullptr) {}
  ModelPayloadUnion(ModelPayloadUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ModelPayload_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ModelPayloadUnion(const ModelPayloadUnion &);
  ModelPayloadUnion &operator=(const ModelPayloadUnion &u)
    { ModelPayloadUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ModelPayloadUnion &operator=(ModelPayloadUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ModelPayloadUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ModelPayloadUnionTraits<RT>::enum_value;
    if (type != ModelPayload_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ModelPayload type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  quantra::CapFloorModelSpecT *AsCapFloorModelSpec() {
    return type == ModelPayload_CapFloorModelSpec ?
      reinterpret_cast<quantra::CapFloorModelSpecT *>(value) : nullptr;
  }
  const quantra::CapFloorModelSpecT *AsCapFloorModelSpec() const {
    return type == ModelPayload_CapFloorModelSpec ?
      reinterpret_cast<const quantra::CapFloorModelSpecT *>(value) : nullptr;
  }
  quantra::SwaptionModelSpecT *AsSwaptionModelSpec() {
    return type == ModelPayload_SwaptionModelSpec ?
      reinterpret_cast<quantra::SwaptionModelSpecT *>(value) : nullptr;
  }
  const quantra::SwaptionModelSpecT *AsSwaptionModelSpec() const {
    return type == ModelPayload_SwaptionModelSpec ?
      reinterpret_cast<const quantra::SwaptionModelSpecT *>(value) : nullptr;
  }
  quantra::CdsModelSpecT *AsCdsModelSpec() {
    return type == ModelPayload_CdsModelSpec ?
      reinterpret_cast<quantra::CdsModelSpecT *>(value) : nullptr;
  }
  const quantra::CdsModelSpecT *AsCdsModelSpec() const {
    return type == ModelPayload_CdsModelSpec ?
      reinterpret_cast<const quantra::CdsModelSpecT *>(value) : nullptr;
  }
  quantra::EquityVanillaModelSpecT *AsEquityVanillaModelSpec() {
    return type == ModelPayload_EquityVanillaModelSpec ?
      reinterpret_cast<quantra::EquityVanillaModelSpecT *>(value) : nullptr;
  }
  const quantra::EquityVanillaModelSpecT *AsEquityVanillaModelSpec() const {
    return type == ModelPayload_EquityVanillaModelSpec ?
      reinterpret_cast<const quantra::EquityVanillaModelSpecT *>(value) : nullptr;
  }
};

bool VerifyModelPayload(::flatbuffers::Verifier &verifier, const void *obj, ModelPayload type);
bool VerifyModelPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct CapFloorModelSpecT : public ::flatbuffers::NativeTable {
  typedef CapFloorModelSpec TableType;
  quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black;
};

/// Cap/Floor pricing model specification
struct CapFloorModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CapFloorModelSpecT NativeTableType;
  typedef CapFloorModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_TYPE = 4
  };
  quantra::enums::IrModelType model_type() const {
    return static_cast<quantra::enums::IrModelType>(GetField<int8_t>(VT_MODEL_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODEL_TYPE, 1) &&
           verifier.EndTable();
  }
  CapFloorModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CapFloorModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CapFloorModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CapFloorModelSpecBuilder {
  typedef CapFloorModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model_type(quantra::enums::IrModelType model_type) {
    fbb_.AddElement<int8_t>(CapFloorModelSpec::VT_MODEL_TYPE, static_cast<int8_t>(model_type), 0);
  }
  explicit CapFloorModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CapFloorModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CapFloorModelSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CapFloorModelSpec> CreateCapFloorModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black) {
  CapFloorModelSpecBuilder builder_(_fbb);
  builder_.add_model_type(model_type);
  return builder_.Finish();
}

::flatbuffers::Offset<CapFloorModelSpec> CreateCapFloorModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwaptionModelSpecT : public ::flatbuffers::NativeTable {
  typedef SwaptionModelSpec TableType;
  quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black;
};

/// Swaption pricing model specification
struct SwaptionModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwaptionModelSpecT NativeTableType;
  typedef SwaptionModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_TYPE = 4
  };
  quantra::enums::IrModelType model_type() const {
    return static_cast<quantra::enums::IrModelType>(GetField<int8_t>(VT_MODEL_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODEL_TYPE, 1) &&
           verifier.EndTable();
  }
  SwaptionModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwaptionModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwaptionModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwaptionModelSpecBuilder {
  typedef SwaptionModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model_type(quantra::enums::IrModelType model_type) {
    fbb_.AddElement<int8_t>(SwaptionModelSpec::VT_MODEL_TYPE, static_cast<int8_t>(model_type), 0);
  }
  explicit SwaptionModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwaptionModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwaptionModelSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwaptionModelSpec> CreateSwaptionModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::IrModelType model_type = quantra::enums::IrModelType_Black) {
  SwaptionModelSpecBuilder builder_(_fbb);
  builder_.add_model_type(model_type);
  return builder_.Finish();
}

::flatbuffers::Offset<SwaptionModelSpec> CreateSwaptionModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CdsModelSpecT : public ::flatbuffers::NativeTable {
  typedef CdsModelSpec TableType;
  quantra::enums::CdsEngineType engine_type = quantra::enums::CdsEngineType_MidPoint;
  bool include_settlement_date_flows = false;
  quantra::enums::CdsIsdaNumericalFix isda_numerical_fix = quantra::enums::CdsIsdaNumericalFix_Taylor;
  quantra::enums::CdsIsdaAccrualBias isda_accrual_bias = quantra::enums::CdsIsdaAccrualBias_HalfDayBias;
  quantra::enums::CdsIsdaForwardsInCouponPeriod isda_forwards_in_coupon_period = quantra::enums::CdsIsdaForwardsInCouponPeriod_Piecewise;
};

/// CDS pricing model specification
struct CdsModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CdsModelSpecT NativeTableType;
  typedef CdsModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENGINE_TYPE = 4,
    VT_INCLUDE_SETTLEMENT_DATE_FLOWS = 6,
    VT_ISDA_NUMERICAL_FIX = 8,
    VT_ISDA_ACCRUAL_BIAS = 10,
    VT_ISDA_FORWARDS_IN_COUPON_PERIOD = 12
  };
  quantra::enums::CdsEngineType engine_type() const {
    return static_cast<quantra::enums::CdsEngineType>(GetField<int8_t>(VT_ENGINE_TYPE, 0));
  }
  bool include_settlement_date_flows() const {
    return GetField<uint8_t>(VT_INCLUDE_SETTLEMENT_DATE_FLOWS, 0) != 0;
  }
  quantra::enums::CdsIsdaNumericalFix isda_numerical_fix() const {
    return static_cast<quantra::enums::CdsIsdaNumericalFix>(GetField<int8_t>(VT_ISDA_NUMERICAL_FIX, 1));
  }
  quantra::enums::CdsIsdaAccrualBias isda_accrual_bias() const {
    return static_cast<quantra::enums::CdsIsdaAccrualBias>(GetField<int8_t>(VT_ISDA_ACCRUAL_BIAS, 0));
  }
  quantra::enums::CdsIsdaForwardsInCouponPeriod isda_forwards_in_coupon_period() const {
    return static_cast<quantra::enums::CdsIsdaForwardsInCouponPeriod>(GetField<int8_t>(VT_ISDA_FORWARDS_IN_COUPON_PERIOD, 1));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ENGINE_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_SETTLEMENT_DATE_FLOWS, 1) &&
           VerifyField<int8_t>(verifier, VT_ISDA_NUMERICAL_FIX, 1) &&
           VerifyField<int8_t>(verifier, VT_ISDA_ACCRUAL_BIAS, 1) &&
           VerifyField<int8_t>(verifier, VT_ISDA_FORWARDS_IN_COUPON_PERIOD, 1) &&
           verifier.EndTable();
  }
  CdsModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CdsModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CdsModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CdsModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CdsModelSpecBuilder {
  typedef CdsModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_engine_type(quantra::enums::CdsEngineType engine_type) {
    fbb_.AddElement<int8_t>(CdsModelSpec::VT_ENGINE_TYPE, static_cast<int8_t>(engine_type), 0);
  }
  void add_include_settlement_date_flows(bool include_settlement_date_flows) {
    fbb_.AddElement<uint8_t>(CdsModelSpec::VT_INCLUDE_SETTLEMENT_DATE_FLOWS, static_cast<uint8_t>(include_settlement_date_flows), 0);
  }
  void add_isda_numerical_fix(quantra::enums::CdsIsdaNumericalFix isda_numerical_fix) {
    fbb_.AddElement<int8_t>(CdsModelSpec::VT_ISDA_NUMERICAL_FIX, static_cast<int8_t>(isda_numerical_fix), 1);
  }
  void add_isda_accrual_bias(quantra::enums::CdsIsdaAccrualBias isda_accrual_bias) {
    fbb_.AddElement<int8_t>(CdsModelSpec::VT_ISDA_ACCRUAL_BIAS, static_cast<int8_t>(isda_accrual_bias), 0);
  }
  void add_isda_forwards_in_coupon_period(quantra::enums::CdsIsdaForwardsInCouponPeriod isda_forwards_in_coupon_period) {
    fbb_.AddElement<int8_t>(CdsModelSpec::VT_ISDA_FORWARDS_IN_COUPON_PERIOD, static_cast<int8_t>(isda_forwards_in_coupon_period), 1);
  }
  explicit CdsModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CdsModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CdsModelSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CdsModelSpec> CreateCdsModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::CdsEngineType engine_type = quantra::enums::CdsEngineType_MidPoint,
    bool include_settlement_date_flows = false,
    quantra::enums::CdsIsdaNumericalFix isda_numerical_fix = quantra::enums::CdsIsdaNumericalFix_Taylor,
    quantra::enums::CdsIsdaAccrualBias isda_accrual_bias = quantra::enums::CdsIsdaAccrualBias_HalfDayBias,
    quantra::enums::CdsIsdaForwardsInCouponPeriod isda_forwards_in_coupon_period = quantra::enums::CdsIsdaForwardsInCouponPeriod_Piecewise) {
  CdsModelSpecBuilder builder_(_fbb);
  builder_.add_isda_forwards_in_coupon_period(isda_forwards_in_coupon_period);
  builder_.add_isda_accrual_bias(isda_accrual_bias);
  builder_.add_isda_numerical_fix(isda_numerical_fix);
  builder_.add_include_settlement_date_flows(include_settlement_date_flows);
  builder_.add_engine_type(engine_type);
  return builder_.Finish();
}

::flatbuffers::Offset<CdsModelSpec> CreateCdsModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CdsModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EquityVanillaModelSpecT : public ::flatbuffers::NativeTable {
  typedef EquityVanillaModelSpec TableType;
  quantra::enums::EquityModelType model_type = quantra::enums::EquityModelType_BlackScholesAnalytic;
  int32_t binomial_steps = 500;
};

/// Equity vanilla option pricing model specification (future)
struct EquityVanillaModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EquityVanillaModelSpecT NativeTableType;
  typedef EquityVanillaModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_TYPE = 4,
    VT_BINOMIAL_STEPS = 6
  };
  quantra::enums::EquityModelType model_type() const {
    return static_cast<quantra::enums::EquityModelType>(GetField<int8_t>(VT_MODEL_TYPE, 0));
  }
  int32_t binomial_steps() const {
    return GetField<int32_t>(VT_BINOMIAL_STEPS, 500);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODEL_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_BINOMIAL_STEPS, 4) &&
           verifier.EndTable();
  }
  EquityVanillaModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EquityVanillaModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EquityVanillaModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EquityVanillaModelSpecBuilder {
  typedef EquityVanillaModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_model_type(quantra::enums::EquityModelType model_type) {
    fbb_.AddElement<int8_t>(EquityVanillaModelSpec::VT_MODEL_TYPE, static_cast<int8_t>(model_type), 0);
  }
  void add_binomial_steps(int32_t binomial_steps) {
    fbb_.AddElement<int32_t>(EquityVanillaModelSpec::VT_BINOMIAL_STEPS, binomial_steps, 500);
  }
  explicit EquityVanillaModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EquityVanillaModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EquityVanillaModelSpec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EquityVanillaModelSpec> CreateEquityVanillaModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::EquityModelType model_type = quantra::enums::EquityModelType_BlackScholesAnalytic,
    int32_t binomial_steps = 500) {
  EquityVanillaModelSpecBuilder builder_(_fbb);
  builder_.add_binomial_steps(binomial_steps);
  builder_.add_model_type(model_type);
  return builder_.Finish();
}

::flatbuffers::Offset<EquityVanillaModelSpec> CreateEquityVanillaModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ModelSpecT : public ::flatbuffers::NativeTable {
  typedef ModelSpec TableType;
  std::string id{};
  quantra::ModelPayloadUnion payload{};
};

/// Model specification - references by id in trade requests
struct ModelSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelSpecT NativeTableType;
  typedef ModelSpecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::ModelPayload payload_type() const {
    return static_cast<quantra::ModelPayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const quantra::CapFloorModelSpec *payload_as_CapFloorModelSpec() const {
    return payload_type() == quantra::ModelPayload_CapFloorModelSpec ? static_cast<const quantra::CapFloorModelSpec *>(payload()) : nullptr;
  }
  const quantra::SwaptionModelSpec *payload_as_SwaptionModelSpec() const {
    return payload_type() == quantra::ModelPayload_SwaptionModelSpec ? static_cast<const quantra::SwaptionModelSpec *>(payload()) : nullptr;
  }
  const quantra::CdsModelSpec *payload_as_CdsModelSpec() const {
    return payload_type() == quantra::ModelPayload_CdsModelSpec ? static_cast<const quantra::CdsModelSpec *>(payload()) : nullptr;
  }
  const quantra::EquityVanillaModelSpec *payload_as_EquityVanillaModelSpec() const {
    return payload_type() == quantra::ModelPayload_EquityVanillaModelSpec ? static_cast<const quantra::EquityVanillaModelSpec *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyModelPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
  ModelSpecT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ModelSpec> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const quantra::CapFloorModelSpec *ModelSpec::payload_as<quantra::CapFloorModelSpec>() const {
  return payload_as_CapFloorModelSpec();
}

template<> inline const quantra::SwaptionModelSpec *ModelSpec::payload_as<quantra::SwaptionModelSpec>() const {
  return payload_as_SwaptionModelSpec();
}

template<> inline const quantra::CdsModelSpec *ModelSpec::payload_as<quantra::CdsModelSpec>() const {
  return payload_as_CdsModelSpec();
}

template<> inline const quantra::EquityVanillaModelSpec *ModelSpec::payload_as<quantra::EquityVanillaModelSpec>() const {
  return payload_as_EquityVanillaModelSpec();
}

struct ModelSpecBuilder {
  typedef ModelSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ModelSpec::VT_ID, id);
  }
  void add_payload_type(quantra::ModelPayload payload_type) {
    fbb_.AddElement<uint8_t>(ModelSpec::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(ModelSpec::VT_PAYLOAD, payload);
  }
  explicit ModelSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelSpec>(end);
    fbb_.Required(o, ModelSpec::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelSpec> CreateModelSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::ModelPayload payload_type = quantra::ModelPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  ModelSpecBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_id(id);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelSpec> CreateModelSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::ModelPayload payload_type = quantra::ModelPayload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return quantra::CreateModelSpec(
      _fbb,
      id__,
      payload_type,
      payload);
}

::flatbuffers::Offset<ModelSpec> CreateModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CapFloorModelSpecT *CapFloorModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CapFloorModelSpecT>(new CapFloorModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CapFloorModelSpec::UnPackTo(CapFloorModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model_type(); _o->model_type = _e; }
}

inline ::flatbuffers::Offset<CapFloorModelSpec> CapFloorModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCapFloorModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CapFloorModelSpec> CreateCapFloorModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CapFloorModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CapFloorModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model_type = _o->model_type;
  return quantra::CreateCapFloorModelSpec(
      _fbb,
      _model_type);
}

inline SwaptionModelSpecT *SwaptionModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwaptionModelSpecT>(new SwaptionModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwaptionModelSpec::UnPackTo(SwaptionModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model_type(); _o->model_type = _e; }
}

inline ::flatbuffers::Offset<SwaptionModelSpec> SwaptionModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwaptionModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwaptionModelSpec> CreateSwaptionModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const SwaptionModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwaptionModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model_type = _o->model_type;
  return quantra::CreateSwaptionModelSpec(
      _fbb,
      _model_type);
}

inline CdsModelSpecT *CdsModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CdsModelSpecT>(new CdsModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CdsModelSpec::UnPackTo(CdsModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = engine_type(); _o->engine_type = _e; }
  { auto _e = include_settlement_date_flows(); _o->include_settlement_date_flows = _e; }
  { auto _e = isda_numerical_fix(); _o->isda_numerical_fix = _e; }
  { auto _e = isda_accrual_bias(); _o->isda_accrual_bias = _e; }
  { auto _e = isda_forwards_in_coupon_period(); _o->isda_forwards_in_coupon_period = _e; }
}

inline ::flatbuffers::Offset<CdsModelSpec> CdsModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CdsModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCdsModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CdsModelSpec> CreateCdsModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const CdsModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CdsModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _engine_type = _o->engine_type;
  auto _include_settlement_date_flows = _o->include_settlement_date_flows;
  auto _isda_numerical_fix = _o->isda_numerical_fix;
  auto _isda_accrual_bias = _o->isda_accrual_bias;
  auto _isda_forwards_in_coupon_period = _o->isda_forwards_in_coupon_period;
  return quantra::CreateCdsModelSpec(
      _fbb,
      _engine_type,
      _include_settlement_date_flows,
      _isda_numerical_fix,
      _isda_accrual_bias,
      _isda_forwards_in_coupon_period);
}

inline EquityVanillaModelSpecT *EquityVanillaModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EquityVanillaModelSpecT>(new EquityVanillaModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EquityVanillaModelSpec::UnPackTo(EquityVanillaModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = model_type(); _o->model_type = _e; }
  { auto _e = binomial_steps(); _o->binomial_steps = _e; }
}

inline ::flatbuffers::Offset<EquityVanillaModelSpec> EquityVanillaModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEquityVanillaModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EquityVanillaModelSpec> CreateEquityVanillaModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const EquityVanillaModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EquityVanillaModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _model_type = _o->model_type;
  auto _binomial_steps = _o->binomial_steps;
  return quantra::CreateEquityVanillaModelSpec(
      _fbb,
      _model_type,
      _binomial_steps);
}

inline ModelSpecT *ModelSpec::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ModelSpecT>(new ModelSpecT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ModelSpec::UnPackTo(ModelSpecT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = payload_type(); _o->payload.type = _e; }
  { auto _e = payload(); if (_e) _o->payload.value = quantra::ModelPayloadUnion::UnPack(_e, payload_type(), _resolver); }
}

inline ::flatbuffers::Offset<ModelSpec> ModelSpec::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateModelSpec(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ModelSpec> CreateModelSpec(::flatbuffers::FlatBufferBuilder &_fbb, const ModelSpecT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ModelSpecT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _payload_type = _o->payload.type;
  auto _payload = _o->payload.Pack(_fbb);
  return quantra::CreateModelSpec(
      _fbb,
      _id,
      _payload_type,
      _payload);
}

inline bool VerifyModelPayload(::flatbuffers::Verifier &verifier, const void *obj, ModelPayload type) {
  switch (type) {
    case ModelPayload_NONE: {
      return true;
    }
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CapFloorModelSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionModelSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ModelPayload_CdsModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CdsModelSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<const quantra::EquityVanillaModelSpec *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyModelPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyModelPayload(
        verifier,  values->Get(i), types->GetEnum<ModelPayload>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ModelPayloadUnion::UnPack(const void *obj, ModelPayload type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CapFloorModelSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionModelSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case ModelPayload_CdsModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CdsModelSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<const quantra::EquityVanillaModelSpec *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ModelPayloadUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CapFloorModelSpecT *>(value);
      return CreateCapFloorModelSpec(_fbb, ptr, _rehasher).Union();
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<const quantra::SwaptionModelSpecT *>(value);
      return CreateSwaptionModelSpec(_fbb, ptr, _rehasher).Union();
    }
    case ModelPayload_CdsModelSpec: {
      auto ptr = reinterpret_cast<const quantra::CdsModelSpecT *>(value);
      return CreateCdsModelSpec(_fbb, ptr, _rehasher).Union();
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<const quantra::EquityVanillaModelSpecT *>(value);
      return CreateEquityVanillaModelSpec(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ModelPayloadUnion::ModelPayloadUnion(const ModelPayloadUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      value = new quantra::CapFloorModelSpecT(*reinterpret_cast<quantra::CapFloorModelSpecT *>(u.value));
      break;
    }
    case ModelPayload_SwaptionModelSpec: {
      value = new quantra::SwaptionModelSpecT(*reinterpret_cast<quantra::SwaptionModelSpecT *>(u.value));
      break;
    }
    case ModelPayload_CdsModelSpec: {
      value = new quantra::CdsModelSpecT(*reinterpret_cast<quantra::CdsModelSpecT *>(u.value));
      break;
    }
    case ModelPayload_EquityVanillaModelSpec: {
      value = new quantra::EquityVanillaModelSpecT(*reinterpret_cast<quantra::EquityVanillaModelSpecT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ModelPayloadUnion::Reset() {
  switch (type) {
    case ModelPayload_CapFloorModelSpec: {
      auto ptr = reinterpret_cast<quantra::CapFloorModelSpecT *>(value);
      delete ptr;
      break;
    }
    case ModelPayload_SwaptionModelSpec: {
      auto ptr = reinterpret_cast<quantra::SwaptionModelSpecT *>(value);
      delete ptr;
      break;
    }
    case ModelPayload_CdsModelSpec: {
      auto ptr = reinterpret_cast<quantra::CdsModelSpecT *>(value);
      delete ptr;
      break;
    }
    case ModelPayload_EquityVanillaModelSpec: {
      auto ptr = reinterpret_cast<quantra::EquityVanillaModelSpecT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ModelPayload_NONE;
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_MODEL_QUANTRA_H_
