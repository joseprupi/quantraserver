// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace quantra {

struct SwapLegFlow;
struct SwapLegFlowBuilder;

struct SwapLegResponse;
struct SwapLegResponseBuilder;

struct VanillaSwapResponse;
struct VanillaSwapResponseBuilder;

struct PriceVanillaSwapResponse;
struct PriceVanillaSwapResponseBuilder;

struct SwapLegFlow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapLegFlowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYMENT_DATE = 4,
    VT_ACCRUAL_START_DATE = 6,
    VT_ACCRUAL_END_DATE = 8,
    VT_AMOUNT = 10,
    VT_DISCOUNT = 12,
    VT_PRESENT_VALUE = 14,
    VT_FIXING_DATE = 16,
    VT_INDEX_FIXING = 18,
    VT_SPREAD = 20,
    VT_RATE = 22
  };
  const ::flatbuffers::String *payment_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  double discount() const {
    return GetField<double>(VT_DISCOUNT, 0.0);
  }
  double present_value() const {
    return GetField<double>(VT_PRESENT_VALUE, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  double index_fixing() const {
    return GetField<double>(VT_INDEX_FIXING, 0.0);
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYMENT_DATE) &&
           verifier.VerifyString(payment_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyField<double>(verifier, VT_DISCOUNT, 8) &&
           VerifyField<double>(verifier, VT_PRESENT_VALUE, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyField<double>(verifier, VT_INDEX_FIXING, 8) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           verifier.EndTable();
  }
};

struct SwapLegFlowBuilder {
  typedef SwapLegFlow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payment_date(::flatbuffers::Offset<::flatbuffers::String> payment_date) {
    fbb_.AddOffset(SwapLegFlow::VT_PAYMENT_DATE, payment_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(SwapLegFlow::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(SwapLegFlow::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(SwapLegFlow::VT_AMOUNT, amount, 0.0);
  }
  void add_discount(double discount) {
    fbb_.AddElement<double>(SwapLegFlow::VT_DISCOUNT, discount, 0.0);
  }
  void add_present_value(double present_value) {
    fbb_.AddElement<double>(SwapLegFlow::VT_PRESENT_VALUE, present_value, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(SwapLegFlow::VT_FIXING_DATE, fixing_date);
  }
  void add_index_fixing(double index_fixing) {
    fbb_.AddElement<double>(SwapLegFlow::VT_INDEX_FIXING, index_fixing, 0.0);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(SwapLegFlow::VT_SPREAD, spread, 0.0);
  }
  void add_rate(double rate) {
    fbb_.AddElement<double>(SwapLegFlow::VT_RATE, rate, 0.0);
  }
  explicit SwapLegFlowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapLegFlow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapLegFlow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> payment_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    double amount = 0.0,
    double discount = 0.0,
    double present_value = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    double index_fixing = 0.0,
    double spread = 0.0,
    double rate = 0.0) {
  SwapLegFlowBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_spread(spread);
  builder_.add_index_fixing(index_fixing);
  builder_.add_present_value(present_value);
  builder_.add_discount(discount);
  builder_.add_amount(amount);
  builder_.add_fixing_date(fixing_date);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_payment_date(payment_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *payment_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    double amount = 0.0,
    double discount = 0.0,
    double present_value = 0.0,
    const char *fixing_date = nullptr,
    double index_fixing = 0.0,
    double spread = 0.0,
    double rate = 0.0) {
  auto payment_date__ = payment_date ? _fbb.CreateString(payment_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  return quantra::CreateSwapLegFlow(
      _fbb,
      payment_date__,
      accrual_start_date__,
      accrual_end_date__,
      amount,
      discount,
      present_value,
      fixing_date__,
      index_fixing,
      spread,
      rate);
}

struct SwapLegResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapLegResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_BPS = 6,
    VT_FLOWS = 8
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double bps() const {
    return GetField<double>(VT_BPS, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FLOWS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_BPS, 8) &&
           VerifyOffset(verifier, VT_FLOWS) &&
           verifier.VerifyVector(flows()) &&
           verifier.VerifyVectorOfTables(flows()) &&
           verifier.EndTable();
  }
};

struct SwapLegResponseBuilder {
  typedef SwapLegResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(SwapLegResponse::VT_NPV, npv, 0.0);
  }
  void add_bps(double bps) {
    fbb_.AddElement<double>(SwapLegResponse::VT_BPS, bps, 0.0);
  }
  void add_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> flows) {
    fbb_.AddOffset(SwapLegResponse::VT_FLOWS, flows);
  }
  explicit SwapLegResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapLegResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapLegResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double bps = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> flows = 0) {
  SwapLegResponseBuilder builder_(_fbb);
  builder_.add_bps(bps);
  builder_.add_npv(npv);
  builder_.add_flows(flows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double bps = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *flows = nullptr) {
  auto flows__ = flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*flows) : 0;
  return quantra::CreateSwapLegResponse(
      _fbb,
      npv,
      bps,
      flows__);
}

struct VanillaSwapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VanillaSwapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_FAIR_RATE = 6,
    VT_FAIR_SPREAD = 8,
    VT_FIXED_LEG_BPS = 10,
    VT_FLOATING_LEG_BPS = 12,
    VT_FIXED_LEG_NPV = 14,
    VT_FLOATING_LEG_NPV = 16,
    VT_FIXED_LEG_FLOWS = 18,
    VT_FLOATING_LEG_FLOWS = 20
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double fair_rate() const {
    return GetField<double>(VT_FAIR_RATE, 0.0);
  }
  double fair_spread() const {
    return GetField<double>(VT_FAIR_SPREAD, 0.0);
  }
  double fixed_leg_bps() const {
    return GetField<double>(VT_FIXED_LEG_BPS, 0.0);
  }
  double floating_leg_bps() const {
    return GetField<double>(VT_FLOATING_LEG_BPS, 0.0);
  }
  double fixed_leg_npv() const {
    return GetField<double>(VT_FIXED_LEG_NPV, 0.0);
  }
  double floating_leg_npv() const {
    return GetField<double>(VT_FLOATING_LEG_NPV, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *fixed_leg_flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FIXED_LEG_FLOWS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *floating_leg_flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FLOATING_LEG_FLOWS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_FAIR_RATE, 8) &&
           VerifyField<double>(verifier, VT_FAIR_SPREAD, 8) &&
           VerifyField<double>(verifier, VT_FIXED_LEG_BPS, 8) &&
           VerifyField<double>(verifier, VT_FLOATING_LEG_BPS, 8) &&
           VerifyField<double>(verifier, VT_FIXED_LEG_NPV, 8) &&
           VerifyField<double>(verifier, VT_FLOATING_LEG_NPV, 8) &&
           VerifyOffset(verifier, VT_FIXED_LEG_FLOWS) &&
           verifier.VerifyVector(fixed_leg_flows()) &&
           verifier.VerifyVectorOfTables(fixed_leg_flows()) &&
           VerifyOffset(verifier, VT_FLOATING_LEG_FLOWS) &&
           verifier.VerifyVector(floating_leg_flows()) &&
           verifier.VerifyVectorOfTables(floating_leg_flows()) &&
           verifier.EndTable();
  }
};

struct VanillaSwapResponseBuilder {
  typedef VanillaSwapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_NPV, npv, 0.0);
  }
  void add_fair_rate(double fair_rate) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FAIR_RATE, fair_rate, 0.0);
  }
  void add_fair_spread(double fair_spread) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FAIR_SPREAD, fair_spread, 0.0);
  }
  void add_fixed_leg_bps(double fixed_leg_bps) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FIXED_LEG_BPS, fixed_leg_bps, 0.0);
  }
  void add_floating_leg_bps(double floating_leg_bps) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FLOATING_LEG_BPS, floating_leg_bps, 0.0);
  }
  void add_fixed_leg_npv(double fixed_leg_npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FIXED_LEG_NPV, fixed_leg_npv, 0.0);
  }
  void add_floating_leg_npv(double floating_leg_npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FLOATING_LEG_NPV, floating_leg_npv, 0.0);
  }
  void add_fixed_leg_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> fixed_leg_flows) {
    fbb_.AddOffset(VanillaSwapResponse::VT_FIXED_LEG_FLOWS, fixed_leg_flows);
  }
  void add_floating_leg_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> floating_leg_flows) {
    fbb_.AddOffset(VanillaSwapResponse::VT_FLOATING_LEG_FLOWS, floating_leg_flows);
  }
  explicit VanillaSwapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VanillaSwapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VanillaSwapResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double fair_rate = 0.0,
    double fair_spread = 0.0,
    double fixed_leg_bps = 0.0,
    double floating_leg_bps = 0.0,
    double fixed_leg_npv = 0.0,
    double floating_leg_npv = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> fixed_leg_flows = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> floating_leg_flows = 0) {
  VanillaSwapResponseBuilder builder_(_fbb);
  builder_.add_floating_leg_npv(floating_leg_npv);
  builder_.add_fixed_leg_npv(fixed_leg_npv);
  builder_.add_floating_leg_bps(floating_leg_bps);
  builder_.add_fixed_leg_bps(fixed_leg_bps);
  builder_.add_fair_spread(fair_spread);
  builder_.add_fair_rate(fair_rate);
  builder_.add_npv(npv);
  builder_.add_floating_leg_flows(floating_leg_flows);
  builder_.add_fixed_leg_flows(fixed_leg_flows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double fair_rate = 0.0,
    double fair_spread = 0.0,
    double fixed_leg_bps = 0.0,
    double floating_leg_bps = 0.0,
    double fixed_leg_npv = 0.0,
    double floating_leg_npv = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *fixed_leg_flows = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *floating_leg_flows = nullptr) {
  auto fixed_leg_flows__ = fixed_leg_flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*fixed_leg_flows) : 0;
  auto floating_leg_flows__ = floating_leg_flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*floating_leg_flows) : 0;
  return quantra::CreateVanillaSwapResponse(
      _fbb,
      npv,
      fair_rate,
      fair_spread,
      fixed_leg_bps,
      floating_leg_bps,
      fixed_leg_npv,
      floating_leg_npv,
      fixed_leg_flows__,
      floating_leg_flows__);
}

struct PriceVanillaSwapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriceVanillaSwapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SWAPS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *swaps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *>(VT_SWAPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SWAPS) &&
           verifier.VerifyVector(swaps()) &&
           verifier.VerifyVectorOfTables(swaps()) &&
           verifier.EndTable();
  }
};

struct PriceVanillaSwapResponseBuilder {
  typedef PriceVanillaSwapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_swaps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>> swaps) {
    fbb_.AddOffset(PriceVanillaSwapResponse::VT_SWAPS, swaps);
  }
  explicit PriceVanillaSwapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriceVanillaSwapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriceVanillaSwapResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>> swaps = 0) {
  PriceVanillaSwapResponseBuilder builder_(_fbb);
  builder_.add_swaps(swaps);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *swaps = nullptr) {
  auto swaps__ = swaps ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>(*swaps) : 0;
  return quantra::CreatePriceVanillaSwapResponse(
      _fbb,
      swaps__);
}

inline const quantra::PriceVanillaSwapResponse *GetPriceVanillaSwapResponse(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::PriceVanillaSwapResponse>(buf);
}

inline const quantra::PriceVanillaSwapResponse *GetSizePrefixedPriceVanillaSwapResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::PriceVanillaSwapResponse>(buf);
}

inline bool VerifyPriceVanillaSwapResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::PriceVanillaSwapResponse>(nullptr);
}

inline bool VerifySizePrefixedPriceVanillaSwapResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::PriceVanillaSwapResponse>(nullptr);
}

inline void FinishPriceVanillaSwapResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceVanillaSwapResponse> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPriceVanillaSwapResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceVanillaSwapResponse> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_
