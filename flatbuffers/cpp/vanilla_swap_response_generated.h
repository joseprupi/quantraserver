// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace quantra {

struct SwapLegFlow;
struct SwapLegFlowBuilder;
struct SwapLegFlowT;

struct SwapLegResponse;
struct SwapLegResponseBuilder;
struct SwapLegResponseT;

struct VanillaSwapResponse;
struct VanillaSwapResponseBuilder;
struct VanillaSwapResponseT;

struct PriceVanillaSwapResponse;
struct PriceVanillaSwapResponseBuilder;
struct PriceVanillaSwapResponseT;

struct SwapLegFlowT : public ::flatbuffers::NativeTable {
  typedef SwapLegFlow TableType;
  std::string payment_date{};
  std::string accrual_start_date{};
  std::string accrual_end_date{};
  double amount = 0.0;
  double discount = 0.0;
  double present_value = 0.0;
  std::string fixing_date{};
  double index_fixing = 0.0;
  double spread = 0.0;
  double rate = 0.0;
};

struct SwapLegFlow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapLegFlowT NativeTableType;
  typedef SwapLegFlowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYMENT_DATE = 4,
    VT_ACCRUAL_START_DATE = 6,
    VT_ACCRUAL_END_DATE = 8,
    VT_AMOUNT = 10,
    VT_DISCOUNT = 12,
    VT_PRESENT_VALUE = 14,
    VT_FIXING_DATE = 16,
    VT_INDEX_FIXING = 18,
    VT_SPREAD = 20,
    VT_RATE = 22
  };
  const ::flatbuffers::String *payment_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  double discount() const {
    return GetField<double>(VT_DISCOUNT, 0.0);
  }
  double present_value() const {
    return GetField<double>(VT_PRESENT_VALUE, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  double index_fixing() const {
    return GetField<double>(VT_INDEX_FIXING, 0.0);
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYMENT_DATE) &&
           verifier.VerifyString(payment_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyField<double>(verifier, VT_DISCOUNT, 8) &&
           VerifyField<double>(verifier, VT_PRESENT_VALUE, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyField<double>(verifier, VT_INDEX_FIXING, 8) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           verifier.EndTable();
  }
  SwapLegFlowT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapLegFlowT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapLegFlow> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegFlowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapLegFlowBuilder {
  typedef SwapLegFlow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payment_date(::flatbuffers::Offset<::flatbuffers::String> payment_date) {
    fbb_.AddOffset(SwapLegFlow::VT_PAYMENT_DATE, payment_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(SwapLegFlow::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(SwapLegFlow::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(SwapLegFlow::VT_AMOUNT, amount, 0.0);
  }
  void add_discount(double discount) {
    fbb_.AddElement<double>(SwapLegFlow::VT_DISCOUNT, discount, 0.0);
  }
  void add_present_value(double present_value) {
    fbb_.AddElement<double>(SwapLegFlow::VT_PRESENT_VALUE, present_value, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(SwapLegFlow::VT_FIXING_DATE, fixing_date);
  }
  void add_index_fixing(double index_fixing) {
    fbb_.AddElement<double>(SwapLegFlow::VT_INDEX_FIXING, index_fixing, 0.0);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(SwapLegFlow::VT_SPREAD, spread, 0.0);
  }
  void add_rate(double rate) {
    fbb_.AddElement<double>(SwapLegFlow::VT_RATE, rate, 0.0);
  }
  explicit SwapLegFlowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapLegFlow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapLegFlow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> payment_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    double amount = 0.0,
    double discount = 0.0,
    double present_value = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    double index_fixing = 0.0,
    double spread = 0.0,
    double rate = 0.0) {
  SwapLegFlowBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_spread(spread);
  builder_.add_index_fixing(index_fixing);
  builder_.add_present_value(present_value);
  builder_.add_discount(discount);
  builder_.add_amount(amount);
  builder_.add_fixing_date(fixing_date);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_payment_date(payment_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *payment_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    double amount = 0.0,
    double discount = 0.0,
    double present_value = 0.0,
    const char *fixing_date = nullptr,
    double index_fixing = 0.0,
    double spread = 0.0,
    double rate = 0.0) {
  auto payment_date__ = payment_date ? _fbb.CreateString(payment_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  return quantra::CreateSwapLegFlow(
      _fbb,
      payment_date__,
      accrual_start_date__,
      accrual_end_date__,
      amount,
      discount,
      present_value,
      fixing_date__,
      index_fixing,
      spread,
      rate);
}

::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlow(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegFlowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SwapLegResponseT : public ::flatbuffers::NativeTable {
  typedef SwapLegResponse TableType;
  double npv = 0.0;
  double bps = 0.0;
  std::vector<std::unique_ptr<quantra::SwapLegFlowT>> flows{};
  SwapLegResponseT() = default;
  SwapLegResponseT(const SwapLegResponseT &o);
  SwapLegResponseT(SwapLegResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  SwapLegResponseT &operator=(SwapLegResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct SwapLegResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapLegResponseT NativeTableType;
  typedef SwapLegResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_BPS = 6,
    VT_FLOWS = 8
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double bps() const {
    return GetField<double>(VT_BPS, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FLOWS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_BPS, 8) &&
           VerifyOffset(verifier, VT_FLOWS) &&
           verifier.VerifyVector(flows()) &&
           verifier.VerifyVectorOfTables(flows()) &&
           verifier.EndTable();
  }
  SwapLegResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SwapLegResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SwapLegResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SwapLegResponseBuilder {
  typedef SwapLegResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(SwapLegResponse::VT_NPV, npv, 0.0);
  }
  void add_bps(double bps) {
    fbb_.AddElement<double>(SwapLegResponse::VT_BPS, bps, 0.0);
  }
  void add_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> flows) {
    fbb_.AddOffset(SwapLegResponse::VT_FLOWS, flows);
  }
  explicit SwapLegResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapLegResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapLegResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double bps = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> flows = 0) {
  SwapLegResponseBuilder builder_(_fbb);
  builder_.add_bps(bps);
  builder_.add_npv(npv);
  builder_.add_flows(flows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double bps = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *flows = nullptr) {
  auto flows__ = flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*flows) : 0;
  return quantra::CreateSwapLegResponse(
      _fbb,
      npv,
      bps,
      flows__);
}

::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct VanillaSwapResponseT : public ::flatbuffers::NativeTable {
  typedef VanillaSwapResponse TableType;
  double npv = 0.0;
  double fair_rate = 0.0;
  double fair_spread = 0.0;
  double fixed_leg_bps = 0.0;
  double floating_leg_bps = 0.0;
  double fixed_leg_npv = 0.0;
  double floating_leg_npv = 0.0;
  std::vector<std::unique_ptr<quantra::SwapLegFlowT>> fixed_leg_flows{};
  std::vector<std::unique_ptr<quantra::SwapLegFlowT>> floating_leg_flows{};
  VanillaSwapResponseT() = default;
  VanillaSwapResponseT(const VanillaSwapResponseT &o);
  VanillaSwapResponseT(VanillaSwapResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  VanillaSwapResponseT &operator=(VanillaSwapResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct VanillaSwapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VanillaSwapResponseT NativeTableType;
  typedef VanillaSwapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_FAIR_RATE = 6,
    VT_FAIR_SPREAD = 8,
    VT_FIXED_LEG_BPS = 10,
    VT_FLOATING_LEG_BPS = 12,
    VT_FIXED_LEG_NPV = 14,
    VT_FLOATING_LEG_NPV = 16,
    VT_FIXED_LEG_FLOWS = 18,
    VT_FLOATING_LEG_FLOWS = 20
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double fair_rate() const {
    return GetField<double>(VT_FAIR_RATE, 0.0);
  }
  double fair_spread() const {
    return GetField<double>(VT_FAIR_SPREAD, 0.0);
  }
  double fixed_leg_bps() const {
    return GetField<double>(VT_FIXED_LEG_BPS, 0.0);
  }
  double floating_leg_bps() const {
    return GetField<double>(VT_FLOATING_LEG_BPS, 0.0);
  }
  double fixed_leg_npv() const {
    return GetField<double>(VT_FIXED_LEG_NPV, 0.0);
  }
  double floating_leg_npv() const {
    return GetField<double>(VT_FLOATING_LEG_NPV, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *fixed_leg_flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FIXED_LEG_FLOWS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *floating_leg_flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FLOATING_LEG_FLOWS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_FAIR_RATE, 8) &&
           VerifyField<double>(verifier, VT_FAIR_SPREAD, 8) &&
           VerifyField<double>(verifier, VT_FIXED_LEG_BPS, 8) &&
           VerifyField<double>(verifier, VT_FLOATING_LEG_BPS, 8) &&
           VerifyField<double>(verifier, VT_FIXED_LEG_NPV, 8) &&
           VerifyField<double>(verifier, VT_FLOATING_LEG_NPV, 8) &&
           VerifyOffset(verifier, VT_FIXED_LEG_FLOWS) &&
           verifier.VerifyVector(fixed_leg_flows()) &&
           verifier.VerifyVectorOfTables(fixed_leg_flows()) &&
           VerifyOffset(verifier, VT_FLOATING_LEG_FLOWS) &&
           verifier.VerifyVector(floating_leg_flows()) &&
           verifier.VerifyVectorOfTables(floating_leg_flows()) &&
           verifier.EndTable();
  }
  VanillaSwapResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VanillaSwapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VanillaSwapResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VanillaSwapResponseBuilder {
  typedef VanillaSwapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_NPV, npv, 0.0);
  }
  void add_fair_rate(double fair_rate) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FAIR_RATE, fair_rate, 0.0);
  }
  void add_fair_spread(double fair_spread) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FAIR_SPREAD, fair_spread, 0.0);
  }
  void add_fixed_leg_bps(double fixed_leg_bps) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FIXED_LEG_BPS, fixed_leg_bps, 0.0);
  }
  void add_floating_leg_bps(double floating_leg_bps) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FLOATING_LEG_BPS, floating_leg_bps, 0.0);
  }
  void add_fixed_leg_npv(double fixed_leg_npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FIXED_LEG_NPV, fixed_leg_npv, 0.0);
  }
  void add_floating_leg_npv(double floating_leg_npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FLOATING_LEG_NPV, floating_leg_npv, 0.0);
  }
  void add_fixed_leg_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> fixed_leg_flows) {
    fbb_.AddOffset(VanillaSwapResponse::VT_FIXED_LEG_FLOWS, fixed_leg_flows);
  }
  void add_floating_leg_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> floating_leg_flows) {
    fbb_.AddOffset(VanillaSwapResponse::VT_FLOATING_LEG_FLOWS, floating_leg_flows);
  }
  explicit VanillaSwapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VanillaSwapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VanillaSwapResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double fair_rate = 0.0,
    double fair_spread = 0.0,
    double fixed_leg_bps = 0.0,
    double floating_leg_bps = 0.0,
    double fixed_leg_npv = 0.0,
    double floating_leg_npv = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> fixed_leg_flows = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> floating_leg_flows = 0) {
  VanillaSwapResponseBuilder builder_(_fbb);
  builder_.add_floating_leg_npv(floating_leg_npv);
  builder_.add_fixed_leg_npv(fixed_leg_npv);
  builder_.add_floating_leg_bps(floating_leg_bps);
  builder_.add_fixed_leg_bps(fixed_leg_bps);
  builder_.add_fair_spread(fair_spread);
  builder_.add_fair_rate(fair_rate);
  builder_.add_npv(npv);
  builder_.add_floating_leg_flows(floating_leg_flows);
  builder_.add_fixed_leg_flows(fixed_leg_flows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double fair_rate = 0.0,
    double fair_spread = 0.0,
    double fixed_leg_bps = 0.0,
    double floating_leg_bps = 0.0,
    double fixed_leg_npv = 0.0,
    double floating_leg_npv = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *fixed_leg_flows = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *floating_leg_flows = nullptr) {
  auto fixed_leg_flows__ = fixed_leg_flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*fixed_leg_flows) : 0;
  auto floating_leg_flows__ = floating_leg_flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*floating_leg_flows) : 0;
  return quantra::CreateVanillaSwapResponse(
      _fbb,
      npv,
      fair_rate,
      fair_spread,
      fixed_leg_bps,
      floating_leg_bps,
      fixed_leg_npv,
      floating_leg_npv,
      fixed_leg_flows__,
      floating_leg_flows__);
}

::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PriceVanillaSwapResponseT : public ::flatbuffers::NativeTable {
  typedef PriceVanillaSwapResponse TableType;
  std::vector<std::unique_ptr<quantra::VanillaSwapResponseT>> swaps{};
  PriceVanillaSwapResponseT() = default;
  PriceVanillaSwapResponseT(const PriceVanillaSwapResponseT &o);
  PriceVanillaSwapResponseT(PriceVanillaSwapResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  PriceVanillaSwapResponseT &operator=(PriceVanillaSwapResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct PriceVanillaSwapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriceVanillaSwapResponseT NativeTableType;
  typedef PriceVanillaSwapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SWAPS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *swaps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *>(VT_SWAPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SWAPS) &&
           verifier.VerifyVector(swaps()) &&
           verifier.VerifyVectorOfTables(swaps()) &&
           verifier.EndTable();
  }
  PriceVanillaSwapResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PriceVanillaSwapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PriceVanillaSwapResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PriceVanillaSwapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PriceVanillaSwapResponseBuilder {
  typedef PriceVanillaSwapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_swaps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>> swaps) {
    fbb_.AddOffset(PriceVanillaSwapResponse::VT_SWAPS, swaps);
  }
  explicit PriceVanillaSwapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriceVanillaSwapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriceVanillaSwapResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>> swaps = 0) {
  PriceVanillaSwapResponseBuilder builder_(_fbb);
  builder_.add_swaps(swaps);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *swaps = nullptr) {
  auto swaps__ = swaps ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>(*swaps) : 0;
  return quantra::CreatePriceVanillaSwapResponse(
      _fbb,
      swaps__);
}

::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const PriceVanillaSwapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SwapLegFlowT *SwapLegFlow::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapLegFlowT>(new SwapLegFlowT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapLegFlow::UnPackTo(SwapLegFlowT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = payment_date(); if (_e) _o->payment_date = _e->str(); }
  { auto _e = accrual_start_date(); if (_e) _o->accrual_start_date = _e->str(); }
  { auto _e = accrual_end_date(); if (_e) _o->accrual_end_date = _e->str(); }
  { auto _e = amount(); _o->amount = _e; }
  { auto _e = discount(); _o->discount = _e; }
  { auto _e = present_value(); _o->present_value = _e; }
  { auto _e = fixing_date(); if (_e) _o->fixing_date = _e->str(); }
  { auto _e = index_fixing(); _o->index_fixing = _e; }
  { auto _e = spread(); _o->spread = _e; }
  { auto _e = rate(); _o->rate = _e; }
}

inline ::flatbuffers::Offset<SwapLegFlow> SwapLegFlow::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegFlowT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapLegFlow(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlow(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegFlowT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapLegFlowT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _payment_date = _o->payment_date.empty() ? 0 : _fbb.CreateString(_o->payment_date);
  auto _accrual_start_date = _o->accrual_start_date.empty() ? 0 : _fbb.CreateString(_o->accrual_start_date);
  auto _accrual_end_date = _o->accrual_end_date.empty() ? 0 : _fbb.CreateString(_o->accrual_end_date);
  auto _amount = _o->amount;
  auto _discount = _o->discount;
  auto _present_value = _o->present_value;
  auto _fixing_date = _o->fixing_date.empty() ? 0 : _fbb.CreateString(_o->fixing_date);
  auto _index_fixing = _o->index_fixing;
  auto _spread = _o->spread;
  auto _rate = _o->rate;
  return quantra::CreateSwapLegFlow(
      _fbb,
      _payment_date,
      _accrual_start_date,
      _accrual_end_date,
      _amount,
      _discount,
      _present_value,
      _fixing_date,
      _index_fixing,
      _spread,
      _rate);
}

inline SwapLegResponseT::SwapLegResponseT(const SwapLegResponseT &o)
      : npv(o.npv),
        bps(o.bps) {
  flows.reserve(o.flows.size());
  for (const auto &flows_ : o.flows) { flows.emplace_back((flows_) ? new quantra::SwapLegFlowT(*flows_) : nullptr); }
}

inline SwapLegResponseT &SwapLegResponseT::operator=(SwapLegResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(npv, o.npv);
  std::swap(bps, o.bps);
  std::swap(flows, o.flows);
  return *this;
}

inline SwapLegResponseT *SwapLegResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SwapLegResponseT>(new SwapLegResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SwapLegResponse::UnPackTo(SwapLegResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = npv(); _o->npv = _e; }
  { auto _e = bps(); _o->bps = _e; }
  { auto _e = flows(); if (_e) { _o->flows.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->flows[_i]) { _e->Get(_i)->UnPackTo(_o->flows[_i].get(), _resolver); } else { _o->flows[_i] = std::unique_ptr<quantra::SwapLegFlowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->flows.resize(0); } }
}

inline ::flatbuffers::Offset<SwapLegResponse> SwapLegResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSwapLegResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponse(::flatbuffers::FlatBufferBuilder &_fbb, const SwapLegResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SwapLegResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _npv = _o->npv;
  auto _bps = _o->bps;
  auto _flows = _o->flows.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>> (_o->flows.size(), [](size_t i, _VectorArgs *__va) { return CreateSwapLegFlow(*__va->__fbb, __va->__o->flows[i].get(), __va->__rehasher); }, &_va ) : 0;
  return quantra::CreateSwapLegResponse(
      _fbb,
      _npv,
      _bps,
      _flows);
}

inline VanillaSwapResponseT::VanillaSwapResponseT(const VanillaSwapResponseT &o)
      : npv(o.npv),
        fair_rate(o.fair_rate),
        fair_spread(o.fair_spread),
        fixed_leg_bps(o.fixed_leg_bps),
        floating_leg_bps(o.floating_leg_bps),
        fixed_leg_npv(o.fixed_leg_npv),
        floating_leg_npv(o.floating_leg_npv) {
  fixed_leg_flows.reserve(o.fixed_leg_flows.size());
  for (const auto &fixed_leg_flows_ : o.fixed_leg_flows) { fixed_leg_flows.emplace_back((fixed_leg_flows_) ? new quantra::SwapLegFlowT(*fixed_leg_flows_) : nullptr); }
  floating_leg_flows.reserve(o.floating_leg_flows.size());
  for (const auto &floating_leg_flows_ : o.floating_leg_flows) { floating_leg_flows.emplace_back((floating_leg_flows_) ? new quantra::SwapLegFlowT(*floating_leg_flows_) : nullptr); }
}

inline VanillaSwapResponseT &VanillaSwapResponseT::operator=(VanillaSwapResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(npv, o.npv);
  std::swap(fair_rate, o.fair_rate);
  std::swap(fair_spread, o.fair_spread);
  std::swap(fixed_leg_bps, o.fixed_leg_bps);
  std::swap(floating_leg_bps, o.floating_leg_bps);
  std::swap(fixed_leg_npv, o.fixed_leg_npv);
  std::swap(floating_leg_npv, o.floating_leg_npv);
  std::swap(fixed_leg_flows, o.fixed_leg_flows);
  std::swap(floating_leg_flows, o.floating_leg_flows);
  return *this;
}

inline VanillaSwapResponseT *VanillaSwapResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<VanillaSwapResponseT>(new VanillaSwapResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VanillaSwapResponse::UnPackTo(VanillaSwapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = npv(); _o->npv = _e; }
  { auto _e = fair_rate(); _o->fair_rate = _e; }
  { auto _e = fair_spread(); _o->fair_spread = _e; }
  { auto _e = fixed_leg_bps(); _o->fixed_leg_bps = _e; }
  { auto _e = floating_leg_bps(); _o->floating_leg_bps = _e; }
  { auto _e = fixed_leg_npv(); _o->fixed_leg_npv = _e; }
  { auto _e = floating_leg_npv(); _o->floating_leg_npv = _e; }
  { auto _e = fixed_leg_flows(); if (_e) { _o->fixed_leg_flows.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->fixed_leg_flows[_i]) { _e->Get(_i)->UnPackTo(_o->fixed_leg_flows[_i].get(), _resolver); } else { _o->fixed_leg_flows[_i] = std::unique_ptr<quantra::SwapLegFlowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->fixed_leg_flows.resize(0); } }
  { auto _e = floating_leg_flows(); if (_e) { _o->floating_leg_flows.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->floating_leg_flows[_i]) { _e->Get(_i)->UnPackTo(_o->floating_leg_flows[_i].get(), _resolver); } else { _o->floating_leg_flows[_i] = std::unique_ptr<quantra::SwapLegFlowT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->floating_leg_flows.resize(0); } }
}

inline ::flatbuffers::Offset<VanillaSwapResponse> VanillaSwapResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVanillaSwapResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const VanillaSwapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VanillaSwapResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _npv = _o->npv;
  auto _fair_rate = _o->fair_rate;
  auto _fair_spread = _o->fair_spread;
  auto _fixed_leg_bps = _o->fixed_leg_bps;
  auto _floating_leg_bps = _o->floating_leg_bps;
  auto _fixed_leg_npv = _o->fixed_leg_npv;
  auto _floating_leg_npv = _o->floating_leg_npv;
  auto _fixed_leg_flows = _o->fixed_leg_flows.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>> (_o->fixed_leg_flows.size(), [](size_t i, _VectorArgs *__va) { return CreateSwapLegFlow(*__va->__fbb, __va->__o->fixed_leg_flows[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _floating_leg_flows = _o->floating_leg_flows.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>> (_o->floating_leg_flows.size(), [](size_t i, _VectorArgs *__va) { return CreateSwapLegFlow(*__va->__fbb, __va->__o->floating_leg_flows[i].get(), __va->__rehasher); }, &_va ) : 0;
  return quantra::CreateVanillaSwapResponse(
      _fbb,
      _npv,
      _fair_rate,
      _fair_spread,
      _fixed_leg_bps,
      _floating_leg_bps,
      _fixed_leg_npv,
      _floating_leg_npv,
      _fixed_leg_flows,
      _floating_leg_flows);
}

inline PriceVanillaSwapResponseT::PriceVanillaSwapResponseT(const PriceVanillaSwapResponseT &o) {
  swaps.reserve(o.swaps.size());
  for (const auto &swaps_ : o.swaps) { swaps.emplace_back((swaps_) ? new quantra::VanillaSwapResponseT(*swaps_) : nullptr); }
}

inline PriceVanillaSwapResponseT &PriceVanillaSwapResponseT::operator=(PriceVanillaSwapResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(swaps, o.swaps);
  return *this;
}

inline PriceVanillaSwapResponseT *PriceVanillaSwapResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PriceVanillaSwapResponseT>(new PriceVanillaSwapResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PriceVanillaSwapResponse::UnPackTo(PriceVanillaSwapResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = swaps(); if (_e) { _o->swaps.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->swaps[_i]) { _e->Get(_i)->UnPackTo(_o->swaps[_i].get(), _resolver); } else { _o->swaps[_i] = std::unique_ptr<quantra::VanillaSwapResponseT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->swaps.resize(0); } }
}

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> PriceVanillaSwapResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PriceVanillaSwapResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePriceVanillaSwapResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponse(::flatbuffers::FlatBufferBuilder &_fbb, const PriceVanillaSwapResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PriceVanillaSwapResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _swaps = _o->swaps.size() ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> (_o->swaps.size(), [](size_t i, _VectorArgs *__va) { return CreateVanillaSwapResponse(*__va->__fbb, __va->__o->swaps[i].get(), __va->__rehasher); }, &_va ) : 0;
  return quantra::CreatePriceVanillaSwapResponse(
      _fbb,
      _swaps);
}

inline const quantra::PriceVanillaSwapResponse *GetPriceVanillaSwapResponse(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::PriceVanillaSwapResponse>(buf);
}

inline const quantra::PriceVanillaSwapResponse *GetSizePrefixedPriceVanillaSwapResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::PriceVanillaSwapResponse>(buf);
}

inline bool VerifyPriceVanillaSwapResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::PriceVanillaSwapResponse>(nullptr);
}

inline bool VerifySizePrefixedPriceVanillaSwapResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::PriceVanillaSwapResponse>(nullptr);
}

inline void FinishPriceVanillaSwapResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceVanillaSwapResponse> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPriceVanillaSwapResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceVanillaSwapResponse> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<quantra::PriceVanillaSwapResponseT> UnPackPriceVanillaSwapResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::PriceVanillaSwapResponseT>(GetPriceVanillaSwapResponse(buf)->UnPack(res));
}

inline std::unique_ptr<quantra::PriceVanillaSwapResponseT> UnPackSizePrefixedPriceVanillaSwapResponse(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<quantra::PriceVanillaSwapResponseT>(GetSizePrefixedPriceVanillaSwapResponse(buf)->UnPack(res));
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_
