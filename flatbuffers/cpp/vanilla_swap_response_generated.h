// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_
#define FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace quantra {

struct Schedule;
struct ScheduleBuilder;

struct DepositHelper;
struct DepositHelperBuilder;

struct FRAHelper;
struct FRAHelperBuilder;

struct FutureHelper;
struct FutureHelperBuilder;

struct SwapHelper;
struct SwapHelperBuilder;

struct BondHelper;
struct BondHelperBuilder;

struct PointsWrapper;
struct PointsWrapperBuilder;

struct TermStructure;
struct TermStructureBuilder;

struct VolatilityQuote;
struct VolatilityQuoteBuilder;

struct VolatilityTermStructure;
struct VolatilityTermStructureBuilder;

struct ConstantOptionletVolatility;
struct ConstantOptionletVolatilityBuilder;

struct BlackIborCouponPricer;
struct BlackIborCouponPricerBuilder;

struct CouponPricer;
struct CouponPricerBuilder;

struct Yield;
struct YieldBuilder;

struct Pricing;
struct PricingBuilder;

struct Error;
struct ErrorBuilder;

struct FlowInterest;
struct FlowInterestBuilder;

struct FlowInterestFloat;
struct FlowInterestFloatBuilder;

struct FlowPastInterestFloat;
struct FlowPastInterestFloatBuilder;

struct FlowPastInterest;
struct FlowPastInterestBuilder;

struct FlowNotional;
struct FlowNotionalBuilder;

struct FlowsWrapper;
struct FlowsWrapperBuilder;

struct SwapLegFlow;
struct SwapLegFlowBuilder;

struct SwapLegResponse;
struct SwapLegResponseBuilder;

struct VanillaSwapResponse;
struct VanillaSwapResponseBuilder;

struct PriceVanillaSwapResponse;
struct PriceVanillaSwapResponseBuilder;

namespace enums {

enum DayCounter : int8_t {
  DayCounter_Actual360 = 0,
  DayCounter_Actual365Fixed = 1,
  DayCounter_Actual365NoLeap = 2,
  DayCounter_ActualActual = 3,
  DayCounter_ActualActualISMA = 4,
  DayCounter_ActualActualBond = 5,
  DayCounter_ActualActualISDA = 6,
  DayCounter_ActualActualHistorical = 7,
  DayCounter_ActualActual365 = 8,
  DayCounter_ActualActualAFB = 9,
  DayCounter_ActualActualEuro = 10,
  DayCounter_Business252 = 11,
  DayCounter_One = 12,
  DayCounter_Simple = 13,
  DayCounter_Thirty360 = 14,
  DayCounter_MIN = DayCounter_Actual360,
  DayCounter_MAX = DayCounter_Thirty360
};

inline const DayCounter (&EnumValuesDayCounter())[15] {
  static const DayCounter values[] = {
    DayCounter_Actual360,
    DayCounter_Actual365Fixed,
    DayCounter_Actual365NoLeap,
    DayCounter_ActualActual,
    DayCounter_ActualActualISMA,
    DayCounter_ActualActualBond,
    DayCounter_ActualActualISDA,
    DayCounter_ActualActualHistorical,
    DayCounter_ActualActual365,
    DayCounter_ActualActualAFB,
    DayCounter_ActualActualEuro,
    DayCounter_Business252,
    DayCounter_One,
    DayCounter_Simple,
    DayCounter_Thirty360
  };
  return values;
}

inline const char * const *EnumNamesDayCounter() {
  static const char * const names[16] = {
    "Actual360",
    "Actual365Fixed",
    "Actual365NoLeap",
    "ActualActual",
    "ActualActualISMA",
    "ActualActualBond",
    "ActualActualISDA",
    "ActualActualHistorical",
    "ActualActual365",
    "ActualActualAFB",
    "ActualActualEuro",
    "Business252",
    "One",
    "Simple",
    "Thirty360",
    nullptr
  };
  return names;
}

inline const char *EnumNameDayCounter(DayCounter e) {
  if (::flatbuffers::IsOutRange(e, DayCounter_Actual360, DayCounter_Thirty360)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDayCounter()[index];
}

enum Interpolator : int8_t {
  Interpolator_BackwardFlat = 0,
  Interpolator_ForwardFlat = 1,
  Interpolator_Linear = 2,
  Interpolator_LogCubic = 3,
  Interpolator_LogLinear = 4,
  Interpolator_MIN = Interpolator_BackwardFlat,
  Interpolator_MAX = Interpolator_LogLinear
};

inline const Interpolator (&EnumValuesInterpolator())[5] {
  static const Interpolator values[] = {
    Interpolator_BackwardFlat,
    Interpolator_ForwardFlat,
    Interpolator_Linear,
    Interpolator_LogCubic,
    Interpolator_LogLinear
  };
  return values;
}

inline const char * const *EnumNamesInterpolator() {
  static const char * const names[6] = {
    "BackwardFlat",
    "ForwardFlat",
    "Linear",
    "LogCubic",
    "LogLinear",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterpolator(Interpolator e) {
  if (::flatbuffers::IsOutRange(e, Interpolator_BackwardFlat, Interpolator_LogLinear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterpolator()[index];
}

enum BootstrapTrait : int8_t {
  BootstrapTrait_Discount = 0,
  BootstrapTrait_FwdRate = 1,
  BootstrapTrait_InterpolatedDiscount = 2,
  BootstrapTrait_InterpolatedFwd = 3,
  BootstrapTrait_InterpolatedZero = 4,
  BootstrapTrait_ZeroRate = 5,
  BootstrapTrait_MIN = BootstrapTrait_Discount,
  BootstrapTrait_MAX = BootstrapTrait_ZeroRate
};

inline const BootstrapTrait (&EnumValuesBootstrapTrait())[6] {
  static const BootstrapTrait values[] = {
    BootstrapTrait_Discount,
    BootstrapTrait_FwdRate,
    BootstrapTrait_InterpolatedDiscount,
    BootstrapTrait_InterpolatedFwd,
    BootstrapTrait_InterpolatedZero,
    BootstrapTrait_ZeroRate
  };
  return values;
}

inline const char * const *EnumNamesBootstrapTrait() {
  static const char * const names[7] = {
    "Discount",
    "FwdRate",
    "InterpolatedDiscount",
    "InterpolatedFwd",
    "InterpolatedZero",
    "ZeroRate",
    nullptr
  };
  return names;
}

inline const char *EnumNameBootstrapTrait(BootstrapTrait e) {
  if (::flatbuffers::IsOutRange(e, BootstrapTrait_Discount, BootstrapTrait_ZeroRate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBootstrapTrait()[index];
}

enum TimeUnit : int8_t {
  TimeUnit_Days = 0,
  TimeUnit_Hours = 1,
  TimeUnit_Microseconds = 2,
  TimeUnit_Milliseconds = 3,
  TimeUnit_Minutes = 4,
  TimeUnit_Months = 5,
  TimeUnit_Seconds = 6,
  TimeUnit_Weeks = 7,
  TimeUnit_Years = 8,
  TimeUnit_MIN = TimeUnit_Days,
  TimeUnit_MAX = TimeUnit_Years
};

inline const TimeUnit (&EnumValuesTimeUnit())[9] {
  static const TimeUnit values[] = {
    TimeUnit_Days,
    TimeUnit_Hours,
    TimeUnit_Microseconds,
    TimeUnit_Milliseconds,
    TimeUnit_Minutes,
    TimeUnit_Months,
    TimeUnit_Seconds,
    TimeUnit_Weeks,
    TimeUnit_Years
  };
  return values;
}

inline const char * const *EnumNamesTimeUnit() {
  static const char * const names[10] = {
    "Days",
    "Hours",
    "Microseconds",
    "Milliseconds",
    "Minutes",
    "Months",
    "Seconds",
    "Weeks",
    "Years",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeUnit(TimeUnit e) {
  if (::flatbuffers::IsOutRange(e, TimeUnit_Days, TimeUnit_Years)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeUnit()[index];
}

enum Calendar : int8_t {
  Calendar_Argentina = 0,
  Calendar_Australia = 1,
  Calendar_BespokeCalendar = 2,
  Calendar_Brazil = 3,
  Calendar_Canada = 4,
  Calendar_China = 5,
  Calendar_CzechRepublic = 6,
  Calendar_Denmark = 7,
  Calendar_Finland = 8,
  Calendar_Germany = 9,
  Calendar_HongKong = 10,
  Calendar_Hungary = 11,
  Calendar_Iceland = 12,
  Calendar_India = 13,
  Calendar_Indonesia = 14,
  Calendar_Israel = 15,
  Calendar_Italy = 16,
  Calendar_Japan = 17,
  Calendar_Mexico = 18,
  Calendar_NewZealand = 19,
  Calendar_Norway = 20,
  Calendar_NullCalendar = 21,
  Calendar_Poland = 22,
  Calendar_Romania = 23,
  Calendar_Russia = 24,
  Calendar_SaudiArabia = 25,
  Calendar_Singapore = 26,
  Calendar_Slovakia = 27,
  Calendar_SouthAfrica = 28,
  Calendar_SouthKorea = 29,
  Calendar_Sweden = 30,
  Calendar_Switzerland = 31,
  Calendar_TARGET = 32,
  Calendar_Taiwan = 33,
  Calendar_Turkey = 34,
  Calendar_Ukraine = 35,
  Calendar_UnitedKingdom = 36,
  Calendar_UnitedStates = 37,
  Calendar_UnitedStatesGovernmentBond = 38,
  Calendar_UnitedStatesNERC = 39,
  Calendar_UnitedStatesNYSE = 40,
  Calendar_UnitedStatesSettlement = 41,
  Calendar_WeekendsOnly = 42,
  Calendar_MIN = Calendar_Argentina,
  Calendar_MAX = Calendar_WeekendsOnly
};

inline const Calendar (&EnumValuesCalendar())[43] {
  static const Calendar values[] = {
    Calendar_Argentina,
    Calendar_Australia,
    Calendar_BespokeCalendar,
    Calendar_Brazil,
    Calendar_Canada,
    Calendar_China,
    Calendar_CzechRepublic,
    Calendar_Denmark,
    Calendar_Finland,
    Calendar_Germany,
    Calendar_HongKong,
    Calendar_Hungary,
    Calendar_Iceland,
    Calendar_India,
    Calendar_Indonesia,
    Calendar_Israel,
    Calendar_Italy,
    Calendar_Japan,
    Calendar_Mexico,
    Calendar_NewZealand,
    Calendar_Norway,
    Calendar_NullCalendar,
    Calendar_Poland,
    Calendar_Romania,
    Calendar_Russia,
    Calendar_SaudiArabia,
    Calendar_Singapore,
    Calendar_Slovakia,
    Calendar_SouthAfrica,
    Calendar_SouthKorea,
    Calendar_Sweden,
    Calendar_Switzerland,
    Calendar_TARGET,
    Calendar_Taiwan,
    Calendar_Turkey,
    Calendar_Ukraine,
    Calendar_UnitedKingdom,
    Calendar_UnitedStates,
    Calendar_UnitedStatesGovernmentBond,
    Calendar_UnitedStatesNERC,
    Calendar_UnitedStatesNYSE,
    Calendar_UnitedStatesSettlement,
    Calendar_WeekendsOnly
  };
  return values;
}

inline const char * const *EnumNamesCalendar() {
  static const char * const names[44] = {
    "Argentina",
    "Australia",
    "BespokeCalendar",
    "Brazil",
    "Canada",
    "China",
    "CzechRepublic",
    "Denmark",
    "Finland",
    "Germany",
    "HongKong",
    "Hungary",
    "Iceland",
    "India",
    "Indonesia",
    "Israel",
    "Italy",
    "Japan",
    "Mexico",
    "NewZealand",
    "Norway",
    "NullCalendar",
    "Poland",
    "Romania",
    "Russia",
    "SaudiArabia",
    "Singapore",
    "Slovakia",
    "SouthAfrica",
    "SouthKorea",
    "Sweden",
    "Switzerland",
    "TARGET",
    "Taiwan",
    "Turkey",
    "Ukraine",
    "UnitedKingdom",
    "UnitedStates",
    "UnitedStatesGovernmentBond",
    "UnitedStatesNERC",
    "UnitedStatesNYSE",
    "UnitedStatesSettlement",
    "WeekendsOnly",
    nullptr
  };
  return names;
}

inline const char *EnumNameCalendar(Calendar e) {
  if (::flatbuffers::IsOutRange(e, Calendar_Argentina, Calendar_WeekendsOnly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCalendar()[index];
}

enum BusinessDayConvention : int8_t {
  BusinessDayConvention_Following = 0,
  BusinessDayConvention_HalfMonthModifiedFollowing = 1,
  BusinessDayConvention_ModifiedFollowing = 2,
  BusinessDayConvention_ModifiedPreceding = 3,
  BusinessDayConvention_Nearest = 4,
  BusinessDayConvention_Preceding = 5,
  BusinessDayConvention_Unadjusted = 6,
  BusinessDayConvention_MIN = BusinessDayConvention_Following,
  BusinessDayConvention_MAX = BusinessDayConvention_Unadjusted
};

inline const BusinessDayConvention (&EnumValuesBusinessDayConvention())[7] {
  static const BusinessDayConvention values[] = {
    BusinessDayConvention_Following,
    BusinessDayConvention_HalfMonthModifiedFollowing,
    BusinessDayConvention_ModifiedFollowing,
    BusinessDayConvention_ModifiedPreceding,
    BusinessDayConvention_Nearest,
    BusinessDayConvention_Preceding,
    BusinessDayConvention_Unadjusted
  };
  return values;
}

inline const char * const *EnumNamesBusinessDayConvention() {
  static const char * const names[8] = {
    "Following",
    "HalfMonthModifiedFollowing",
    "ModifiedFollowing",
    "ModifiedPreceding",
    "Nearest",
    "Preceding",
    "Unadjusted",
    nullptr
  };
  return names;
}

inline const char *EnumNameBusinessDayConvention(BusinessDayConvention e) {
  if (::flatbuffers::IsOutRange(e, BusinessDayConvention_Following, BusinessDayConvention_Unadjusted)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBusinessDayConvention()[index];
}

enum Frequency : int8_t {
  Frequency_Annual = 0,
  Frequency_Bimonthly = 1,
  Frequency_Biweekly = 2,
  Frequency_Daily = 3,
  Frequency_EveryFourthMonth = 4,
  Frequency_EveryFourthWeek = 5,
  Frequency_Monthly = 6,
  Frequency_NoFrequency = 7,
  Frequency_Once = 8,
  Frequency_OtherFrequency = 9,
  Frequency_Quarterly = 10,
  Frequency_Semiannual = 11,
  Frequency_Weekly = 12,
  Frequency_MIN = Frequency_Annual,
  Frequency_MAX = Frequency_Weekly
};

inline const Frequency (&EnumValuesFrequency())[13] {
  static const Frequency values[] = {
    Frequency_Annual,
    Frequency_Bimonthly,
    Frequency_Biweekly,
    Frequency_Daily,
    Frequency_EveryFourthMonth,
    Frequency_EveryFourthWeek,
    Frequency_Monthly,
    Frequency_NoFrequency,
    Frequency_Once,
    Frequency_OtherFrequency,
    Frequency_Quarterly,
    Frequency_Semiannual,
    Frequency_Weekly
  };
  return values;
}

inline const char * const *EnumNamesFrequency() {
  static const char * const names[14] = {
    "Annual",
    "Bimonthly",
    "Biweekly",
    "Daily",
    "EveryFourthMonth",
    "EveryFourthWeek",
    "Monthly",
    "NoFrequency",
    "Once",
    "OtherFrequency",
    "Quarterly",
    "Semiannual",
    "Weekly",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrequency(Frequency e) {
  if (::flatbuffers::IsOutRange(e, Frequency_Annual, Frequency_Weekly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFrequency()[index];
}

enum DateGenerationRule : int8_t {
  DateGenerationRule_Backward = 0,
  DateGenerationRule_CDS = 1,
  DateGenerationRule_Forward = 2,
  DateGenerationRule_OldCDS = 3,
  DateGenerationRule_ThirdWednesday = 4,
  DateGenerationRule_Twentieth = 5,
  DateGenerationRule_TwentiethIMM = 6,
  DateGenerationRule_Zero = 7,
  DateGenerationRule_MIN = DateGenerationRule_Backward,
  DateGenerationRule_MAX = DateGenerationRule_Zero
};

inline const DateGenerationRule (&EnumValuesDateGenerationRule())[8] {
  static const DateGenerationRule values[] = {
    DateGenerationRule_Backward,
    DateGenerationRule_CDS,
    DateGenerationRule_Forward,
    DateGenerationRule_OldCDS,
    DateGenerationRule_ThirdWednesday,
    DateGenerationRule_Twentieth,
    DateGenerationRule_TwentiethIMM,
    DateGenerationRule_Zero
  };
  return values;
}

inline const char * const *EnumNamesDateGenerationRule() {
  static const char * const names[9] = {
    "Backward",
    "CDS",
    "Forward",
    "OldCDS",
    "ThirdWednesday",
    "Twentieth",
    "TwentiethIMM",
    "Zero",
    nullptr
  };
  return names;
}

inline const char *EnumNameDateGenerationRule(DateGenerationRule e) {
  if (::flatbuffers::IsOutRange(e, DateGenerationRule_Backward, DateGenerationRule_Zero)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDateGenerationRule()[index];
}

enum Ibor : int8_t {
  Ibor_Euribor10M = 0,
  Ibor_Euribor11M = 1,
  Ibor_Euribor1M = 2,
  Ibor_Euribor1Y = 3,
  Ibor_Euribor2M = 4,
  Ibor_Euribor2W = 5,
  Ibor_Euribor365_10M = 6,
  Ibor_Euribor365_11M = 7,
  Ibor_Euribor365_1M = 8,
  Ibor_Euribor365_1Y = 9,
  Ibor_Euribor365_2M = 10,
  Ibor_Euribor365_2W = 11,
  Ibor_Euribor365_3M = 12,
  Ibor_Euribor365_3W = 13,
  Ibor_Euribor365_4M = 14,
  Ibor_Euribor365_5M = 15,
  Ibor_Euribor365_6M = 16,
  Ibor_Euribor365_7M = 17,
  Ibor_Euribor365_8M = 18,
  Ibor_Euribor365_9M = 19,
  Ibor_Euribor365_SW = 20,
  Ibor_Euribor3M = 21,
  Ibor_Euribor3W = 22,
  Ibor_Euribor4M = 23,
  Ibor_Euribor5M = 24,
  Ibor_Euribor6M = 25,
  Ibor_Euribor7M = 26,
  Ibor_Euribor8M = 27,
  Ibor_Euribor9M = 28,
  Ibor_EuriborSW = 29,
  Ibor_MIN = Ibor_Euribor10M,
  Ibor_MAX = Ibor_EuriborSW
};

inline const Ibor (&EnumValuesIbor())[30] {
  static const Ibor values[] = {
    Ibor_Euribor10M,
    Ibor_Euribor11M,
    Ibor_Euribor1M,
    Ibor_Euribor1Y,
    Ibor_Euribor2M,
    Ibor_Euribor2W,
    Ibor_Euribor365_10M,
    Ibor_Euribor365_11M,
    Ibor_Euribor365_1M,
    Ibor_Euribor365_1Y,
    Ibor_Euribor365_2M,
    Ibor_Euribor365_2W,
    Ibor_Euribor365_3M,
    Ibor_Euribor365_3W,
    Ibor_Euribor365_4M,
    Ibor_Euribor365_5M,
    Ibor_Euribor365_6M,
    Ibor_Euribor365_7M,
    Ibor_Euribor365_8M,
    Ibor_Euribor365_9M,
    Ibor_Euribor365_SW,
    Ibor_Euribor3M,
    Ibor_Euribor3W,
    Ibor_Euribor4M,
    Ibor_Euribor5M,
    Ibor_Euribor6M,
    Ibor_Euribor7M,
    Ibor_Euribor8M,
    Ibor_Euribor9M,
    Ibor_EuriborSW
  };
  return values;
}

inline const char * const *EnumNamesIbor() {
  static const char * const names[31] = {
    "Euribor10M",
    "Euribor11M",
    "Euribor1M",
    "Euribor1Y",
    "Euribor2M",
    "Euribor2W",
    "Euribor365_10M",
    "Euribor365_11M",
    "Euribor365_1M",
    "Euribor365_1Y",
    "Euribor365_2M",
    "Euribor365_2W",
    "Euribor365_3M",
    "Euribor365_3W",
    "Euribor365_4M",
    "Euribor365_5M",
    "Euribor365_6M",
    "Euribor365_7M",
    "Euribor365_8M",
    "Euribor365_9M",
    "Euribor365_SW",
    "Euribor3M",
    "Euribor3W",
    "Euribor4M",
    "Euribor5M",
    "Euribor6M",
    "Euribor7M",
    "Euribor8M",
    "Euribor9M",
    "EuriborSW",
    nullptr
  };
  return names;
}

inline const char *EnumNameIbor(Ibor e) {
  if (::flatbuffers::IsOutRange(e, Ibor_Euribor10M, Ibor_EuriborSW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIbor()[index];
}

enum Compounding : int8_t {
  Compounding_Compounded = 0,
  Compounding_Continuous = 1,
  Compounding_Simple = 2,
  Compounding_SimpleThenCompounded = 3,
  Compounding_MIN = Compounding_Compounded,
  Compounding_MAX = Compounding_SimpleThenCompounded
};

inline const Compounding (&EnumValuesCompounding())[4] {
  static const Compounding values[] = {
    Compounding_Compounded,
    Compounding_Continuous,
    Compounding_Simple,
    Compounding_SimpleThenCompounded
  };
  return values;
}

inline const char * const *EnumNamesCompounding() {
  static const char * const names[5] = {
    "Compounded",
    "Continuous",
    "Simple",
    "SimpleThenCompounded",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompounding(Compounding e) {
  if (::flatbuffers::IsOutRange(e, Compounding_Compounded, Compounding_SimpleThenCompounded)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompounding()[index];
}

enum SwapType : int8_t {
  SwapType_Payer = 0,
  SwapType_Receiver = 1,
  SwapType_MIN = SwapType_Payer,
  SwapType_MAX = SwapType_Receiver
};

inline const SwapType (&EnumValuesSwapType())[2] {
  static const SwapType values[] = {
    SwapType_Payer,
    SwapType_Receiver
  };
  return values;
}

inline const char * const *EnumNamesSwapType() {
  static const char * const names[3] = {
    "Payer",
    "Receiver",
    nullptr
  };
  return names;
}

inline const char *EnumNameSwapType(SwapType e) {
  if (::flatbuffers::IsOutRange(e, SwapType_Payer, SwapType_Receiver)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSwapType()[index];
}

enum FRAType : int8_t {
  FRAType_Long = 0,
  FRAType_Short = 1,
  FRAType_MIN = FRAType_Long,
  FRAType_MAX = FRAType_Short
};

inline const FRAType (&EnumValuesFRAType())[2] {
  static const FRAType values[] = {
    FRAType_Long,
    FRAType_Short
  };
  return values;
}

inline const char * const *EnumNamesFRAType() {
  static const char * const names[3] = {
    "Long",
    "Short",
    nullptr
  };
  return names;
}

inline const char *EnumNameFRAType(FRAType e) {
  if (::flatbuffers::IsOutRange(e, FRAType_Long, FRAType_Short)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFRAType()[index];
}

enum CapFloorType : int8_t {
  CapFloorType_Cap = 0,
  CapFloorType_Floor = 1,
  CapFloorType_Collar = 2,
  CapFloorType_MIN = CapFloorType_Cap,
  CapFloorType_MAX = CapFloorType_Collar
};

inline const CapFloorType (&EnumValuesCapFloorType())[3] {
  static const CapFloorType values[] = {
    CapFloorType_Cap,
    CapFloorType_Floor,
    CapFloorType_Collar
  };
  return values;
}

inline const char * const *EnumNamesCapFloorType() {
  static const char * const names[4] = {
    "Cap",
    "Floor",
    "Collar",
    nullptr
  };
  return names;
}

inline const char *EnumNameCapFloorType(CapFloorType e) {
  if (::flatbuffers::IsOutRange(e, CapFloorType_Cap, CapFloorType_Collar)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCapFloorType()[index];
}

enum ExerciseType : int8_t {
  ExerciseType_European = 0,
  ExerciseType_Bermudan = 1,
  ExerciseType_American = 2,
  ExerciseType_MIN = ExerciseType_European,
  ExerciseType_MAX = ExerciseType_American
};

inline const ExerciseType (&EnumValuesExerciseType())[3] {
  static const ExerciseType values[] = {
    ExerciseType_European,
    ExerciseType_Bermudan,
    ExerciseType_American
  };
  return values;
}

inline const char * const *EnumNamesExerciseType() {
  static const char * const names[4] = {
    "European",
    "Bermudan",
    "American",
    nullptr
  };
  return names;
}

inline const char *EnumNameExerciseType(ExerciseType e) {
  if (::flatbuffers::IsOutRange(e, ExerciseType_European, ExerciseType_American)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExerciseType()[index];
}

enum SettlementType : int8_t {
  SettlementType_Physical = 0,
  SettlementType_Cash = 1,
  SettlementType_MIN = SettlementType_Physical,
  SettlementType_MAX = SettlementType_Cash
};

inline const SettlementType (&EnumValuesSettlementType())[2] {
  static const SettlementType values[] = {
    SettlementType_Physical,
    SettlementType_Cash
  };
  return values;
}

inline const char * const *EnumNamesSettlementType() {
  static const char * const names[3] = {
    "Physical",
    "Cash",
    nullptr
  };
  return names;
}

inline const char *EnumNameSettlementType(SettlementType e) {
  if (::flatbuffers::IsOutRange(e, SettlementType_Physical, SettlementType_Cash)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSettlementType()[index];
}

enum ProtectionSide : int8_t {
  ProtectionSide_Buyer = 0,
  ProtectionSide_Seller = 1,
  ProtectionSide_MIN = ProtectionSide_Buyer,
  ProtectionSide_MAX = ProtectionSide_Seller
};

inline const ProtectionSide (&EnumValuesProtectionSide())[2] {
  static const ProtectionSide values[] = {
    ProtectionSide_Buyer,
    ProtectionSide_Seller
  };
  return values;
}

inline const char * const *EnumNamesProtectionSide() {
  static const char * const names[3] = {
    "Buyer",
    "Seller",
    nullptr
  };
  return names;
}

inline const char *EnumNameProtectionSide(ProtectionSide e) {
  if (::flatbuffers::IsOutRange(e, ProtectionSide_Buyer, ProtectionSide_Seller)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProtectionSide()[index];
}

enum VolatilityType : int8_t {
  VolatilityType_ShiftedLognormal = 0,
  VolatilityType_Normal = 1,
  VolatilityType_MIN = VolatilityType_ShiftedLognormal,
  VolatilityType_MAX = VolatilityType_Normal
};

inline const VolatilityType (&EnumValuesVolatilityType())[2] {
  static const VolatilityType values[] = {
    VolatilityType_ShiftedLognormal,
    VolatilityType_Normal
  };
  return values;
}

inline const char * const *EnumNamesVolatilityType() {
  static const char * const names[3] = {
    "ShiftedLognormal",
    "Normal",
    nullptr
  };
  return names;
}

inline const char *EnumNameVolatilityType(VolatilityType e) {
  if (::flatbuffers::IsOutRange(e, VolatilityType_ShiftedLognormal, VolatilityType_Normal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVolatilityType()[index];
}

}  // namespace enums

enum Point : uint8_t {
  Point_NONE = 0,
  Point_DepositHelper = 1,
  Point_FRAHelper = 2,
  Point_FutureHelper = 3,
  Point_SwapHelper = 4,
  Point_BondHelper = 5,
  Point_MIN = Point_NONE,
  Point_MAX = Point_BondHelper
};

inline const Point (&EnumValuesPoint())[6] {
  static const Point values[] = {
    Point_NONE,
    Point_DepositHelper,
    Point_FRAHelper,
    Point_FutureHelper,
    Point_SwapHelper,
    Point_BondHelper
  };
  return values;
}

inline const char * const *EnumNamesPoint() {
  static const char * const names[7] = {
    "NONE",
    "DepositHelper",
    "FRAHelper",
    "FutureHelper",
    "SwapHelper",
    "BondHelper",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoint(Point e) {
  if (::flatbuffers::IsOutRange(e, Point_NONE, Point_BondHelper)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoint()[index];
}

template<typename T> struct PointTraits {
  static const Point enum_value = Point_NONE;
};

template<> struct PointTraits<quantra::DepositHelper> {
  static const Point enum_value = Point_DepositHelper;
};

template<> struct PointTraits<quantra::FRAHelper> {
  static const Point enum_value = Point_FRAHelper;
};

template<> struct PointTraits<quantra::FutureHelper> {
  static const Point enum_value = Point_FutureHelper;
};

template<> struct PointTraits<quantra::SwapHelper> {
  static const Point enum_value = Point_SwapHelper;
};

template<> struct PointTraits<quantra::BondHelper> {
  static const Point enum_value = Point_BondHelper;
};

bool VerifyPoint(::flatbuffers::Verifier &verifier, const void *obj, Point type);
bool VerifyPointVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum OptionletVolatilityStructure : uint8_t {
  OptionletVolatilityStructure_NONE = 0,
  OptionletVolatilityStructure_ConstantOptionletVolatility = 1,
  OptionletVolatilityStructure_MIN = OptionletVolatilityStructure_NONE,
  OptionletVolatilityStructure_MAX = OptionletVolatilityStructure_ConstantOptionletVolatility
};

inline const OptionletVolatilityStructure (&EnumValuesOptionletVolatilityStructure())[2] {
  static const OptionletVolatilityStructure values[] = {
    OptionletVolatilityStructure_NONE,
    OptionletVolatilityStructure_ConstantOptionletVolatility
  };
  return values;
}

inline const char * const *EnumNamesOptionletVolatilityStructure() {
  static const char * const names[3] = {
    "NONE",
    "ConstantOptionletVolatility",
    nullptr
  };
  return names;
}

inline const char *EnumNameOptionletVolatilityStructure(OptionletVolatilityStructure e) {
  if (::flatbuffers::IsOutRange(e, OptionletVolatilityStructure_NONE, OptionletVolatilityStructure_ConstantOptionletVolatility)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOptionletVolatilityStructure()[index];
}

template<typename T> struct OptionletVolatilityStructureTraits {
  static const OptionletVolatilityStructure enum_value = OptionletVolatilityStructure_NONE;
};

template<> struct OptionletVolatilityStructureTraits<quantra::ConstantOptionletVolatility> {
  static const OptionletVolatilityStructure enum_value = OptionletVolatilityStructure_ConstantOptionletVolatility;
};

bool VerifyOptionletVolatilityStructure(::flatbuffers::Verifier &verifier, const void *obj, OptionletVolatilityStructure type);
bool VerifyOptionletVolatilityStructureVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Pricer : uint8_t {
  Pricer_NONE = 0,
  Pricer_BlackIborCouponPricer = 1,
  Pricer_MIN = Pricer_NONE,
  Pricer_MAX = Pricer_BlackIborCouponPricer
};

inline const Pricer (&EnumValuesPricer())[2] {
  static const Pricer values[] = {
    Pricer_NONE,
    Pricer_BlackIborCouponPricer
  };
  return values;
}

inline const char * const *EnumNamesPricer() {
  static const char * const names[3] = {
    "NONE",
    "BlackIborCouponPricer",
    nullptr
  };
  return names;
}

inline const char *EnumNamePricer(Pricer e) {
  if (::flatbuffers::IsOutRange(e, Pricer_NONE, Pricer_BlackIborCouponPricer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPricer()[index];
}

template<typename T> struct PricerTraits {
  static const Pricer enum_value = Pricer_NONE;
};

template<> struct PricerTraits<quantra::BlackIborCouponPricer> {
  static const Pricer enum_value = Pricer_BlackIborCouponPricer;
};

bool VerifyPricer(::flatbuffers::Verifier &verifier, const void *obj, Pricer type);
bool VerifyPricerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Flow : uint8_t {
  Flow_NONE = 0,
  Flow_FlowInterest = 1,
  Flow_FlowPastInterest = 2,
  Flow_FlowNotional = 3,
  Flow_MIN = Flow_NONE,
  Flow_MAX = Flow_FlowNotional
};

inline const Flow (&EnumValuesFlow())[4] {
  static const Flow values[] = {
    Flow_NONE,
    Flow_FlowInterest,
    Flow_FlowPastInterest,
    Flow_FlowNotional
  };
  return values;
}

inline const char * const *EnumNamesFlow() {
  static const char * const names[5] = {
    "NONE",
    "FlowInterest",
    "FlowPastInterest",
    "FlowNotional",
    nullptr
  };
  return names;
}

inline const char *EnumNameFlow(Flow e) {
  if (::flatbuffers::IsOutRange(e, Flow_NONE, Flow_FlowNotional)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFlow()[index];
}

template<typename T> struct FlowTraits {
  static const Flow enum_value = Flow_NONE;
};

template<> struct FlowTraits<quantra::FlowInterest> {
  static const Flow enum_value = Flow_FlowInterest;
};

template<> struct FlowTraits<quantra::FlowPastInterest> {
  static const Flow enum_value = Flow_FlowPastInterest;
};

template<> struct FlowTraits<quantra::FlowNotional> {
  static const Flow enum_value = Flow_FlowNotional;
};

bool VerifyFlow(::flatbuffers::Verifier &verifier, const void *obj, Flow type);
bool VerifyFlowVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Schedule FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScheduleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALENDAR = 4,
    VT_EFFECTIVE_DATE = 6,
    VT_TERMINATION_DATE = 8,
    VT_FREQUENCY = 10,
    VT_CONVENTION = 12,
    VT_TERMINATION_DATE_CONVENTION = 14,
    VT_DATE_GENERATION_RULE = 16,
    VT_END_OF_MONTH = 18
  };
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  const ::flatbuffers::String *effective_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EFFECTIVE_DATE);
  }
  const ::flatbuffers::String *termination_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TERMINATION_DATE);
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  quantra::enums::BusinessDayConvention convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_CONVENTION, 0));
  }
  quantra::enums::BusinessDayConvention termination_date_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_TERMINATION_DATE_CONVENTION, 0));
  }
  quantra::enums::DateGenerationRule date_generation_rule() const {
    return static_cast<quantra::enums::DateGenerationRule>(GetField<int8_t>(VT_DATE_GENERATION_RULE, 0));
  }
  bool end_of_month() const {
    return GetField<uint8_t>(VT_END_OF_MONTH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyOffset(verifier, VT_EFFECTIVE_DATE) &&
           verifier.VerifyString(effective_date()) &&
           VerifyOffset(verifier, VT_TERMINATION_DATE) &&
           verifier.VerifyString(termination_date()) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_TERMINATION_DATE_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DATE_GENERATION_RULE, 1) &&
           VerifyField<uint8_t>(verifier, VT_END_OF_MONTH, 1) &&
           verifier.EndTable();
  }
};

struct ScheduleBuilder {
  typedef Schedule Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(Schedule::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_effective_date(::flatbuffers::Offset<::flatbuffers::String> effective_date) {
    fbb_.AddOffset(Schedule::VT_EFFECTIVE_DATE, effective_date);
  }
  void add_termination_date(::flatbuffers::Offset<::flatbuffers::String> termination_date) {
    fbb_.AddOffset(Schedule::VT_TERMINATION_DATE, termination_date);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(Schedule::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  void add_convention(quantra::enums::BusinessDayConvention convention) {
    fbb_.AddElement<int8_t>(Schedule::VT_CONVENTION, static_cast<int8_t>(convention), 0);
  }
  void add_termination_date_convention(quantra::enums::BusinessDayConvention termination_date_convention) {
    fbb_.AddElement<int8_t>(Schedule::VT_TERMINATION_DATE_CONVENTION, static_cast<int8_t>(termination_date_convention), 0);
  }
  void add_date_generation_rule(quantra::enums::DateGenerationRule date_generation_rule) {
    fbb_.AddElement<int8_t>(Schedule::VT_DATE_GENERATION_RULE, static_cast<int8_t>(date_generation_rule), 0);
  }
  void add_end_of_month(bool end_of_month) {
    fbb_.AddElement<uint8_t>(Schedule::VT_END_OF_MONTH, static_cast<uint8_t>(end_of_month), 0);
  }
  explicit ScheduleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Schedule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Schedule>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Schedule> CreateSchedule(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    ::flatbuffers::Offset<::flatbuffers::String> effective_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> termination_date = 0,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::BusinessDayConvention termination_date_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DateGenerationRule date_generation_rule = quantra::enums::DateGenerationRule_Backward,
    bool end_of_month = false) {
  ScheduleBuilder builder_(_fbb);
  builder_.add_termination_date(termination_date);
  builder_.add_effective_date(effective_date);
  builder_.add_end_of_month(end_of_month);
  builder_.add_date_generation_rule(date_generation_rule);
  builder_.add_termination_date_convention(termination_date_convention);
  builder_.add_convention(convention);
  builder_.add_frequency(frequency);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Schedule> CreateScheduleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    const char *effective_date = nullptr,
    const char *termination_date = nullptr,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::BusinessDayConvention termination_date_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DateGenerationRule date_generation_rule = quantra::enums::DateGenerationRule_Backward,
    bool end_of_month = false) {
  auto effective_date__ = effective_date ? _fbb.CreateString(effective_date) : 0;
  auto termination_date__ = termination_date ? _fbb.CreateString(termination_date) : 0;
  return quantra::CreateSchedule(
      _fbb,
      calendar,
      effective_date__,
      termination_date__,
      frequency,
      convention,
      termination_date_convention,
      date_generation_rule,
      end_of_month);
}

struct DepositHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepositHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
};

struct DepositHelperBuilder {
  typedef DepositHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(DepositHelper::VT_RATE, rate, 0.0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(DepositHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(DepositHelper::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(DepositHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit DepositHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepositHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepositHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepositHelper> CreateDepositHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  DepositHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_fixing_days(fixing_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

struct FRAHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FRAHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_MONTHS_TO_START = 6,
    VT_MONTHS_TO_END = 8,
    VT_FIXING_DAYS = 10,
    VT_CALENDAR = 12,
    VT_BUSINESS_DAY_CONVENTION = 14,
    VT_DAY_COUNTER = 16
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  int32_t months_to_start() const {
    return GetField<int32_t>(VT_MONTHS_TO_START, 0);
  }
  int32_t months_to_end() const {
    return GetField<int32_t>(VT_MONTHS_TO_END, 0);
  }
  int32_t fixing_days() const {
    return GetField<int32_t>(VT_FIXING_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_START, 4) &&
           VerifyField<int32_t>(verifier, VT_MONTHS_TO_END, 4) &&
           VerifyField<int32_t>(verifier, VT_FIXING_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
};

struct FRAHelperBuilder {
  typedef FRAHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(FRAHelper::VT_RATE, rate, 0.0);
  }
  void add_months_to_start(int32_t months_to_start) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_MONTHS_TO_START, months_to_start, 0);
  }
  void add_months_to_end(int32_t months_to_end) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_MONTHS_TO_END, months_to_end, 0);
  }
  void add_fixing_days(int32_t fixing_days) {
    fbb_.AddElement<int32_t>(FRAHelper::VT_FIXING_DAYS, fixing_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FRAHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit FRAHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FRAHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FRAHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FRAHelper> CreateFRAHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t months_to_start = 0,
    int32_t months_to_end = 0,
    int32_t fixing_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  FRAHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_fixing_days(fixing_days);
  builder_.add_months_to_end(months_to_end);
  builder_.add_months_to_start(months_to_start);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

struct FutureHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FutureHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_FUTURE_START_DATE = 6,
    VT_FUTURE_MONTHS = 8,
    VT_CALENDAR = 10,
    VT_BUSINESS_DAY_CONVENTION = 12,
    VT_DAY_COUNTER = 14
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  const ::flatbuffers::String *future_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUTURE_START_DATE);
  }
  int32_t future_months() const {
    return GetField<int32_t>(VT_FUTURE_MONTHS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyOffset(verifier, VT_FUTURE_START_DATE) &&
           verifier.VerifyString(future_start_date()) &&
           VerifyField<int32_t>(verifier, VT_FUTURE_MONTHS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
};

struct FutureHelperBuilder {
  typedef FutureHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(FutureHelper::VT_RATE, rate, 0.0);
  }
  void add_future_start_date(::flatbuffers::Offset<::flatbuffers::String> future_start_date) {
    fbb_.AddOffset(FutureHelper::VT_FUTURE_START_DATE, future_start_date);
  }
  void add_future_months(int32_t future_months) {
    fbb_.AddElement<int32_t>(FutureHelper::VT_FUTURE_MONTHS, future_months, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(FutureHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit FutureHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FutureHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FutureHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> future_start_date = 0,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  FutureHelperBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_future_months(future_months);
  builder_.add_future_start_date(future_start_date);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FutureHelper> CreateFutureHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    const char *future_start_date = nullptr,
    int32_t future_months = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  auto future_start_date__ = future_start_date ? _fbb.CreateString(future_start_date) : 0;
  return quantra::CreateFutureHelper(
      _fbb,
      rate,
      future_start_date__,
      future_months,
      calendar,
      business_day_convention,
      day_counter);
}

struct SwapHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_TENOR_NUMBER = 8,
    VT_CALENDAR = 10,
    VT_SW_FIXED_LEG_FREQUENCY = 12,
    VT_SW_FIXED_LEG_CONVENTION = 14,
    VT_SW_FIXED_LEG_DAY_COUNTER = 16,
    VT_SW_FLOATING_LEG_INDEX = 18,
    VT_SPREAD = 20,
    VT_FWD_START_DAYS = 22
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::Frequency sw_fixed_leg_frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_SW_FIXED_LEG_FREQUENCY, 0));
  }
  quantra::enums::BusinessDayConvention sw_fixed_leg_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_SW_FIXED_LEG_CONVENTION, 0));
  }
  quantra::enums::DayCounter sw_fixed_leg_day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_SW_FIXED_LEG_DAY_COUNTER, 0));
  }
  quantra::enums::Ibor sw_floating_leg_index() const {
    return static_cast<quantra::enums::Ibor>(GetField<int8_t>(VT_SW_FLOATING_LEG_INDEX, 0));
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  int32_t fwd_start_days() const {
    return GetField<int32_t>(VT_FWD_START_DAYS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_FREQUENCY, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FIXED_LEG_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_SW_FLOATING_LEG_INDEX, 1) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<int32_t>(verifier, VT_FWD_START_DAYS, 4) &&
           verifier.EndTable();
  }
};

struct SwapHelperBuilder {
  typedef SwapHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(SwapHelper::VT_RATE, rate, 0.0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(SwapHelper::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_sw_fixed_leg_frequency(quantra::enums::Frequency sw_fixed_leg_frequency) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_FREQUENCY, static_cast<int8_t>(sw_fixed_leg_frequency), 0);
  }
  void add_sw_fixed_leg_convention(quantra::enums::BusinessDayConvention sw_fixed_leg_convention) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_CONVENTION, static_cast<int8_t>(sw_fixed_leg_convention), 0);
  }
  void add_sw_fixed_leg_day_counter(quantra::enums::DayCounter sw_fixed_leg_day_counter) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FIXED_LEG_DAY_COUNTER, static_cast<int8_t>(sw_fixed_leg_day_counter), 0);
  }
  void add_sw_floating_leg_index(quantra::enums::Ibor sw_floating_leg_index) {
    fbb_.AddElement<int8_t>(SwapHelper::VT_SW_FLOATING_LEG_INDEX, static_cast<int8_t>(sw_floating_leg_index), 0);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(SwapHelper::VT_SPREAD, spread, 0.0);
  }
  void add_fwd_start_days(int32_t fwd_start_days) {
    fbb_.AddElement<int32_t>(SwapHelper::VT_FWD_START_DAYS, fwd_start_days, 0);
  }
  explicit SwapHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapHelper> CreateSwapHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    int32_t tenor_number = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::Frequency sw_fixed_leg_frequency = quantra::enums::Frequency_Annual,
    quantra::enums::BusinessDayConvention sw_fixed_leg_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter sw_fixed_leg_day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Ibor sw_floating_leg_index = quantra::enums::Ibor_Euribor10M,
    double spread = 0.0,
    int32_t fwd_start_days = 0) {
  SwapHelperBuilder builder_(_fbb);
  builder_.add_spread(spread);
  builder_.add_rate(rate);
  builder_.add_fwd_start_days(fwd_start_days);
  builder_.add_tenor_number(tenor_number);
  builder_.add_sw_floating_leg_index(sw_floating_leg_index);
  builder_.add_sw_fixed_leg_day_counter(sw_fixed_leg_day_counter);
  builder_.add_sw_fixed_leg_convention(sw_fixed_leg_convention);
  builder_.add_sw_fixed_leg_frequency(sw_fixed_leg_frequency);
  builder_.add_calendar(calendar);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

struct BondHelper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BondHelperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4,
    VT_SETTLEMENT_DAYS = 6,
    VT_FACE_AMOUNT = 8,
    VT_SCHEDULE = 10,
    VT_COUPON_RATE = 12,
    VT_DAY_COUNTER = 14,
    VT_BUSINESS_DAY_CONVENTION = 16,
    VT_REDEMPTION = 18,
    VT_ISSUE_DATE = 20
  };
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 0);
  }
  double face_amount() const {
    return GetField<double>(VT_FACE_AMOUNT, 0.0);
  }
  const quantra::Schedule *schedule() const {
    return GetPointer<const quantra::Schedule *>(VT_SCHEDULE);
  }
  double coupon_rate() const {
    return GetField<double>(VT_COUPON_RATE, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  double redemption() const {
    return GetField<double>(VT_REDEMPTION, 0.0);
  }
  const ::flatbuffers::String *issue_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ISSUE_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<double>(verifier, VT_FACE_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.VerifyTable(schedule()) &&
           VerifyField<double>(verifier, VT_COUPON_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<double>(verifier, VT_REDEMPTION, 8) &&
           VerifyOffset(verifier, VT_ISSUE_DATE) &&
           verifier.VerifyString(issue_date()) &&
           verifier.EndTable();
  }
};

struct BondHelperBuilder {
  typedef BondHelper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rate(double rate) {
    fbb_.AddElement<double>(BondHelper::VT_RATE, rate, 0.0);
  }
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(BondHelper::VT_SETTLEMENT_DAYS, settlement_days, 0);
  }
  void add_face_amount(double face_amount) {
    fbb_.AddElement<double>(BondHelper::VT_FACE_AMOUNT, face_amount, 0.0);
  }
  void add_schedule(::flatbuffers::Offset<quantra::Schedule> schedule) {
    fbb_.AddOffset(BondHelper::VT_SCHEDULE, schedule);
  }
  void add_coupon_rate(double coupon_rate) {
    fbb_.AddElement<double>(BondHelper::VT_COUPON_RATE, coupon_rate, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(BondHelper::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(BondHelper::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_redemption(double redemption) {
    fbb_.AddElement<double>(BondHelper::VT_REDEMPTION, redemption, 0.0);
  }
  void add_issue_date(::flatbuffers::Offset<::flatbuffers::String> issue_date) {
    fbb_.AddOffset(BondHelper::VT_ISSUE_DATE, issue_date);
  }
  explicit BondHelperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BondHelper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BondHelper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BondHelper> CreateBondHelper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t settlement_days = 0,
    double face_amount = 0.0,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double coupon_rate = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double redemption = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> issue_date = 0) {
  BondHelperBuilder builder_(_fbb);
  builder_.add_redemption(redemption);
  builder_.add_coupon_rate(coupon_rate);
  builder_.add_face_amount(face_amount);
  builder_.add_rate(rate);
  builder_.add_issue_date(issue_date);
  builder_.add_schedule(schedule);
  builder_.add_settlement_days(settlement_days);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BondHelper> CreateBondHelperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double rate = 0.0,
    int32_t settlement_days = 0,
    double face_amount = 0.0,
    ::flatbuffers::Offset<quantra::Schedule> schedule = 0,
    double coupon_rate = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double redemption = 0.0,
    const char *issue_date = nullptr) {
  auto issue_date__ = issue_date ? _fbb.CreateString(issue_date) : 0;
  return quantra::CreateBondHelper(
      _fbb,
      rate,
      settlement_days,
      face_amount,
      schedule,
      coupon_rate,
      day_counter,
      business_day_convention,
      redemption,
      issue_date__);
}

struct PointsWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointsWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINT_TYPE = 4,
    VT_POINT = 6
  };
  quantra::Point point_type() const {
    return static_cast<quantra::Point>(GetField<uint8_t>(VT_POINT_TYPE, 0));
  }
  const void *point() const {
    return GetPointer<const void *>(VT_POINT);
  }
  template<typename T> const T *point_as() const;
  const quantra::DepositHelper *point_as_DepositHelper() const {
    return point_type() == quantra::Point_DepositHelper ? static_cast<const quantra::DepositHelper *>(point()) : nullptr;
  }
  const quantra::FRAHelper *point_as_FRAHelper() const {
    return point_type() == quantra::Point_FRAHelper ? static_cast<const quantra::FRAHelper *>(point()) : nullptr;
  }
  const quantra::FutureHelper *point_as_FutureHelper() const {
    return point_type() == quantra::Point_FutureHelper ? static_cast<const quantra::FutureHelper *>(point()) : nullptr;
  }
  const quantra::SwapHelper *point_as_SwapHelper() const {
    return point_type() == quantra::Point_SwapHelper ? static_cast<const quantra::SwapHelper *>(point()) : nullptr;
  }
  const quantra::BondHelper *point_as_BondHelper() const {
    return point_type() == quantra::Point_BondHelper ? static_cast<const quantra::BondHelper *>(point()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POINT_TYPE, 1) &&
           VerifyOffset(verifier, VT_POINT) &&
           VerifyPoint(verifier, point(), point_type()) &&
           verifier.EndTable();
  }
};

template<> inline const quantra::DepositHelper *PointsWrapper::point_as<quantra::DepositHelper>() const {
  return point_as_DepositHelper();
}

template<> inline const quantra::FRAHelper *PointsWrapper::point_as<quantra::FRAHelper>() const {
  return point_as_FRAHelper();
}

template<> inline const quantra::FutureHelper *PointsWrapper::point_as<quantra::FutureHelper>() const {
  return point_as_FutureHelper();
}

template<> inline const quantra::SwapHelper *PointsWrapper::point_as<quantra::SwapHelper>() const {
  return point_as_SwapHelper();
}

template<> inline const quantra::BondHelper *PointsWrapper::point_as<quantra::BondHelper>() const {
  return point_as_BondHelper();
}

struct PointsWrapperBuilder {
  typedef PointsWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_point_type(quantra::Point point_type) {
    fbb_.AddElement<uint8_t>(PointsWrapper::VT_POINT_TYPE, static_cast<uint8_t>(point_type), 0);
  }
  void add_point(::flatbuffers::Offset<void> point) {
    fbb_.AddOffset(PointsWrapper::VT_POINT, point);
  }
  explicit PointsWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointsWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointsWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointsWrapper> CreatePointsWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::Point point_type = quantra::Point_NONE,
    ::flatbuffers::Offset<void> point = 0) {
  PointsWrapperBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_point_type(point_type);
  return builder_.Finish();
}

struct TermStructure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TermStructureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DAY_COUNTER = 6,
    VT_INTERPOLATOR = 8,
    VT_BOOTSTRAP_TRAIT = 10,
    VT_POINTS = 12,
    VT_REFERENCE_DATE = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Interpolator interpolator() const {
    return static_cast<quantra::enums::Interpolator>(GetField<int8_t>(VT_INTERPOLATOR, 0));
  }
  quantra::enums::BootstrapTrait bootstrap_trait() const {
    return static_cast<quantra::enums::BootstrapTrait>(GetField<int8_t>(VT_BOOTSTRAP_TRAIT, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>> *>(VT_POINTS);
  }
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_INTERPOLATOR, 1) &&
           VerifyField<int8_t>(verifier, VT_BOOTSTRAP_TRAIT, 1) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           verifier.EndTable();
  }
};

struct TermStructureBuilder {
  typedef TermStructure Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TermStructure::VT_ID, id);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(TermStructure::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_interpolator(quantra::enums::Interpolator interpolator) {
    fbb_.AddElement<int8_t>(TermStructure::VT_INTERPOLATOR, static_cast<int8_t>(interpolator), 0);
  }
  void add_bootstrap_trait(quantra::enums::BootstrapTrait bootstrap_trait) {
    fbb_.AddElement<int8_t>(TermStructure::VT_BOOTSTRAP_TRAIT, static_cast<int8_t>(bootstrap_trait), 0);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>>> points) {
    fbb_.AddOffset(TermStructure::VT_POINTS, points);
  }
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(TermStructure::VT_REFERENCE_DATE, reference_date);
  }
  explicit TermStructureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TermStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TermStructure>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TermStructure> CreateTermStructure(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::PointsWrapper>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0) {
  TermStructureBuilder builder_(_fbb);
  builder_.add_reference_date(reference_date);
  builder_.add_points(points);
  builder_.add_id(id);
  builder_.add_bootstrap_trait(bootstrap_trait);
  builder_.add_interpolator(interpolator);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TermStructure> CreateTermStructureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Interpolator interpolator = quantra::enums::Interpolator_BackwardFlat,
    quantra::enums::BootstrapTrait bootstrap_trait = quantra::enums::BootstrapTrait_Discount,
    const std::vector<::flatbuffers::Offset<quantra::PointsWrapper>> *points = nullptr,
    const char *reference_date = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<quantra::PointsWrapper>>(*points) : 0;
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  return quantra::CreateTermStructure(
      _fbb,
      id__,
      day_counter,
      interpolator,
      bootstrap_trait,
      points__,
      reference_date__);
}

struct VolatilityQuote FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VolatilityQuoteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENOR_NUMBER = 4,
    VT_TENOR_TIME_UNIT = 6,
    VT_STRIKE = 8,
    VT_VOLATILITY = 10
  };
  int32_t tenor_number() const {
    return GetField<int32_t>(VT_TENOR_NUMBER, 0);
  }
  quantra::enums::TimeUnit tenor_time_unit() const {
    return static_cast<quantra::enums::TimeUnit>(GetField<int8_t>(VT_TENOR_TIME_UNIT, 0));
  }
  double strike() const {
    return GetField<double>(VT_STRIKE, 0.0);
  }
  double volatility() const {
    return GetField<double>(VT_VOLATILITY, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TENOR_NUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_TENOR_TIME_UNIT, 1) &&
           VerifyField<double>(verifier, VT_STRIKE, 8) &&
           VerifyField<double>(verifier, VT_VOLATILITY, 8) &&
           verifier.EndTable();
  }
};

struct VolatilityQuoteBuilder {
  typedef VolatilityQuote Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tenor_number(int32_t tenor_number) {
    fbb_.AddElement<int32_t>(VolatilityQuote::VT_TENOR_NUMBER, tenor_number, 0);
  }
  void add_tenor_time_unit(quantra::enums::TimeUnit tenor_time_unit) {
    fbb_.AddElement<int8_t>(VolatilityQuote::VT_TENOR_TIME_UNIT, static_cast<int8_t>(tenor_time_unit), 0);
  }
  void add_strike(double strike) {
    fbb_.AddElement<double>(VolatilityQuote::VT_STRIKE, strike, 0.0);
  }
  void add_volatility(double volatility) {
    fbb_.AddElement<double>(VolatilityQuote::VT_VOLATILITY, volatility, 0.0);
  }
  explicit VolatilityQuoteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VolatilityQuote> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VolatilityQuote>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VolatilityQuote> CreateVolatilityQuote(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tenor_number = 0,
    quantra::enums::TimeUnit tenor_time_unit = quantra::enums::TimeUnit_Days,
    double strike = 0.0,
    double volatility = 0.0) {
  VolatilityQuoteBuilder builder_(_fbb);
  builder_.add_volatility(volatility);
  builder_.add_strike(strike);
  builder_.add_tenor_number(tenor_number);
  builder_.add_tenor_time_unit(tenor_time_unit);
  return builder_.Finish();
}

struct VolatilityTermStructure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VolatilityTermStructureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_REFERENCE_DATE = 6,
    VT_CALENDAR = 8,
    VT_BUSINESS_DAY_CONVENTION = 10,
    VT_DAY_COUNTER = 12,
    VT_VOLATILITY_TYPE = 14,
    VT_CONSTANT_VOL = 16,
    VT_QUOTES = 18
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *reference_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_DATE);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::VolatilityType volatility_type() const {
    return static_cast<quantra::enums::VolatilityType>(GetField<int8_t>(VT_VOLATILITY_TYPE, 0));
  }
  double constant_vol() const {
    return GetField<double>(VT_CONSTANT_VOL, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityQuote>> *quotes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityQuote>> *>(VT_QUOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_REFERENCE_DATE) &&
           verifier.VerifyString(reference_date()) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_VOLATILITY_TYPE, 1) &&
           VerifyField<double>(verifier, VT_CONSTANT_VOL, 8) &&
           VerifyOffset(verifier, VT_QUOTES) &&
           verifier.VerifyVector(quotes()) &&
           verifier.VerifyVectorOfTables(quotes()) &&
           verifier.EndTable();
  }
};

struct VolatilityTermStructureBuilder {
  typedef VolatilityTermStructure Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(VolatilityTermStructure::VT_ID, id);
  }
  void add_reference_date(::flatbuffers::Offset<::flatbuffers::String> reference_date) {
    fbb_.AddOffset(VolatilityTermStructure::VT_REFERENCE_DATE, reference_date);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(VolatilityTermStructure::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(VolatilityTermStructure::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(VolatilityTermStructure::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_volatility_type(quantra::enums::VolatilityType volatility_type) {
    fbb_.AddElement<int8_t>(VolatilityTermStructure::VT_VOLATILITY_TYPE, static_cast<int8_t>(volatility_type), 0);
  }
  void add_constant_vol(double constant_vol) {
    fbb_.AddElement<double>(VolatilityTermStructure::VT_CONSTANT_VOL, constant_vol, 0.0);
  }
  void add_quotes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityQuote>>> quotes) {
    fbb_.AddOffset(VolatilityTermStructure::VT_QUOTES, quotes);
  }
  explicit VolatilityTermStructureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VolatilityTermStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VolatilityTermStructure>(end);
    fbb_.Required(o, VolatilityTermStructure::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<VolatilityTermStructure> CreateVolatilityTermStructure(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reference_date = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::VolatilityType volatility_type = quantra::enums::VolatilityType_ShiftedLognormal,
    double constant_vol = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityQuote>>> quotes = 0) {
  VolatilityTermStructureBuilder builder_(_fbb);
  builder_.add_constant_vol(constant_vol);
  builder_.add_quotes(quotes);
  builder_.add_reference_date(reference_date);
  builder_.add_id(id);
  builder_.add_volatility_type(volatility_type);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VolatilityTermStructure> CreateVolatilityTermStructureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *reference_date = nullptr,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::VolatilityType volatility_type = quantra::enums::VolatilityType_ShiftedLognormal,
    double constant_vol = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::VolatilityQuote>> *quotes = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto reference_date__ = reference_date ? _fbb.CreateString(reference_date) : 0;
  auto quotes__ = quotes ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VolatilityQuote>>(*quotes) : 0;
  return quantra::CreateVolatilityTermStructure(
      _fbb,
      id__,
      reference_date__,
      calendar,
      business_day_convention,
      day_counter,
      volatility_type,
      constant_vol,
      quotes__);
}

struct ConstantOptionletVolatility FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstantOptionletVolatilityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTLEMENT_DAYS = 4,
    VT_CALENDAR = 6,
    VT_BUSINESS_DAY_CONVENTION = 8,
    VT_VOLATILITY = 10,
    VT_DAY_COUNTER = 12
  };
  int32_t settlement_days() const {
    return GetField<int32_t>(VT_SETTLEMENT_DAYS, 0);
  }
  quantra::enums::Calendar calendar() const {
    return static_cast<quantra::enums::Calendar>(GetField<int8_t>(VT_CALENDAR, 0));
  }
  quantra::enums::BusinessDayConvention business_day_convention() const {
    return static_cast<quantra::enums::BusinessDayConvention>(GetField<int8_t>(VT_BUSINESS_DAY_CONVENTION, 0));
  }
  double volatility() const {
    return GetField<double>(VT_VOLATILITY, 0.0);
  }
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SETTLEMENT_DAYS, 4) &&
           VerifyField<int8_t>(verifier, VT_CALENDAR, 1) &&
           VerifyField<int8_t>(verifier, VT_BUSINESS_DAY_CONVENTION, 1) &&
           VerifyField<double>(verifier, VT_VOLATILITY, 8) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           verifier.EndTable();
  }
};

struct ConstantOptionletVolatilityBuilder {
  typedef ConstantOptionletVolatility Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_settlement_days(int32_t settlement_days) {
    fbb_.AddElement<int32_t>(ConstantOptionletVolatility::VT_SETTLEMENT_DAYS, settlement_days, 0);
  }
  void add_calendar(quantra::enums::Calendar calendar) {
    fbb_.AddElement<int8_t>(ConstantOptionletVolatility::VT_CALENDAR, static_cast<int8_t>(calendar), 0);
  }
  void add_business_day_convention(quantra::enums::BusinessDayConvention business_day_convention) {
    fbb_.AddElement<int8_t>(ConstantOptionletVolatility::VT_BUSINESS_DAY_CONVENTION, static_cast<int8_t>(business_day_convention), 0);
  }
  void add_volatility(double volatility) {
    fbb_.AddElement<double>(ConstantOptionletVolatility::VT_VOLATILITY, volatility, 0.0);
  }
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(ConstantOptionletVolatility::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  explicit ConstantOptionletVolatilityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstantOptionletVolatility> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstantOptionletVolatility>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstantOptionletVolatility> CreateConstantOptionletVolatility(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t settlement_days = 0,
    quantra::enums::Calendar calendar = quantra::enums::Calendar_Argentina,
    quantra::enums::BusinessDayConvention business_day_convention = quantra::enums::BusinessDayConvention_Following,
    double volatility = 0.0,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360) {
  ConstantOptionletVolatilityBuilder builder_(_fbb);
  builder_.add_volatility(volatility);
  builder_.add_settlement_days(settlement_days);
  builder_.add_day_counter(day_counter);
  builder_.add_business_day_convention(business_day_convention);
  builder_.add_calendar(calendar);
  return builder_.Finish();
}

struct BlackIborCouponPricer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlackIborCouponPricerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE = 4,
    VT_OPTIONLET_VOLATILITY_STRUCTURE = 6
  };
  quantra::OptionletVolatilityStructure optionlet_volatility_structure_type() const {
    return static_cast<quantra::OptionletVolatilityStructure>(GetField<uint8_t>(VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE, 0));
  }
  const void *optionlet_volatility_structure() const {
    return GetPointer<const void *>(VT_OPTIONLET_VOLATILITY_STRUCTURE);
  }
  template<typename T> const T *optionlet_volatility_structure_as() const;
  const quantra::ConstantOptionletVolatility *optionlet_volatility_structure_as_ConstantOptionletVolatility() const {
    return optionlet_volatility_structure_type() == quantra::OptionletVolatilityStructure_ConstantOptionletVolatility ? static_cast<const quantra::ConstantOptionletVolatility *>(optionlet_volatility_structure()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE, 1) &&
           VerifyOffset(verifier, VT_OPTIONLET_VOLATILITY_STRUCTURE) &&
           VerifyOptionletVolatilityStructure(verifier, optionlet_volatility_structure(), optionlet_volatility_structure_type()) &&
           verifier.EndTable();
  }
};

template<> inline const quantra::ConstantOptionletVolatility *BlackIborCouponPricer::optionlet_volatility_structure_as<quantra::ConstantOptionletVolatility>() const {
  return optionlet_volatility_structure_as_ConstantOptionletVolatility();
}

struct BlackIborCouponPricerBuilder {
  typedef BlackIborCouponPricer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_optionlet_volatility_structure_type(quantra::OptionletVolatilityStructure optionlet_volatility_structure_type) {
    fbb_.AddElement<uint8_t>(BlackIborCouponPricer::VT_OPTIONLET_VOLATILITY_STRUCTURE_TYPE, static_cast<uint8_t>(optionlet_volatility_structure_type), 0);
  }
  void add_optionlet_volatility_structure(::flatbuffers::Offset<void> optionlet_volatility_structure) {
    fbb_.AddOffset(BlackIborCouponPricer::VT_OPTIONLET_VOLATILITY_STRUCTURE, optionlet_volatility_structure);
  }
  explicit BlackIborCouponPricerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlackIborCouponPricer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlackIborCouponPricer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlackIborCouponPricer> CreateBlackIborCouponPricer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::OptionletVolatilityStructure optionlet_volatility_structure_type = quantra::OptionletVolatilityStructure_NONE,
    ::flatbuffers::Offset<void> optionlet_volatility_structure = 0) {
  BlackIborCouponPricerBuilder builder_(_fbb);
  builder_.add_optionlet_volatility_structure(optionlet_volatility_structure);
  builder_.add_optionlet_volatility_structure_type(optionlet_volatility_structure_type);
  return builder_.Finish();
}

struct CouponPricer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CouponPricerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PRICER_TYPE = 6,
    VT_PRICER = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  quantra::Pricer pricer_type() const {
    return static_cast<quantra::Pricer>(GetField<uint8_t>(VT_PRICER_TYPE, 0));
  }
  const void *pricer() const {
    return GetPointer<const void *>(VT_PRICER);
  }
  template<typename T> const T *pricer_as() const;
  const quantra::BlackIborCouponPricer *pricer_as_BlackIborCouponPricer() const {
    return pricer_type() == quantra::Pricer_BlackIborCouponPricer ? static_cast<const quantra::BlackIborCouponPricer *>(pricer()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_PRICER_TYPE, 1) &&
           VerifyOffset(verifier, VT_PRICER) &&
           VerifyPricer(verifier, pricer(), pricer_type()) &&
           verifier.EndTable();
  }
};

template<> inline const quantra::BlackIborCouponPricer *CouponPricer::pricer_as<quantra::BlackIborCouponPricer>() const {
  return pricer_as_BlackIborCouponPricer();
}

struct CouponPricerBuilder {
  typedef CouponPricer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CouponPricer::VT_ID, id);
  }
  void add_pricer_type(quantra::Pricer pricer_type) {
    fbb_.AddElement<uint8_t>(CouponPricer::VT_PRICER_TYPE, static_cast<uint8_t>(pricer_type), 0);
  }
  void add_pricer(::flatbuffers::Offset<void> pricer) {
    fbb_.AddOffset(CouponPricer::VT_PRICER, pricer);
  }
  explicit CouponPricerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CouponPricer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CouponPricer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CouponPricer> CreateCouponPricer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    quantra::Pricer pricer_type = quantra::Pricer_NONE,
    ::flatbuffers::Offset<void> pricer = 0) {
  CouponPricerBuilder builder_(_fbb);
  builder_.add_pricer(pricer);
  builder_.add_id(id);
  builder_.add_pricer_type(pricer_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CouponPricer> CreateCouponPricerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    quantra::Pricer pricer_type = quantra::Pricer_NONE,
    ::flatbuffers::Offset<void> pricer = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return quantra::CreateCouponPricer(
      _fbb,
      id__,
      pricer_type,
      pricer);
}

struct Yield FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef YieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DAY_COUNTER = 4,
    VT_COMPOUNDING = 6,
    VT_FREQUENCY = 8
  };
  quantra::enums::DayCounter day_counter() const {
    return static_cast<quantra::enums::DayCounter>(GetField<int8_t>(VT_DAY_COUNTER, 0));
  }
  quantra::enums::Compounding compounding() const {
    return static_cast<quantra::enums::Compounding>(GetField<int8_t>(VT_COMPOUNDING, 0));
  }
  quantra::enums::Frequency frequency() const {
    return static_cast<quantra::enums::Frequency>(GetField<int8_t>(VT_FREQUENCY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DAY_COUNTER, 1) &&
           VerifyField<int8_t>(verifier, VT_COMPOUNDING, 1) &&
           VerifyField<int8_t>(verifier, VT_FREQUENCY, 1) &&
           verifier.EndTable();
  }
};

struct YieldBuilder {
  typedef Yield Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_day_counter(quantra::enums::DayCounter day_counter) {
    fbb_.AddElement<int8_t>(Yield::VT_DAY_COUNTER, static_cast<int8_t>(day_counter), 0);
  }
  void add_compounding(quantra::enums::Compounding compounding) {
    fbb_.AddElement<int8_t>(Yield::VT_COMPOUNDING, static_cast<int8_t>(compounding), 0);
  }
  void add_frequency(quantra::enums::Frequency frequency) {
    fbb_.AddElement<int8_t>(Yield::VT_FREQUENCY, static_cast<int8_t>(frequency), 0);
  }
  explicit YieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Yield> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Yield>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Yield> CreateYield(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::enums::DayCounter day_counter = quantra::enums::DayCounter_Actual360,
    quantra::enums::Compounding compounding = quantra::enums::Compounding_Compounded,
    quantra::enums::Frequency frequency = quantra::enums::Frequency_Annual) {
  YieldBuilder builder_(_fbb);
  builder_.add_frequency(frequency);
  builder_.add_compounding(compounding);
  builder_.add_day_counter(day_counter);
  return builder_.Finish();
}

struct Pricing FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PricingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AS_OF_DATE = 4,
    VT_SETTLEMENT_DATE = 6,
    VT_CURVES = 8,
    VT_VOLATILITIES = 10,
    VT_BOND_PRICING_DETAILS = 12,
    VT_BOND_PRICING_FLOWS = 14,
    VT_COUPON_PRICERS = 16
  };
  const ::flatbuffers::String *as_of_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AS_OF_DATE);
  }
  const ::flatbuffers::String *settlement_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTLEMENT_DATE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>> *curves() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>> *>(VT_CURVES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityTermStructure>> *volatilities() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityTermStructure>> *>(VT_VOLATILITIES);
  }
  bool bond_pricing_details() const {
    return GetField<uint8_t>(VT_BOND_PRICING_DETAILS, 0) != 0;
  }
  bool bond_pricing_flows() const {
    return GetField<uint8_t>(VT_BOND_PRICING_FLOWS, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>> *coupon_pricers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>> *>(VT_COUPON_PRICERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_AS_OF_DATE) &&
           verifier.VerifyString(as_of_date()) &&
           VerifyOffsetRequired(verifier, VT_SETTLEMENT_DATE) &&
           verifier.VerifyString(settlement_date()) &&
           VerifyOffsetRequired(verifier, VT_CURVES) &&
           verifier.VerifyVector(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           VerifyOffset(verifier, VT_VOLATILITIES) &&
           verifier.VerifyVector(volatilities()) &&
           verifier.VerifyVectorOfTables(volatilities()) &&
           VerifyField<uint8_t>(verifier, VT_BOND_PRICING_DETAILS, 1) &&
           VerifyField<uint8_t>(verifier, VT_BOND_PRICING_FLOWS, 1) &&
           VerifyOffset(verifier, VT_COUPON_PRICERS) &&
           verifier.VerifyVector(coupon_pricers()) &&
           verifier.VerifyVectorOfTables(coupon_pricers()) &&
           verifier.EndTable();
  }
};

struct PricingBuilder {
  typedef Pricing Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_as_of_date(::flatbuffers::Offset<::flatbuffers::String> as_of_date) {
    fbb_.AddOffset(Pricing::VT_AS_OF_DATE, as_of_date);
  }
  void add_settlement_date(::flatbuffers::Offset<::flatbuffers::String> settlement_date) {
    fbb_.AddOffset(Pricing::VT_SETTLEMENT_DATE, settlement_date);
  }
  void add_curves(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>>> curves) {
    fbb_.AddOffset(Pricing::VT_CURVES, curves);
  }
  void add_volatilities(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityTermStructure>>> volatilities) {
    fbb_.AddOffset(Pricing::VT_VOLATILITIES, volatilities);
  }
  void add_bond_pricing_details(bool bond_pricing_details) {
    fbb_.AddElement<uint8_t>(Pricing::VT_BOND_PRICING_DETAILS, static_cast<uint8_t>(bond_pricing_details), 0);
  }
  void add_bond_pricing_flows(bool bond_pricing_flows) {
    fbb_.AddElement<uint8_t>(Pricing::VT_BOND_PRICING_FLOWS, static_cast<uint8_t>(bond_pricing_flows), 0);
  }
  void add_coupon_pricers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>>> coupon_pricers) {
    fbb_.AddOffset(Pricing::VT_COUPON_PRICERS, coupon_pricers);
  }
  explicit PricingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pricing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pricing>(end);
    fbb_.Required(o, Pricing::VT_AS_OF_DATE);
    fbb_.Required(o, Pricing::VT_SETTLEMENT_DATE);
    fbb_.Required(o, Pricing::VT_CURVES);
    return o;
  }
};

inline ::flatbuffers::Offset<Pricing> CreatePricing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> as_of_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> settlement_date = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::TermStructure>>> curves = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VolatilityTermStructure>>> volatilities = 0,
    bool bond_pricing_details = false,
    bool bond_pricing_flows = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::CouponPricer>>> coupon_pricers = 0) {
  PricingBuilder builder_(_fbb);
  builder_.add_coupon_pricers(coupon_pricers);
  builder_.add_volatilities(volatilities);
  builder_.add_curves(curves);
  builder_.add_settlement_date(settlement_date);
  builder_.add_as_of_date(as_of_date);
  builder_.add_bond_pricing_flows(bond_pricing_flows);
  builder_.add_bond_pricing_details(bond_pricing_details);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Pricing> CreatePricingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *as_of_date = nullptr,
    const char *settlement_date = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::TermStructure>> *curves = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::VolatilityTermStructure>> *volatilities = nullptr,
    bool bond_pricing_details = false,
    bool bond_pricing_flows = false,
    const std::vector<::flatbuffers::Offset<quantra::CouponPricer>> *coupon_pricers = nullptr) {
  auto as_of_date__ = as_of_date ? _fbb.CreateString(as_of_date) : 0;
  auto settlement_date__ = settlement_date ? _fbb.CreateString(settlement_date) : 0;
  auto curves__ = curves ? _fbb.CreateVector<::flatbuffers::Offset<quantra::TermStructure>>(*curves) : 0;
  auto volatilities__ = volatilities ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VolatilityTermStructure>>(*volatilities) : 0;
  auto coupon_pricers__ = coupon_pricers ? _fbb.CreateVector<::flatbuffers::Offset<quantra::CouponPricer>>(*coupon_pricers) : 0;
  return quantra::CreatePricing(
      _fbb,
      as_of_date__,
      settlement_date__,
      curves__,
      volatilities__,
      bond_pricing_details,
      bond_pricing_flows,
      coupon_pricers__);
}

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_MESSAGE = 4
  };
  const ::flatbuffers::String *error_message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_message(::flatbuffers::Offset<::flatbuffers::String> error_message) {
    fbb_.AddOffset(Error::VT_ERROR_MESSAGE, error_message);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> error_message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return quantra::CreateError(
      _fbb,
      error_message__);
}

struct FlowInterest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
};

struct FlowInterestBuilder {
  typedef FlowInterest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterest::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterest::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterest::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowInterest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowInterest> CreateFlowInterestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

struct FlowInterestFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_DISCOUNT = 12,
    VT_RATE = 14,
    VT_PRICE = 16
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
};

struct FlowInterestFloatBuilder {
  typedef FlowInterestFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_DISCOUNT, discount, 0.0f);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_RATE, rate, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowInterestFloat::VT_PRICE, price, 0.0f);
  }
  explicit FlowInterestFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowInterestFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  FlowInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_rate(rate);
  builder_.add_discount(discount);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowInterestFloat> CreateFlowInterestFloatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float discount = 0.0f,
    float rate = 0.0f,
    float price = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      discount,
      rate,
      price);
}

struct FlowPastInterestFloat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowPastInterestFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           verifier.EndTable();
  }
};

struct FlowPastInterestFloatBuilder {
  typedef FlowPastInterestFloat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterestFloat::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterestFloat::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterestFloat::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestFloatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowPastInterestFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowPastInterestFloat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestFloatBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowPastInterestFloat> CreateFlowPastInterestFloatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterestFloat(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

struct FlowPastInterest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowPastInterestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AMOUNT = 4,
    VT_FIXING_DATE = 6,
    VT_ACCRUAL_START_DATE = 8,
    VT_ACCRUAL_END_DATE = 10,
    VT_RATE = 12
  };
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  float rate() const {
    return GetField<float>(VT_RATE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<float>(verifier, VT_RATE, 4) &&
           verifier.EndTable();
  }
};

struct FlowPastInterestBuilder {
  typedef FlowPastInterest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowPastInterest::VT_AMOUNT, amount, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(FlowPastInterest::VT_FIXING_DATE, fixing_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(FlowPastInterest::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_rate(float rate) {
    fbb_.AddElement<float>(FlowPastInterest::VT_RATE, rate, 0.0f);
  }
  explicit FlowPastInterestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowPastInterest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowPastInterest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    float rate = 0.0f) {
  FlowPastInterestBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_rate(rate);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_fixing_date(fixing_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowPastInterest> CreateFlowPastInterestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double amount = 0.0,
    const char *fixing_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    float rate = 0.0f) {
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  return quantra::CreateFlowPastInterest(
      _fbb,
      amount,
      fixing_date__,
      accrual_start_date__,
      accrual_end_date__,
      rate);
}

struct FlowNotional FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowNotionalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_AMOUNT = 6,
    VT_DISCOUNT = 8,
    VT_PRICE = 10
  };
  const ::flatbuffers::String *date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  float discount() const {
    return GetField<float>(VT_DISCOUNT, 0.0f);
  }
  float price() const {
    return GetField<float>(VT_PRICE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyField<float>(verifier, VT_DISCOUNT, 4) &&
           VerifyField<float>(verifier, VT_PRICE, 4) &&
           verifier.EndTable();
  }
};

struct FlowNotionalBuilder {
  typedef FlowNotional Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_date(::flatbuffers::Offset<::flatbuffers::String> date) {
    fbb_.AddOffset(FlowNotional::VT_DATE, date);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(FlowNotional::VT_AMOUNT, amount, 0.0);
  }
  void add_discount(float discount) {
    fbb_.AddElement<float>(FlowNotional::VT_DISCOUNT, discount, 0.0f);
  }
  void add_price(float price) {
    fbb_.AddElement<float>(FlowNotional::VT_PRICE, price, 0.0f);
  }
  explicit FlowNotionalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowNotional> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowNotional>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotional(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> date = 0,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  FlowNotionalBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_price(price);
  builder_.add_discount(discount);
  builder_.add_date(date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlowNotional> CreateFlowNotionalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *date = nullptr,
    double amount = 0.0,
    float discount = 0.0f,
    float price = 0.0f) {
  auto date__ = date ? _fbb.CreateString(date) : 0;
  return quantra::CreateFlowNotional(
      _fbb,
      date__,
      amount,
      discount,
      price);
}

struct FlowsWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlowsWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOW_TYPE = 4,
    VT_FLOW = 6
  };
  quantra::Flow flow_type() const {
    return static_cast<quantra::Flow>(GetField<uint8_t>(VT_FLOW_TYPE, 0));
  }
  const void *flow() const {
    return GetPointer<const void *>(VT_FLOW);
  }
  template<typename T> const T *flow_as() const;
  const quantra::FlowInterest *flow_as_FlowInterest() const {
    return flow_type() == quantra::Flow_FlowInterest ? static_cast<const quantra::FlowInterest *>(flow()) : nullptr;
  }
  const quantra::FlowPastInterest *flow_as_FlowPastInterest() const {
    return flow_type() == quantra::Flow_FlowPastInterest ? static_cast<const quantra::FlowPastInterest *>(flow()) : nullptr;
  }
  const quantra::FlowNotional *flow_as_FlowNotional() const {
    return flow_type() == quantra::Flow_FlowNotional ? static_cast<const quantra::FlowNotional *>(flow()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLOW_TYPE, 1) &&
           VerifyOffset(verifier, VT_FLOW) &&
           VerifyFlow(verifier, flow(), flow_type()) &&
           verifier.EndTable();
  }
};

template<> inline const quantra::FlowInterest *FlowsWrapper::flow_as<quantra::FlowInterest>() const {
  return flow_as_FlowInterest();
}

template<> inline const quantra::FlowPastInterest *FlowsWrapper::flow_as<quantra::FlowPastInterest>() const {
  return flow_as_FlowPastInterest();
}

template<> inline const quantra::FlowNotional *FlowsWrapper::flow_as<quantra::FlowNotional>() const {
  return flow_as_FlowNotional();
}

struct FlowsWrapperBuilder {
  typedef FlowsWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flow_type(quantra::Flow flow_type) {
    fbb_.AddElement<uint8_t>(FlowsWrapper::VT_FLOW_TYPE, static_cast<uint8_t>(flow_type), 0);
  }
  void add_flow(::flatbuffers::Offset<void> flow) {
    fbb_.AddOffset(FlowsWrapper::VT_FLOW, flow);
  }
  explicit FlowsWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlowsWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlowsWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlowsWrapper> CreateFlowsWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    quantra::Flow flow_type = quantra::Flow_NONE,
    ::flatbuffers::Offset<void> flow = 0) {
  FlowsWrapperBuilder builder_(_fbb);
  builder_.add_flow(flow);
  builder_.add_flow_type(flow_type);
  return builder_.Finish();
}

struct SwapLegFlow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapLegFlowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYMENT_DATE = 4,
    VT_ACCRUAL_START_DATE = 6,
    VT_ACCRUAL_END_DATE = 8,
    VT_AMOUNT = 10,
    VT_DISCOUNT = 12,
    VT_PRESENT_VALUE = 14,
    VT_FIXING_DATE = 16,
    VT_INDEX_FIXING = 18,
    VT_SPREAD = 20,
    VT_RATE = 22
  };
  const ::flatbuffers::String *payment_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_DATE);
  }
  const ::flatbuffers::String *accrual_start_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_START_DATE);
  }
  const ::flatbuffers::String *accrual_end_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCRUAL_END_DATE);
  }
  double amount() const {
    return GetField<double>(VT_AMOUNT, 0.0);
  }
  double discount() const {
    return GetField<double>(VT_DISCOUNT, 0.0);
  }
  double present_value() const {
    return GetField<double>(VT_PRESENT_VALUE, 0.0);
  }
  const ::flatbuffers::String *fixing_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIXING_DATE);
  }
  double index_fixing() const {
    return GetField<double>(VT_INDEX_FIXING, 0.0);
  }
  double spread() const {
    return GetField<double>(VT_SPREAD, 0.0);
  }
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYMENT_DATE) &&
           verifier.VerifyString(payment_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_START_DATE) &&
           verifier.VerifyString(accrual_start_date()) &&
           VerifyOffset(verifier, VT_ACCRUAL_END_DATE) &&
           verifier.VerifyString(accrual_end_date()) &&
           VerifyField<double>(verifier, VT_AMOUNT, 8) &&
           VerifyField<double>(verifier, VT_DISCOUNT, 8) &&
           VerifyField<double>(verifier, VT_PRESENT_VALUE, 8) &&
           VerifyOffset(verifier, VT_FIXING_DATE) &&
           verifier.VerifyString(fixing_date()) &&
           VerifyField<double>(verifier, VT_INDEX_FIXING, 8) &&
           VerifyField<double>(verifier, VT_SPREAD, 8) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           verifier.EndTable();
  }
};

struct SwapLegFlowBuilder {
  typedef SwapLegFlow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payment_date(::flatbuffers::Offset<::flatbuffers::String> payment_date) {
    fbb_.AddOffset(SwapLegFlow::VT_PAYMENT_DATE, payment_date);
  }
  void add_accrual_start_date(::flatbuffers::Offset<::flatbuffers::String> accrual_start_date) {
    fbb_.AddOffset(SwapLegFlow::VT_ACCRUAL_START_DATE, accrual_start_date);
  }
  void add_accrual_end_date(::flatbuffers::Offset<::flatbuffers::String> accrual_end_date) {
    fbb_.AddOffset(SwapLegFlow::VT_ACCRUAL_END_DATE, accrual_end_date);
  }
  void add_amount(double amount) {
    fbb_.AddElement<double>(SwapLegFlow::VT_AMOUNT, amount, 0.0);
  }
  void add_discount(double discount) {
    fbb_.AddElement<double>(SwapLegFlow::VT_DISCOUNT, discount, 0.0);
  }
  void add_present_value(double present_value) {
    fbb_.AddElement<double>(SwapLegFlow::VT_PRESENT_VALUE, present_value, 0.0);
  }
  void add_fixing_date(::flatbuffers::Offset<::flatbuffers::String> fixing_date) {
    fbb_.AddOffset(SwapLegFlow::VT_FIXING_DATE, fixing_date);
  }
  void add_index_fixing(double index_fixing) {
    fbb_.AddElement<double>(SwapLegFlow::VT_INDEX_FIXING, index_fixing, 0.0);
  }
  void add_spread(double spread) {
    fbb_.AddElement<double>(SwapLegFlow::VT_SPREAD, spread, 0.0);
  }
  void add_rate(double rate) {
    fbb_.AddElement<double>(SwapLegFlow::VT_RATE, rate, 0.0);
  }
  explicit SwapLegFlowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapLegFlow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapLegFlow>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> payment_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_start_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> accrual_end_date = 0,
    double amount = 0.0,
    double discount = 0.0,
    double present_value = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> fixing_date = 0,
    double index_fixing = 0.0,
    double spread = 0.0,
    double rate = 0.0) {
  SwapLegFlowBuilder builder_(_fbb);
  builder_.add_rate(rate);
  builder_.add_spread(spread);
  builder_.add_index_fixing(index_fixing);
  builder_.add_present_value(present_value);
  builder_.add_discount(discount);
  builder_.add_amount(amount);
  builder_.add_fixing_date(fixing_date);
  builder_.add_accrual_end_date(accrual_end_date);
  builder_.add_accrual_start_date(accrual_start_date);
  builder_.add_payment_date(payment_date);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapLegFlow> CreateSwapLegFlowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *payment_date = nullptr,
    const char *accrual_start_date = nullptr,
    const char *accrual_end_date = nullptr,
    double amount = 0.0,
    double discount = 0.0,
    double present_value = 0.0,
    const char *fixing_date = nullptr,
    double index_fixing = 0.0,
    double spread = 0.0,
    double rate = 0.0) {
  auto payment_date__ = payment_date ? _fbb.CreateString(payment_date) : 0;
  auto accrual_start_date__ = accrual_start_date ? _fbb.CreateString(accrual_start_date) : 0;
  auto accrual_end_date__ = accrual_end_date ? _fbb.CreateString(accrual_end_date) : 0;
  auto fixing_date__ = fixing_date ? _fbb.CreateString(fixing_date) : 0;
  return quantra::CreateSwapLegFlow(
      _fbb,
      payment_date__,
      accrual_start_date__,
      accrual_end_date__,
      amount,
      discount,
      present_value,
      fixing_date__,
      index_fixing,
      spread,
      rate);
}

struct SwapLegResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SwapLegResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_BPS = 6,
    VT_FLOWS = 8
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double bps() const {
    return GetField<double>(VT_BPS, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FLOWS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_BPS, 8) &&
           VerifyOffset(verifier, VT_FLOWS) &&
           verifier.VerifyVector(flows()) &&
           verifier.VerifyVectorOfTables(flows()) &&
           verifier.EndTable();
  }
};

struct SwapLegResponseBuilder {
  typedef SwapLegResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(SwapLegResponse::VT_NPV, npv, 0.0);
  }
  void add_bps(double bps) {
    fbb_.AddElement<double>(SwapLegResponse::VT_BPS, bps, 0.0);
  }
  void add_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> flows) {
    fbb_.AddOffset(SwapLegResponse::VT_FLOWS, flows);
  }
  explicit SwapLegResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SwapLegResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SwapLegResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double bps = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> flows = 0) {
  SwapLegResponseBuilder builder_(_fbb);
  builder_.add_bps(bps);
  builder_.add_npv(npv);
  builder_.add_flows(flows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SwapLegResponse> CreateSwapLegResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double bps = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *flows = nullptr) {
  auto flows__ = flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*flows) : 0;
  return quantra::CreateSwapLegResponse(
      _fbb,
      npv,
      bps,
      flows__);
}

struct VanillaSwapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VanillaSwapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NPV = 4,
    VT_FAIR_RATE = 6,
    VT_FAIR_SPREAD = 8,
    VT_FIXED_LEG_BPS = 10,
    VT_FLOATING_LEG_BPS = 12,
    VT_FIXED_LEG_NPV = 14,
    VT_FLOATING_LEG_NPV = 16,
    VT_FIXED_LEG_FLOWS = 18,
    VT_FLOATING_LEG_FLOWS = 20
  };
  double npv() const {
    return GetField<double>(VT_NPV, 0.0);
  }
  double fair_rate() const {
    return GetField<double>(VT_FAIR_RATE, 0.0);
  }
  double fair_spread() const {
    return GetField<double>(VT_FAIR_SPREAD, 0.0);
  }
  double fixed_leg_bps() const {
    return GetField<double>(VT_FIXED_LEG_BPS, 0.0);
  }
  double floating_leg_bps() const {
    return GetField<double>(VT_FLOATING_LEG_BPS, 0.0);
  }
  double fixed_leg_npv() const {
    return GetField<double>(VT_FIXED_LEG_NPV, 0.0);
  }
  double floating_leg_npv() const {
    return GetField<double>(VT_FLOATING_LEG_NPV, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *fixed_leg_flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FIXED_LEG_FLOWS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *floating_leg_flows() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *>(VT_FLOATING_LEG_FLOWS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NPV, 8) &&
           VerifyField<double>(verifier, VT_FAIR_RATE, 8) &&
           VerifyField<double>(verifier, VT_FAIR_SPREAD, 8) &&
           VerifyField<double>(verifier, VT_FIXED_LEG_BPS, 8) &&
           VerifyField<double>(verifier, VT_FLOATING_LEG_BPS, 8) &&
           VerifyField<double>(verifier, VT_FIXED_LEG_NPV, 8) &&
           VerifyField<double>(verifier, VT_FLOATING_LEG_NPV, 8) &&
           VerifyOffset(verifier, VT_FIXED_LEG_FLOWS) &&
           verifier.VerifyVector(fixed_leg_flows()) &&
           verifier.VerifyVectorOfTables(fixed_leg_flows()) &&
           VerifyOffset(verifier, VT_FLOATING_LEG_FLOWS) &&
           verifier.VerifyVector(floating_leg_flows()) &&
           verifier.VerifyVectorOfTables(floating_leg_flows()) &&
           verifier.EndTable();
  }
};

struct VanillaSwapResponseBuilder {
  typedef VanillaSwapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_npv(double npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_NPV, npv, 0.0);
  }
  void add_fair_rate(double fair_rate) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FAIR_RATE, fair_rate, 0.0);
  }
  void add_fair_spread(double fair_spread) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FAIR_SPREAD, fair_spread, 0.0);
  }
  void add_fixed_leg_bps(double fixed_leg_bps) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FIXED_LEG_BPS, fixed_leg_bps, 0.0);
  }
  void add_floating_leg_bps(double floating_leg_bps) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FLOATING_LEG_BPS, floating_leg_bps, 0.0);
  }
  void add_fixed_leg_npv(double fixed_leg_npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FIXED_LEG_NPV, fixed_leg_npv, 0.0);
  }
  void add_floating_leg_npv(double floating_leg_npv) {
    fbb_.AddElement<double>(VanillaSwapResponse::VT_FLOATING_LEG_NPV, floating_leg_npv, 0.0);
  }
  void add_fixed_leg_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> fixed_leg_flows) {
    fbb_.AddOffset(VanillaSwapResponse::VT_FIXED_LEG_FLOWS, fixed_leg_flows);
  }
  void add_floating_leg_flows(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> floating_leg_flows) {
    fbb_.AddOffset(VanillaSwapResponse::VT_FLOATING_LEG_FLOWS, floating_leg_flows);
  }
  explicit VanillaSwapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VanillaSwapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VanillaSwapResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double fair_rate = 0.0,
    double fair_spread = 0.0,
    double fixed_leg_bps = 0.0,
    double floating_leg_bps = 0.0,
    double fixed_leg_npv = 0.0,
    double floating_leg_npv = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> fixed_leg_flows = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::SwapLegFlow>>> floating_leg_flows = 0) {
  VanillaSwapResponseBuilder builder_(_fbb);
  builder_.add_floating_leg_npv(floating_leg_npv);
  builder_.add_fixed_leg_npv(fixed_leg_npv);
  builder_.add_floating_leg_bps(floating_leg_bps);
  builder_.add_fixed_leg_bps(fixed_leg_bps);
  builder_.add_fair_spread(fair_spread);
  builder_.add_fair_rate(fair_rate);
  builder_.add_npv(npv);
  builder_.add_floating_leg_flows(floating_leg_flows);
  builder_.add_fixed_leg_flows(fixed_leg_flows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VanillaSwapResponse> CreateVanillaSwapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double npv = 0.0,
    double fair_rate = 0.0,
    double fair_spread = 0.0,
    double fixed_leg_bps = 0.0,
    double floating_leg_bps = 0.0,
    double fixed_leg_npv = 0.0,
    double floating_leg_npv = 0.0,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *fixed_leg_flows = nullptr,
    const std::vector<::flatbuffers::Offset<quantra::SwapLegFlow>> *floating_leg_flows = nullptr) {
  auto fixed_leg_flows__ = fixed_leg_flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*fixed_leg_flows) : 0;
  auto floating_leg_flows__ = floating_leg_flows ? _fbb.CreateVector<::flatbuffers::Offset<quantra::SwapLegFlow>>(*floating_leg_flows) : 0;
  return quantra::CreateVanillaSwapResponse(
      _fbb,
      npv,
      fair_rate,
      fair_spread,
      fixed_leg_bps,
      floating_leg_bps,
      fixed_leg_npv,
      floating_leg_npv,
      fixed_leg_flows__,
      floating_leg_flows__);
}

struct PriceVanillaSwapResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriceVanillaSwapResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SWAPS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *swaps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *>(VT_SWAPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SWAPS) &&
           verifier.VerifyVector(swaps()) &&
           verifier.VerifyVectorOfTables(swaps()) &&
           verifier.EndTable();
  }
};

struct PriceVanillaSwapResponseBuilder {
  typedef PriceVanillaSwapResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_swaps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>> swaps) {
    fbb_.AddOffset(PriceVanillaSwapResponse::VT_SWAPS, swaps);
  }
  explicit PriceVanillaSwapResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriceVanillaSwapResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriceVanillaSwapResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>> swaps = 0) {
  PriceVanillaSwapResponseBuilder builder_(_fbb);
  builder_.add_swaps(swaps);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PriceVanillaSwapResponse> CreatePriceVanillaSwapResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<quantra::VanillaSwapResponse>> *swaps = nullptr) {
  auto swaps__ = swaps ? _fbb.CreateVector<::flatbuffers::Offset<quantra::VanillaSwapResponse>>(*swaps) : 0;
  return quantra::CreatePriceVanillaSwapResponse(
      _fbb,
      swaps__);
}

inline bool VerifyPoint(::flatbuffers::Verifier &verifier, const void *obj, Point type) {
  switch (type) {
    case Point_NONE: {
      return true;
    }
    case Point_DepositHelper: {
      auto ptr = reinterpret_cast<const quantra::DepositHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FRAHelper: {
      auto ptr = reinterpret_cast<const quantra::FRAHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_FutureHelper: {
      auto ptr = reinterpret_cast<const quantra::FutureHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_SwapHelper: {
      auto ptr = reinterpret_cast<const quantra::SwapHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Point_BondHelper: {
      auto ptr = reinterpret_cast<const quantra::BondHelper *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPointVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPoint(
        verifier,  values->Get(i), types->GetEnum<Point>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyOptionletVolatilityStructure(::flatbuffers::Verifier &verifier, const void *obj, OptionletVolatilityStructure type) {
  switch (type) {
    case OptionletVolatilityStructure_NONE: {
      return true;
    }
    case OptionletVolatilityStructure_ConstantOptionletVolatility: {
      auto ptr = reinterpret_cast<const quantra::ConstantOptionletVolatility *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOptionletVolatilityStructureVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOptionletVolatilityStructure(
        verifier,  values->Get(i), types->GetEnum<OptionletVolatilityStructure>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyPricer(::flatbuffers::Verifier &verifier, const void *obj, Pricer type) {
  switch (type) {
    case Pricer_NONE: {
      return true;
    }
    case Pricer_BlackIborCouponPricer: {
      auto ptr = reinterpret_cast<const quantra::BlackIborCouponPricer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPricerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPricer(
        verifier,  values->Get(i), types->GetEnum<Pricer>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyFlow(::flatbuffers::Verifier &verifier, const void *obj, Flow type) {
  switch (type) {
    case Flow_NONE: {
      return true;
    }
    case Flow_FlowInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowPastInterest: {
      auto ptr = reinterpret_cast<const quantra::FlowPastInterest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Flow_FlowNotional: {
      auto ptr = reinterpret_cast<const quantra::FlowNotional *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFlowVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFlow(
        verifier,  values->Get(i), types->GetEnum<Flow>(i))) {
      return false;
    }
  }
  return true;
}

inline const quantra::PriceVanillaSwapResponse *GetPriceVanillaSwapResponse(const void *buf) {
  return ::flatbuffers::GetRoot<quantra::PriceVanillaSwapResponse>(buf);
}

inline const quantra::PriceVanillaSwapResponse *GetSizePrefixedPriceVanillaSwapResponse(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<quantra::PriceVanillaSwapResponse>(buf);
}

inline bool VerifyPriceVanillaSwapResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<quantra::PriceVanillaSwapResponse>(nullptr);
}

inline bool VerifySizePrefixedPriceVanillaSwapResponseBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<quantra::PriceVanillaSwapResponse>(nullptr);
}

inline void FinishPriceVanillaSwapResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceVanillaSwapResponse> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPriceVanillaSwapResponseBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<quantra::PriceVanillaSwapResponse> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace quantra

#endif  // FLATBUFFERS_GENERATED_VANILLASWAPRESPONSE_QUANTRA_H_
