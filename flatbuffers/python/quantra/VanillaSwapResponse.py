# automatically generated by the FlatBuffers compiler, do not modify

# namespace: quantra

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class VanillaSwapResponse(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = VanillaSwapResponse()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsVanillaSwapResponse(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # VanillaSwapResponse
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # VanillaSwapResponse
    def Npv(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # VanillaSwapResponse
    def FairRate(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # VanillaSwapResponse
    def FairSpread(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # VanillaSwapResponse
    def FixedLegBps(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # VanillaSwapResponse
    def FloatingLegBps(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # VanillaSwapResponse
    def FixedLegNpv(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # VanillaSwapResponse
    def FloatingLegNpv(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # VanillaSwapResponse
    def FixedLegFlows(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.SwapLegFlow import SwapLegFlow
            obj = SwapLegFlow()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # VanillaSwapResponse
    def FixedLegFlowsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # VanillaSwapResponse
    def FixedLegFlowsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # VanillaSwapResponse
    def FloatingLegFlows(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = SwapLegFlow()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # VanillaSwapResponse
    def FloatingLegFlowsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # VanillaSwapResponse
    def FloatingLegFlowsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

def VanillaSwapResponseStart(builder):
    builder.StartObject(9)

def Start(builder):
    VanillaSwapResponseStart(builder)

def VanillaSwapResponseAddNpv(builder, npv):
    builder.PrependFloat64Slot(0, npv, 0.0)

def AddNpv(builder, npv):
    VanillaSwapResponseAddNpv(builder, npv)

def VanillaSwapResponseAddFairRate(builder, fairRate):
    builder.PrependFloat64Slot(1, fairRate, 0.0)

def AddFairRate(builder, fairRate):
    VanillaSwapResponseAddFairRate(builder, fairRate)

def VanillaSwapResponseAddFairSpread(builder, fairSpread):
    builder.PrependFloat64Slot(2, fairSpread, 0.0)

def AddFairSpread(builder, fairSpread):
    VanillaSwapResponseAddFairSpread(builder, fairSpread)

def VanillaSwapResponseAddFixedLegBps(builder, fixedLegBps):
    builder.PrependFloat64Slot(3, fixedLegBps, 0.0)

def AddFixedLegBps(builder, fixedLegBps):
    VanillaSwapResponseAddFixedLegBps(builder, fixedLegBps)

def VanillaSwapResponseAddFloatingLegBps(builder, floatingLegBps):
    builder.PrependFloat64Slot(4, floatingLegBps, 0.0)

def AddFloatingLegBps(builder, floatingLegBps):
    VanillaSwapResponseAddFloatingLegBps(builder, floatingLegBps)

def VanillaSwapResponseAddFixedLegNpv(builder, fixedLegNpv):
    builder.PrependFloat64Slot(5, fixedLegNpv, 0.0)

def AddFixedLegNpv(builder, fixedLegNpv):
    VanillaSwapResponseAddFixedLegNpv(builder, fixedLegNpv)

def VanillaSwapResponseAddFloatingLegNpv(builder, floatingLegNpv):
    builder.PrependFloat64Slot(6, floatingLegNpv, 0.0)

def AddFloatingLegNpv(builder, floatingLegNpv):
    VanillaSwapResponseAddFloatingLegNpv(builder, floatingLegNpv)

def VanillaSwapResponseAddFixedLegFlows(builder, fixedLegFlows):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(fixedLegFlows), 0)

def AddFixedLegFlows(builder, fixedLegFlows):
    VanillaSwapResponseAddFixedLegFlows(builder, fixedLegFlows)

def VanillaSwapResponseStartFixedLegFlowsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartFixedLegFlowsVector(builder, numElems):
    return VanillaSwapResponseStartFixedLegFlowsVector(builder, numElems)

def VanillaSwapResponseAddFloatingLegFlows(builder, floatingLegFlows):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(floatingLegFlows), 0)

def AddFloatingLegFlows(builder, floatingLegFlows):
    VanillaSwapResponseAddFloatingLegFlows(builder, floatingLegFlows)

def VanillaSwapResponseStartFloatingLegFlowsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartFloatingLegFlowsVector(builder, numElems):
    return VanillaSwapResponseStartFloatingLegFlowsVector(builder, numElems)

def VanillaSwapResponseEnd(builder):
    return builder.EndObject()

def End(builder):
    return VanillaSwapResponseEnd(builder)

try:
    from typing import List
except:
    pass

class VanillaSwapResponseT(object):

    # VanillaSwapResponseT
    def __init__(self):
        self.npv = 0.0  # type: float
        self.fairRate = 0.0  # type: float
        self.fairSpread = 0.0  # type: float
        self.fixedLegBps = 0.0  # type: float
        self.floatingLegBps = 0.0  # type: float
        self.fixedLegNpv = 0.0  # type: float
        self.floatingLegNpv = 0.0  # type: float
        self.fixedLegFlows = None  # type: List[SwapLegFlowT]
        self.floatingLegFlows = None  # type: List[SwapLegFlowT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        vanillaSwapResponse = VanillaSwapResponse()
        vanillaSwapResponse.Init(buf, pos)
        return cls.InitFromObj(vanillaSwapResponse)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, vanillaSwapResponse):
        x = VanillaSwapResponseT()
        x._UnPack(vanillaSwapResponse)
        return x

    # VanillaSwapResponseT
    def _UnPack(self, vanillaSwapResponse):
        if vanillaSwapResponse is None:
            return
        self.npv = vanillaSwapResponse.Npv()
        self.fairRate = vanillaSwapResponse.FairRate()
        self.fairSpread = vanillaSwapResponse.FairSpread()
        self.fixedLegBps = vanillaSwapResponse.FixedLegBps()
        self.floatingLegBps = vanillaSwapResponse.FloatingLegBps()
        self.fixedLegNpv = vanillaSwapResponse.FixedLegNpv()
        self.floatingLegNpv = vanillaSwapResponse.FloatingLegNpv()
        if not vanillaSwapResponse.FixedLegFlowsIsNone():
            self.fixedLegFlows = []
            for i in range(vanillaSwapResponse.FixedLegFlowsLength()):
                if vanillaSwapResponse.FixedLegFlows(i) is None:
                    self.fixedLegFlows.append(None)
                else:
                    swapLegFlow_ = SwapLegFlowT.InitFromObj(vanillaSwapResponse.FixedLegFlows(i))
                    self.fixedLegFlows.append(swapLegFlow_)
        if not vanillaSwapResponse.FloatingLegFlowsIsNone():
            self.floatingLegFlows = []
            for i in range(vanillaSwapResponse.FloatingLegFlowsLength()):
                if vanillaSwapResponse.FloatingLegFlows(i) is None:
                    self.floatingLegFlows.append(None)
                else:
                    swapLegFlow_ = SwapLegFlowT.InitFromObj(vanillaSwapResponse.FloatingLegFlows(i))
                    self.floatingLegFlows.append(swapLegFlow_)

    # VanillaSwapResponseT
    def Pack(self, builder):
        if self.fixedLegFlows is not None:
            fixedLegFlowslist = []
            for i in range(len(self.fixedLegFlows)):
                fixedLegFlowslist.append(self.fixedLegFlows[i].Pack(builder))
            VanillaSwapResponseStartFixedLegFlowsVector(builder, len(self.fixedLegFlows))
            for i in reversed(range(len(self.fixedLegFlows))):
                builder.PrependUOffsetTRelative(fixedLegFlowslist[i])
            fixedLegFlows = builder.EndVector()
        if self.floatingLegFlows is not None:
            floatingLegFlowslist = []
            for i in range(len(self.floatingLegFlows)):
                floatingLegFlowslist.append(self.floatingLegFlows[i].Pack(builder))
            VanillaSwapResponseStartFloatingLegFlowsVector(builder, len(self.floatingLegFlows))
            for i in reversed(range(len(self.floatingLegFlows))):
                builder.PrependUOffsetTRelative(floatingLegFlowslist[i])
            floatingLegFlows = builder.EndVector()
        VanillaSwapResponseStart(builder)
        VanillaSwapResponseAddNpv(builder, self.npv)
        VanillaSwapResponseAddFairRate(builder, self.fairRate)
        VanillaSwapResponseAddFairSpread(builder, self.fairSpread)
        VanillaSwapResponseAddFixedLegBps(builder, self.fixedLegBps)
        VanillaSwapResponseAddFloatingLegBps(builder, self.floatingLegBps)
        VanillaSwapResponseAddFixedLegNpv(builder, self.fixedLegNpv)
        VanillaSwapResponseAddFloatingLegNpv(builder, self.floatingLegNpv)
        if self.fixedLegFlows is not None:
            VanillaSwapResponseAddFixedLegFlows(builder, fixedLegFlows)
        if self.floatingLegFlows is not None:
            VanillaSwapResponseAddFloatingLegFlows(builder, floatingLegFlows)
        vanillaSwapResponse = VanillaSwapResponseEnd(builder)
        return vanillaSwapResponse
