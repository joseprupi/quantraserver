# automatically generated by the FlatBuffers compiler, do not modify

# namespace: quantra

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Request to bootstrap multiple yield curves.
class BootstrapCurvesRequest(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BootstrapCurvesRequest()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBootstrapCurvesRequest(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # BootstrapCurvesRequest
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Valuation date (YYYY-MM-DD or YYYY/MM/DD) for evaluationDate().
    # BootstrapCurvesRequest
    def AsOfDate(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Index definitions needed by curve helpers (SwapHelper, OISHelper, etc.)
    # Every IndexRef in helpers must resolve to an IndexDef here.
    # BootstrapCurvesRequest
    def Indices(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.IndexDef import IndexDef
            obj = IndexDef()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # BootstrapCurvesRequest
    def IndicesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BootstrapCurvesRequest
    def IndicesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Bootstrap many curves at once.
    # BootstrapCurvesRequest
    def Curves(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.BootstrapCurveSpec import BootstrapCurveSpec
            obj = BootstrapCurveSpec()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # BootstrapCurvesRequest
    def CurvesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BootstrapCurvesRequest
    def CurvesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

def BootstrapCurvesRequestStart(builder):
    builder.StartObject(3)

def Start(builder):
    BootstrapCurvesRequestStart(builder)

def BootstrapCurvesRequestAddAsOfDate(builder, asOfDate):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(asOfDate), 0)

def AddAsOfDate(builder, asOfDate):
    BootstrapCurvesRequestAddAsOfDate(builder, asOfDate)

def BootstrapCurvesRequestAddIndices(builder, indices):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(indices), 0)

def AddIndices(builder, indices):
    BootstrapCurvesRequestAddIndices(builder, indices)

def BootstrapCurvesRequestStartIndicesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartIndicesVector(builder, numElems):
    return BootstrapCurvesRequestStartIndicesVector(builder, numElems)

def BootstrapCurvesRequestAddCurves(builder, curves):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(curves), 0)

def AddCurves(builder, curves):
    BootstrapCurvesRequestAddCurves(builder, curves)

def BootstrapCurvesRequestStartCurvesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartCurvesVector(builder, numElems):
    return BootstrapCurvesRequestStartCurvesVector(builder, numElems)

def BootstrapCurvesRequestEnd(builder):
    return builder.EndObject()

def End(builder):
    return BootstrapCurvesRequestEnd(builder)

try:
    from typing import List
except:
    pass

class BootstrapCurvesRequestT(object):

    # BootstrapCurvesRequestT
    def __init__(self):
        self.asOfDate = None  # type: str
        self.indices = None  # type: List[IndexDefT]
        self.curves = None  # type: List[BootstrapCurveSpecT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        bootstrapCurvesRequest = BootstrapCurvesRequest()
        bootstrapCurvesRequest.Init(buf, pos)
        return cls.InitFromObj(bootstrapCurvesRequest)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, bootstrapCurvesRequest):
        x = BootstrapCurvesRequestT()
        x._UnPack(bootstrapCurvesRequest)
        return x

    # BootstrapCurvesRequestT
    def _UnPack(self, bootstrapCurvesRequest):
        if bootstrapCurvesRequest is None:
            return
        self.asOfDate = bootstrapCurvesRequest.AsOfDate()
        if not bootstrapCurvesRequest.IndicesIsNone():
            self.indices = []
            for i in range(bootstrapCurvesRequest.IndicesLength()):
                if bootstrapCurvesRequest.Indices(i) is None:
                    self.indices.append(None)
                else:
                    indexDef_ = IndexDefT.InitFromObj(bootstrapCurvesRequest.Indices(i))
                    self.indices.append(indexDef_)
        if not bootstrapCurvesRequest.CurvesIsNone():
            self.curves = []
            for i in range(bootstrapCurvesRequest.CurvesLength()):
                if bootstrapCurvesRequest.Curves(i) is None:
                    self.curves.append(None)
                else:
                    bootstrapCurveSpec_ = BootstrapCurveSpecT.InitFromObj(bootstrapCurvesRequest.Curves(i))
                    self.curves.append(bootstrapCurveSpec_)

    # BootstrapCurvesRequestT
    def Pack(self, builder):
        if self.asOfDate is not None:
            asOfDate = builder.CreateString(self.asOfDate)
        if self.indices is not None:
            indiceslist = []
            for i in range(len(self.indices)):
                indiceslist.append(self.indices[i].Pack(builder))
            BootstrapCurvesRequestStartIndicesVector(builder, len(self.indices))
            for i in reversed(range(len(self.indices))):
                builder.PrependUOffsetTRelative(indiceslist[i])
            indices = builder.EndVector()
        if self.curves is not None:
            curveslist = []
            for i in range(len(self.curves)):
                curveslist.append(self.curves[i].Pack(builder))
            BootstrapCurvesRequestStartCurvesVector(builder, len(self.curves))
            for i in reversed(range(len(self.curves))):
                builder.PrependUOffsetTRelative(curveslist[i])
            curves = builder.EndVector()
        BootstrapCurvesRequestStart(builder)
        if self.asOfDate is not None:
            BootstrapCurvesRequestAddAsOfDate(builder, asOfDate)
        if self.indices is not None:
            BootstrapCurvesRequestAddIndices(builder, indices)
        if self.curves is not None:
            BootstrapCurvesRequestAddCurves(builder, curves)
        bootstrapCurvesRequest = BootstrapCurvesRequestEnd(builder)
        return bootstrapCurvesRequest
