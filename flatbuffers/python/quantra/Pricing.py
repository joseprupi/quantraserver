# automatically generated by the FlatBuffers compiler, do not modify

# namespace: quantra

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Pricing(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Pricing()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPricing(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Pricing
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Valuation date (YYYY-MM-DD). Used by: ALL
    # Pricing
    def AsOfDate(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Settlement date (YYYY-MM-DD). Used by: FixedRateBond, FloatingRateBond
    # Pricing
    def SettlementDate(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Index definitions. Used by: ALL floating-rate instruments and curve helpers.
    # Every IndexRef in the request must resolve to an IndexDef here.
    # Pricing
    def Indices(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.IndexDef import IndexDef
            obj = IndexDef()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Pricing
    def IndicesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Pricing
    def IndicesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Yield curves for discounting/forwarding. Used by: ALL
    # Pricing
    def Curves(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.TermStructure import TermStructure
            obj = TermStructure()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Pricing
    def CurvesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Pricing
    def CurvesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Market quotes (spot prices, FX rates). Used by: EquityOption (future)
    # Pricing
    def Quotes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.QuoteSpec import QuoteSpec
            obj = QuoteSpec()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Pricing
    def QuotesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Pricing
    def QuotesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Volatility surfaces (typed by product family). Used by: CapFloor, Swaption, EquityOption
    # Pricing
    def VolSurfaces(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.VolSurfaceSpec import VolSurfaceSpec
            obj = VolSurfaceSpec()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Pricing
    def VolSurfacesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Pricing
    def VolSurfacesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # Pricing models/engines (typed by product family). Used by: CapFloor, Swaption, EquityOption
    # Pricing
    def Models(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.ModelSpec import ModelSpec
            obj = ModelSpec()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Pricing
    def ModelsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Pricing
    def ModelsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Include bond analytics (duration, convexity). Used by: FixedRateBond, FloatingRateBond
    # Pricing
    def BondPricingDetails(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Include cash flow details. Used by: FixedRateBond, FloatingRateBond
    # Pricing
    def BondPricingFlows(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Include detailed swaption analytics (delta/vega/gamma/theta/DV01).
    # Pricing
    def SwaptionPricingDetails(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Include curve-rebump swaption analytics (Bloomberg-style).
    # Pricing
    def SwaptionPricingRebump(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Coupon pricers for floating legs. Used by: FloatingRateBond, VanillaSwap
    # Pricing
    def CouponPricers(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from quantra.CouponPricer import CouponPricer
            obj = CouponPricer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Pricing
    def CouponPricersLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Pricing
    def CouponPricersIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

def PricingStart(builder):
    builder.StartObject(12)

def Start(builder):
    PricingStart(builder)

def PricingAddAsOfDate(builder, asOfDate):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(asOfDate), 0)

def AddAsOfDate(builder, asOfDate):
    PricingAddAsOfDate(builder, asOfDate)

def PricingAddSettlementDate(builder, settlementDate):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(settlementDate), 0)

def AddSettlementDate(builder, settlementDate):
    PricingAddSettlementDate(builder, settlementDate)

def PricingAddIndices(builder, indices):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(indices), 0)

def AddIndices(builder, indices):
    PricingAddIndices(builder, indices)

def PricingStartIndicesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartIndicesVector(builder, numElems):
    return PricingStartIndicesVector(builder, numElems)

def PricingAddCurves(builder, curves):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(curves), 0)

def AddCurves(builder, curves):
    PricingAddCurves(builder, curves)

def PricingStartCurvesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartCurvesVector(builder, numElems):
    return PricingStartCurvesVector(builder, numElems)

def PricingAddQuotes(builder, quotes):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(quotes), 0)

def AddQuotes(builder, quotes):
    PricingAddQuotes(builder, quotes)

def PricingStartQuotesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartQuotesVector(builder, numElems):
    return PricingStartQuotesVector(builder, numElems)

def PricingAddVolSurfaces(builder, volSurfaces):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(volSurfaces), 0)

def AddVolSurfaces(builder, volSurfaces):
    PricingAddVolSurfaces(builder, volSurfaces)

def PricingStartVolSurfacesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartVolSurfacesVector(builder, numElems):
    return PricingStartVolSurfacesVector(builder, numElems)

def PricingAddModels(builder, models):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(models), 0)

def AddModels(builder, models):
    PricingAddModels(builder, models)

def PricingStartModelsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartModelsVector(builder, numElems):
    return PricingStartModelsVector(builder, numElems)

def PricingAddBondPricingDetails(builder, bondPricingDetails):
    builder.PrependBoolSlot(7, bondPricingDetails, 0)

def AddBondPricingDetails(builder, bondPricingDetails):
    PricingAddBondPricingDetails(builder, bondPricingDetails)

def PricingAddBondPricingFlows(builder, bondPricingFlows):
    builder.PrependBoolSlot(8, bondPricingFlows, 0)

def AddBondPricingFlows(builder, bondPricingFlows):
    PricingAddBondPricingFlows(builder, bondPricingFlows)

def PricingAddSwaptionPricingDetails(builder, swaptionPricingDetails):
    builder.PrependBoolSlot(9, swaptionPricingDetails, 0)

def AddSwaptionPricingDetails(builder, swaptionPricingDetails):
    PricingAddSwaptionPricingDetails(builder, swaptionPricingDetails)

def PricingAddSwaptionPricingRebump(builder, swaptionPricingRebump):
    builder.PrependBoolSlot(10, swaptionPricingRebump, 0)

def AddSwaptionPricingRebump(builder, swaptionPricingRebump):
    PricingAddSwaptionPricingRebump(builder, swaptionPricingRebump)

def PricingAddCouponPricers(builder, couponPricers):
    builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(couponPricers), 0)

def AddCouponPricers(builder, couponPricers):
    PricingAddCouponPricers(builder, couponPricers)

def PricingStartCouponPricersVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def StartCouponPricersVector(builder, numElems):
    return PricingStartCouponPricersVector(builder, numElems)

def PricingEnd(builder):
    return builder.EndObject()

def End(builder):
    return PricingEnd(builder)

try:
    from typing import List
except:
    pass

class PricingT(object):

    # PricingT
    def __init__(self):
        self.asOfDate = None  # type: str
        self.settlementDate = None  # type: str
        self.indices = None  # type: List[IndexDefT]
        self.curves = None  # type: List[TermStructureT]
        self.quotes = None  # type: List[QuoteSpecT]
        self.volSurfaces = None  # type: List[VolSurfaceSpecT]
        self.models = None  # type: List[ModelSpecT]
        self.bondPricingDetails = False  # type: bool
        self.bondPricingFlows = False  # type: bool
        self.swaptionPricingDetails = False  # type: bool
        self.swaptionPricingRebump = False  # type: bool
        self.couponPricers = None  # type: List[CouponPricerT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        pricing = Pricing()
        pricing.Init(buf, pos)
        return cls.InitFromObj(pricing)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, pricing):
        x = PricingT()
        x._UnPack(pricing)
        return x

    # PricingT
    def _UnPack(self, pricing):
        if pricing is None:
            return
        self.asOfDate = pricing.AsOfDate()
        self.settlementDate = pricing.SettlementDate()
        if not pricing.IndicesIsNone():
            self.indices = []
            for i in range(pricing.IndicesLength()):
                if pricing.Indices(i) is None:
                    self.indices.append(None)
                else:
                    indexDef_ = IndexDefT.InitFromObj(pricing.Indices(i))
                    self.indices.append(indexDef_)
        if not pricing.CurvesIsNone():
            self.curves = []
            for i in range(pricing.CurvesLength()):
                if pricing.Curves(i) is None:
                    self.curves.append(None)
                else:
                    termStructure_ = TermStructureT.InitFromObj(pricing.Curves(i))
                    self.curves.append(termStructure_)
        if not pricing.QuotesIsNone():
            self.quotes = []
            for i in range(pricing.QuotesLength()):
                if pricing.Quotes(i) is None:
                    self.quotes.append(None)
                else:
                    quoteSpec_ = QuoteSpecT.InitFromObj(pricing.Quotes(i))
                    self.quotes.append(quoteSpec_)
        if not pricing.VolSurfacesIsNone():
            self.volSurfaces = []
            for i in range(pricing.VolSurfacesLength()):
                if pricing.VolSurfaces(i) is None:
                    self.volSurfaces.append(None)
                else:
                    volSurfaceSpec_ = VolSurfaceSpecT.InitFromObj(pricing.VolSurfaces(i))
                    self.volSurfaces.append(volSurfaceSpec_)
        if not pricing.ModelsIsNone():
            self.models = []
            for i in range(pricing.ModelsLength()):
                if pricing.Models(i) is None:
                    self.models.append(None)
                else:
                    modelSpec_ = ModelSpecT.InitFromObj(pricing.Models(i))
                    self.models.append(modelSpec_)
        self.bondPricingDetails = pricing.BondPricingDetails()
        self.bondPricingFlows = pricing.BondPricingFlows()
        self.swaptionPricingDetails = pricing.SwaptionPricingDetails()
        self.swaptionPricingRebump = pricing.SwaptionPricingRebump()
        if not pricing.CouponPricersIsNone():
            self.couponPricers = []
            for i in range(pricing.CouponPricersLength()):
                if pricing.CouponPricers(i) is None:
                    self.couponPricers.append(None)
                else:
                    couponPricer_ = CouponPricerT.InitFromObj(pricing.CouponPricers(i))
                    self.couponPricers.append(couponPricer_)

    # PricingT
    def Pack(self, builder):
        if self.asOfDate is not None:
            asOfDate = builder.CreateString(self.asOfDate)
        if self.settlementDate is not None:
            settlementDate = builder.CreateString(self.settlementDate)
        if self.indices is not None:
            indiceslist = []
            for i in range(len(self.indices)):
                indiceslist.append(self.indices[i].Pack(builder))
            PricingStartIndicesVector(builder, len(self.indices))
            for i in reversed(range(len(self.indices))):
                builder.PrependUOffsetTRelative(indiceslist[i])
            indices = builder.EndVector()
        if self.curves is not None:
            curveslist = []
            for i in range(len(self.curves)):
                curveslist.append(self.curves[i].Pack(builder))
            PricingStartCurvesVector(builder, len(self.curves))
            for i in reversed(range(len(self.curves))):
                builder.PrependUOffsetTRelative(curveslist[i])
            curves = builder.EndVector()
        if self.quotes is not None:
            quoteslist = []
            for i in range(len(self.quotes)):
                quoteslist.append(self.quotes[i].Pack(builder))
            PricingStartQuotesVector(builder, len(self.quotes))
            for i in reversed(range(len(self.quotes))):
                builder.PrependUOffsetTRelative(quoteslist[i])
            quotes = builder.EndVector()
        if self.volSurfaces is not None:
            volSurfaceslist = []
            for i in range(len(self.volSurfaces)):
                volSurfaceslist.append(self.volSurfaces[i].Pack(builder))
            PricingStartVolSurfacesVector(builder, len(self.volSurfaces))
            for i in reversed(range(len(self.volSurfaces))):
                builder.PrependUOffsetTRelative(volSurfaceslist[i])
            volSurfaces = builder.EndVector()
        if self.models is not None:
            modelslist = []
            for i in range(len(self.models)):
                modelslist.append(self.models[i].Pack(builder))
            PricingStartModelsVector(builder, len(self.models))
            for i in reversed(range(len(self.models))):
                builder.PrependUOffsetTRelative(modelslist[i])
            models = builder.EndVector()
        if self.couponPricers is not None:
            couponPricerslist = []
            for i in range(len(self.couponPricers)):
                couponPricerslist.append(self.couponPricers[i].Pack(builder))
            PricingStartCouponPricersVector(builder, len(self.couponPricers))
            for i in reversed(range(len(self.couponPricers))):
                builder.PrependUOffsetTRelative(couponPricerslist[i])
            couponPricers = builder.EndVector()
        PricingStart(builder)
        if self.asOfDate is not None:
            PricingAddAsOfDate(builder, asOfDate)
        if self.settlementDate is not None:
            PricingAddSettlementDate(builder, settlementDate)
        if self.indices is not None:
            PricingAddIndices(builder, indices)
        if self.curves is not None:
            PricingAddCurves(builder, curves)
        if self.quotes is not None:
            PricingAddQuotes(builder, quotes)
        if self.volSurfaces is not None:
            PricingAddVolSurfaces(builder, volSurfaces)
        if self.models is not None:
            PricingAddModels(builder, models)
        PricingAddBondPricingDetails(builder, self.bondPricingDetails)
        PricingAddBondPricingFlows(builder, self.bondPricingFlows)
        PricingAddSwaptionPricingDetails(builder, self.swaptionPricingDetails)
        PricingAddSwaptionPricingRebump(builder, self.swaptionPricingRebump)
        if self.couponPricers is not None:
            PricingAddCouponPricers(builder, couponPricers)
        pricing = PricingEnd(builder)
        return pricing
