#!/usr/bin/env python3
"""
Quantra Process Manager

A CLI tool to manage multiple Quantra server processes with Envoy load balancing.

Usage:
    quantra start [--workers N] [--port PORT] [--base-port PORT]
    quantra stop
    quantra status
    quantra restart [--workers N]
    quantra logs [--follow]
    quantra health
"""

import argparse
import json
import os
import signal
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional, List, Dict, Any

import yaml

# Default configuration
DEFAULT_CONFIG = {
    "workers": 4,
    "port": 50051,           # Envoy listening port (client-facing)
    "base_port": 50055,      # First worker port
    "admin_port": 9901,      # Envoy admin port
    "health_check_interval": 1,
    "connect_timeout": 0.25,
}

QUANTRA_HOME = os.environ.get("QUANTRA_HOME", os.path.dirname(os.path.abspath(__file__)))
CONFIG_DIR = Path(QUANTRA_HOME) / ".quantra"
PID_FILE = CONFIG_DIR / "quantra.pid"
CONFIG_FILE = CONFIG_DIR / "config.json"
ENVOY_CONFIG = CONFIG_DIR / "envoy.yaml"
LOG_DIR = CONFIG_DIR / "logs"


def ensure_config_dir():
    """Create config directory if it doesn't exist."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    LOG_DIR.mkdir(parents=True, exist_ok=True)


def find_quantra_binary() -> Optional[Path]:
    """Find the sync_server binary."""
    # Check common locations
    candidates = [
        Path(QUANTRA_HOME) / "build" / "server" / "sync_server",
        Path("/workspace/build/server/sync_server"),
        Path("./build/server/sync_server"),
    ]
    
    for candidate in candidates:
        if candidate.exists() and candidate.is_file():
            return candidate
    
    # Try to find it
    result = subprocess.run(["which", "sync_server"], capture_output=True, text=True)
    if result.returncode == 0:
        return Path(result.stdout.strip())
    
    return None


def find_envoy_binary() -> Optional[Path]:
    """Find the envoy binary."""
    result = subprocess.run(["which", "envoy"], capture_output=True, text=True)
    if result.returncode == 0:
        return Path(result.stdout.strip())
    return None


def generate_envoy_config(port: int, base_port: int, workers: int, admin_port: int) -> dict:
    """Generate Envoy configuration for load balancing across workers."""
    
    # Build endpoints list
    endpoints = []
    for i in range(workers):
        endpoints.append({
            "endpoint": {
                "address": {
                    "socket_address": {
                        "address": "127.0.0.1",
                        "port_value": base_port + i
                    }
                }
            }
        })
    
    config = {
        "admin": {
            "address": {
                "socket_address": {
                    "address": "127.0.0.1",
                    "port_value": admin_port
                }
            }
        },
        "static_resources": {
            "listeners": [{
                "name": "quantra_listener",
                "address": {
                    "socket_address": {
                        "address": "0.0.0.0",
                        "port_value": port
                    }
                },
                "filter_chains": [{
                    "filters": [{
                        "name": "envoy.filters.network.http_connection_manager",
                        "typed_config": {
                            "@type": "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager",
                            "codec_type": "AUTO",
                            "stat_prefix": "quantra_grpc",
                            "route_config": {
                                "name": "local_route",
                                "virtual_hosts": [{
                                    "name": "quantra_service",
                                    "domains": ["*"],
                                    "routes": [{
                                        "match": {"prefix": "/"},
                                        "route": {
                                            "cluster": "quantra_workers",
                                            "timeout": "0s",
                                            "max_stream_duration": {
                                                "grpc_timeout_header_max": "0s"
                                            }
                                        }
                                    }]
                                }]
                            },
                            "http_filters": [
                                {
                                    "name": "envoy.filters.http.router",
                                    "typed_config": {
                                        "@type": "type.googleapis.com/envoy.extensions.filters.http.router.v3.Router"
                                    }
                                }
                            ]
                        }
                    }]
                }]
            }],
            "clusters": [{
                "name": "quantra_workers",
                "connect_timeout": "0.25s",
                "type": "STATIC",
                "lb_policy": "ROUND_ROBIN",
                "typed_extension_protocol_options": {
                    "envoy.extensions.upstreams.http.v3.HttpProtocolOptions": {
                        "@type": "type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions",
                        "explicit_http_config": {
                            "http2_protocol_options": {}
                        }
                    }
                },
                "circuit_breakers": {
                    "thresholds": [{
                        "priority": "DEFAULT",
                        "max_connections": 10000,
                        "max_requests": 10000,
                        "max_pending_requests": 10000
                    }]
                },
                "health_checks": [{
                    "timeout": "1s",
                    "interval": "1s",
                    "unhealthy_threshold": 2,
                    "healthy_threshold": 1,
                    "tcp_health_check": {}
                }],
                "load_assignment": {
                    "cluster_name": "quantra_workers",
                    "endpoints": [{
                        "lb_endpoints": endpoints
                    }]
                }
            }]
        }
    }
    
    return config


def save_pids(pids: Dict[str, Any]):
    """Save process PIDs to file."""
    ensure_config_dir()
    with open(PID_FILE, 'w') as f:
        json.dump(pids, f, indent=2)


def load_pids() -> Optional[Dict[str, Any]]:
    """Load process PIDs from file."""
    if not PID_FILE.exists():
        return None
    with open(PID_FILE, 'r') as f:
        return json.load(f)


def is_process_running(pid: int) -> bool:
    """Check if a process is running."""
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False


def start_workers(binary: Path, base_port: int, workers: int) -> List[subprocess.Popen]:
    """Start worker processes."""
    processes = []
    
    for i in range(workers):
        port = base_port + i
        log_file = LOG_DIR / f"worker_{port}.log"
        
        with open(log_file, 'w') as log:
            proc = subprocess.Popen(
                [str(binary), str(port)],
                stdout=log,
                stderr=subprocess.STDOUT,
                start_new_session=True
            )
            processes.append({"port": port, "pid": proc.pid})
            print(f"  Started worker on port {port} (PID: {proc.pid})")
    
    return processes


def start_envoy(config_path: Path) -> subprocess.Popen:
    """Start Envoy proxy."""
    envoy_binary = find_envoy_binary()
    if not envoy_binary:
        print("Error: envoy not found in PATH", file=sys.stderr)
        sys.exit(1)
    
    log_file = LOG_DIR / "envoy.log"
    
    with open(log_file, 'w') as log:
        proc = subprocess.Popen(
            [str(envoy_binary), "-c", str(config_path), "--log-level", "warn"],
            stdout=log,
            stderr=subprocess.STDOUT,
            start_new_session=True
        )
    
    return proc


def cmd_start(args):
    """Start Quantra cluster."""
    ensure_config_dir()
    
    # Check if already running
    pids = load_pids()
    if pids:
        running = any(is_process_running(w["pid"]) for w in pids.get("workers", []))
        if running:
            print("Quantra is already running. Use 'quantra stop' first or 'quantra restart'.")
            sys.exit(1)
    
    # Find binary
    binary = find_quantra_binary()
    if not binary:
        print("Error: sync_server binary not found.", file=sys.stderr)
        print("Set QUANTRA_HOME or ensure build/server/sync_server exists.", file=sys.stderr)
        sys.exit(1)
    
    print(f"Using binary: {binary}")
    
    workers = args.workers
    port = args.port
    base_port = args.base_port
    admin_port = args.admin_port
    
    print(f"\nStarting Quantra cluster:")
    print(f"  Workers: {workers}")
    print(f"  Client port: {port}")
    print(f"  Worker ports: {base_port}-{base_port + workers - 1}")
    print(f"  Admin port: {admin_port}")
    print()
    
    # Generate Envoy config
    envoy_config = generate_envoy_config(port, base_port, workers, admin_port)
    with open(ENVOY_CONFIG, 'w') as f:
        yaml.dump(envoy_config, f, default_flow_style=False)
    print(f"Generated Envoy config: {ENVOY_CONFIG}")
    
    # Start workers
    print("\nStarting workers...")
    worker_info = start_workers(binary, base_port, workers)
    
    # Give workers time to start
    time.sleep(0.5)
    
    # Start Envoy
    print("\nStarting Envoy load balancer...")
    envoy_proc = start_envoy(ENVOY_CONFIG)
    print(f"  Started Envoy (PID: {envoy_proc.pid})")
    
    # Save PIDs
    save_pids({
        "workers": worker_info,
        "envoy": {"pid": envoy_proc.pid},
        "config": {
            "workers": workers,
            "port": port,
            "base_port": base_port,
            "admin_port": admin_port
        }
    })
    
    # Wait for health checks
    print("\nWaiting for health checks...")
    time.sleep(2)
    
    # Check health
    cmd_health(args, quiet=False)
    
    print(f"\n✓ Quantra cluster started on port {port}")
    print(f"  Connect with: grpc://localhost:{port}")


def cmd_stop(args):
    """Stop Quantra cluster."""
    pids = load_pids()
    if not pids:
        print("Quantra is not running.")
        return
    
    print("Stopping Quantra cluster...")
    
    # Stop Envoy first
    envoy_pid = pids.get("envoy", {}).get("pid")
    if envoy_pid and is_process_running(envoy_pid):
        print(f"  Stopping Envoy (PID: {envoy_pid})...")
        try:
            os.kill(envoy_pid, signal.SIGTERM)
        except OSError:
            pass
    
    # Stop workers
    for worker in pids.get("workers", []):
        pid = worker["pid"]
        port = worker["port"]
        if is_process_running(pid):
            print(f"  Stopping worker on port {port} (PID: {pid})...")
            try:
                os.kill(pid, signal.SIGTERM)
            except OSError:
                pass
    
    # Clean up PID file
    if PID_FILE.exists():
        PID_FILE.unlink()
    
    print("✓ Quantra cluster stopped")


def cmd_status(args):
    """Show Quantra cluster status."""
    pids = load_pids()
    if not pids:
        print("Quantra is not running.")
        return
    
    config = pids.get("config", {})
    print("Quantra Cluster Status")
    print("=" * 50)
    print(f"Client port:  {config.get('port', 'N/A')}")
    print(f"Admin port:   {config.get('admin_port', 'N/A')}")
    print(f"Workers:      {config.get('workers', 'N/A')}")
    print()
    
    # Check Envoy
    envoy_pid = pids.get("envoy", {}).get("pid")
    envoy_status = "Running" if envoy_pid and is_process_running(envoy_pid) else "Stopped"
    print(f"Envoy:        {envoy_status} (PID: {envoy_pid})")
    
    # Check workers
    print("\nWorkers:")
    for worker in pids.get("workers", []):
        pid = worker["pid"]
        port = worker["port"]
        status = "Running" if is_process_running(pid) else "Stopped"
        print(f"  Port {port}: {status} (PID: {pid})")


def cmd_restart(args):
    """Restart Quantra cluster."""
    pids = load_pids()
    if pids:
        # Preserve config if not overridden
        config = pids.get("config", {})
        if args.workers is None:
            args.workers = config.get("workers", DEFAULT_CONFIG["workers"])
        if args.port == DEFAULT_CONFIG["port"]:
            args.port = config.get("port", DEFAULT_CONFIG["port"])
        if args.base_port == DEFAULT_CONFIG["base_port"]:
            args.base_port = config.get("base_port", DEFAULT_CONFIG["base_port"])
    
    cmd_stop(args)
    time.sleep(1)
    cmd_start(args)


def cmd_health(args, quiet=True):
    """Check health of all workers via Envoy admin API."""
    pids = load_pids()
    if not pids:
        print("Quantra is not running.")
        return
    
    admin_port = pids.get("config", {}).get("admin_port", DEFAULT_CONFIG["admin_port"])
    
    try:
        import urllib.request
        url = f"http://localhost:{admin_port}/clusters?format=json"
        with urllib.request.urlopen(url, timeout=5) as response:
            data = json.loads(response.read().decode())
            
            if not quiet:
                print("\nWorker Health:")
            
            all_healthy = True
            for cluster in data.get("cluster_statuses", []):
                if cluster.get("name") == "quantra_workers":
                    for host in cluster.get("host_statuses", []):
                        addr = host.get("address", {}).get("socket_address", {})
                        port = addr.get("port_value", "?")
                        health = host.get("health_status", {})
                        
                        if "failed_active_health_check" in health:
                            status = "✗ UNHEALTHY"
                            all_healthy = False
                        else:
                            status = "✓ healthy"
                        
                        if not quiet:
                            print(f"  Port {port}: {status}")
            
            if not quiet and all_healthy:
                print("\n✓ All workers healthy")
            elif not quiet:
                print("\n✗ Some workers unhealthy")
                
    except Exception as e:
        print(f"Could not check health: {e}")
        print("(Envoy admin API may not be ready yet)")


def cmd_logs(args):
    """Show logs from workers and envoy."""
    pids = load_pids()
    if not pids:
        print("Quantra is not running.")
        return
    
    if args.follow:
        # Tail all logs
        log_files = list(LOG_DIR.glob("*.log"))
        if not log_files:
            print("No log files found.")
            return
        
        print(f"Following logs from {LOG_DIR}...")
        print("Press Ctrl+C to stop.\n")
        
        try:
            subprocess.run(["tail", "-f"] + [str(f) for f in log_files])
        except KeyboardInterrupt:
            pass
    else:
        # Show recent logs
        for log_file in sorted(LOG_DIR.glob("*.log")):
            print(f"\n=== {log_file.name} ===")
            with open(log_file) as f:
                lines = f.readlines()
                for line in lines[-20:]:  # Last 20 lines
                    print(line, end="")


def main():
    parser = argparse.ArgumentParser(
        description="Quantra Process Manager - Manage distributed QuantLib pricing servers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  quantra start --workers 8          Start with 8 worker processes
  quantra start --workers 4 --port 9000   Start on custom port
  quantra status                     Show cluster status
  quantra health                     Check worker health
  quantra logs --follow              Tail all logs
  quantra restart --workers 16       Restart with more workers
  quantra stop                       Stop all processes
        """
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Commands")
    
    # start
    start_parser = subparsers.add_parser("start", help="Start Quantra cluster")
    start_parser.add_argument("-w", "--workers", type=int, default=DEFAULT_CONFIG["workers"],
                             help=f"Number of worker processes (default: {DEFAULT_CONFIG['workers']})")
    start_parser.add_argument("-p", "--port", type=int, default=DEFAULT_CONFIG["port"],
                             help=f"Client-facing port (default: {DEFAULT_CONFIG['port']})")
    start_parser.add_argument("--base-port", type=int, default=DEFAULT_CONFIG["base_port"],
                             help=f"First worker port (default: {DEFAULT_CONFIG['base_port']})")
    start_parser.add_argument("--admin-port", type=int, default=DEFAULT_CONFIG["admin_port"],
                             help=f"Envoy admin port (default: {DEFAULT_CONFIG['admin_port']})")
    
    # stop
    subparsers.add_parser("stop", help="Stop Quantra cluster")
    
    # status
    subparsers.add_parser("status", help="Show cluster status")
    
    # restart
    restart_parser = subparsers.add_parser("restart", help="Restart Quantra cluster")
    restart_parser.add_argument("-w", "--workers", type=int, default=None,
                               help="Number of worker processes")
    restart_parser.add_argument("-p", "--port", type=int, default=DEFAULT_CONFIG["port"],
                               help="Client-facing port")
    restart_parser.add_argument("--base-port", type=int, default=DEFAULT_CONFIG["base_port"],
                               help="First worker port")
    restart_parser.add_argument("--admin-port", type=int, default=DEFAULT_CONFIG["admin_port"],
                               help="Envoy admin port")
    
    # health
    subparsers.add_parser("health", help="Check worker health")
    
    # logs
    logs_parser = subparsers.add_parser("logs", help="Show logs")
    logs_parser.add_argument("-f", "--follow", action="store_true",
                            help="Follow log output")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    commands = {
        "start": cmd_start,
        "stop": cmd_stop,
        "status": cmd_status,
        "restart": cmd_restart,
        "health": cmd_health,
        "logs": cmd_logs,
    }
    
    commands[args.command](args)


if __name__ == "__main__":
    main()
